import 'package:interviewquestion/model/language_response.dart';
import 'package:interviewquestion/model/quiz_response.dart';
import 'package:interviewquestion/model/topic_response.dart';
import 'package:interviewquestion/model/interview_question_response.dart';

getLanguage() => <LanguageResponse>[
      LanguageResponse(
          id: 1,
          name: 'Flutter',
          author: 'Google',
          releaseDate: 2018,
          totalTopic: '10',
          image: ''),
      LanguageResponse(
          id: 2,
          name: 'Dart',
          author: 'Google',
          releaseDate: 2011,
          totalTopic: '9',
          image: ''),
      LanguageResponse(
          id: 3,
          name: 'Java',
          author: 'James Gosling',
          releaseDate: 1995,
          totalTopic: '21',
          image: ''),
      LanguageResponse(
          id: 4,
          name: 'Android',
          author: 'Andy Rubin, Rich Miner, Nick Sears, and Chris White',
          releaseDate: 2003,
          totalTopic: '11',
          image: ''),
      LanguageResponse(
          id: 5,
          name: 'Kotlin',
          author: 'JetBrains',
          releaseDate: 2011,
          totalTopic: '16',
          image: ''),
      LanguageResponse(
          id: 6,
          name: 'Jetpack compose',
          author: '',
          releaseDate: 2020,
          totalTopic: '0',
          image: ''),
    ];

getQuiz() => <QuizResponse>[
      QuizResponse(id: 1, name: 'Single', image: ''),
      QuizResponse(id: 2, name: 'Multiple', image: ''),
      QuizResponse(id: 3, name: 'Top Company', image: '')
    ];

getTopic() => <TopicResponse>[
      TopicResponse(id: 1, subjectId: 1, topic: 'Introduction', date: ''),
      TopicResponse(id: 2, subjectId: 1, topic: 'Install', date: ''),
      TopicResponse(id: 3, subjectId: 1, topic: 'Architecture', date: ''),
      TopicResponse(id: 4, subjectId: 1, topic: 'Widget', date: ''),
      TopicResponse(id: 5, subjectId: 1, topic: 'Navigation', date: ''),
      TopicResponse(id: 6, subjectId: 1, topic: 'Animation', date: ''),
      TopicResponse(id: 7, subjectId: 1, topic: 'BLoC Pattern', date: ''),
      TopicResponse(id: 8, subjectId: 1, topic: 'Keyword', date: ''),
      TopicResponse(id: 9, subjectId: 1, topic: 'Library', date: ''),
      TopicResponse(id: 10, subjectId: 1, topic: 'Deployment', date: ''),

      //DART
      TopicResponse(id: 1, subjectId: 2, topic: 'Introduction', date: ''),
      TopicResponse(id: 2, subjectId: 2, topic: 'Operators', date: ''),
      TopicResponse(id: 3, subjectId: 2, topic: 'Data type', date: ''),
      TopicResponse(id: 4, subjectId: 2, topic: 'Control Flow', date: ''),
      TopicResponse(id: 5, subjectId: 2, topic: 'Class & Method', date: ''),
      TopicResponse(id: 6, subjectId: 2, topic: 'Constructor', date: ''),
      TopicResponse(id: 7, subjectId: 2, topic: 'Inheritance & Interface', date: ''),
      TopicResponse(id: 8, subjectId: 2, topic: 'Typedef', date: ''),
      TopicResponse(id: 9, subjectId: 2, topic: 'Library', date: ''),

      //JAVA
      TopicResponse(id: 1, subjectId: 3, topic: 'Introduction', date: ''),
      TopicResponse(id: 2, subjectId: 3, topic: 'Install', date: ''),
      TopicResponse(id: 3, subjectId: 3, topic: 'Architecture', date: ''),
      TopicResponse(id: 4, subjectId: 3, topic: 'OOP', date: ''),
      TopicResponse(id: 5, subjectId: 3, topic: 'Variable', date: ''),
      TopicResponse(id: 6, subjectId: 3, topic: 'Data type', date: ''),
      TopicResponse(id: 7, subjectId: 3, topic: 'Flow Control', date: ''),
      TopicResponse(id: 8, subjectId: 3, topic: 'Class', date: ''),
      TopicResponse(id: 9, subjectId: 3, topic: 'Array', date: ''),
      TopicResponse(id: 10, subjectId: 3, topic: 'Package', date: ''),
      TopicResponse(id: 11, subjectId: 3, topic: 'Inheritance', date: ''),
      TopicResponse(id: 12, subjectId: 3, topic: 'Abstract class', date: ''),
      TopicResponse(id: 13, subjectId: 3, topic: 'Interface', date: ''),
      TopicResponse(id: 14, subjectId: 3, topic: 'Exception Handling', date: ''),
      TopicResponse(id: 15, subjectId: 3, topic: 'I/O', date: ''),
      TopicResponse(id: 16, subjectId: 3, topic: 'Multithreading', date: ''),
      TopicResponse(id: 17, subjectId: 3, topic: 'Collection', date: ''),
      TopicResponse(id: 18, subjectId: 3, topic: 'Generic', date: ''),
      TopicResponse(id: 19, subjectId: 3, topic: 'Anonymous class', date: ''),
      TopicResponse(id: 20, subjectId: 3, topic: 'JSON, GSON', date: ''),
      TopicResponse(id: 21, subjectId: 3, topic: 'XML', date: ''),

      TopicResponse(id: 1, subjectId: 4, topic: 'Introduction', date: ''),
      TopicResponse(id: 2, subjectId: 4, topic: 'Install', date: ''),
      TopicResponse(id: 3, subjectId: 4, topic: 'Architecture', date: ''),
      TopicResponse(id: 4, subjectId: 4, topic: 'Lifecycle', date: ''),
      TopicResponse(id: 5, subjectId: 4, topic: 'Intent', date: ''),
      TopicResponse(id: 6, subjectId: 4, topic: 'RecyclerView', date: ''),
      TopicResponse(id: 7, subjectId: 4, topic: 'Activity', date: ''),
      TopicResponse(id: 8, subjectId: 4, topic: 'Fragment', date: ''),
      TopicResponse(id: 9, subjectId: 4, topic: 'Layout', date: ''),
      TopicResponse(id: 10, subjectId: 4, topic: 'Service', date: ''),
      TopicResponse(id: 11, subjectId: 4, topic: 'ContentProvider', date: ''),

      TopicResponse(id: 1, subjectId: 5, topic: 'Introduction', date: ''),
      TopicResponse(id: 2, subjectId: 5, topic: 'Variable', date: ''),
      TopicResponse(id: 3, subjectId: 5, topic: 'Data type', date: ''),
      TopicResponse(id: 4, subjectId: 5, topic: 'Type Conversion', date: ''),
      TopicResponse(id: 5, subjectId: 5, topic: 'Operator', date: ''),
      TopicResponse(id: 6, subjectId: 5, topic: 'IO', date: ''),
      TopicResponse(id: 7, subjectId: 5, topic: 'Control Flow', date: ''),
      TopicResponse(id: 8, subjectId: 5, topic: 'Function', date: ''),
      TopicResponse(id: 9, subjectId: 5, topic: 'Array', date: ''),
      TopicResponse(id: 10, subjectId: 5, topic: 'Exception Handling', date: ''),
      TopicResponse(id: 11, subjectId: 5, topic: 'Null Safety', date: ''),
      TopicResponse(id: 12, subjectId: 5, topic: 'Collections', date: ''),
      TopicResponse(id: 13, subjectId: 5, topic: 'Annotations', date: ''),
      TopicResponse(id: 14, subjectId: 5, topic: 'Reflection', date: ''),
      TopicResponse(id: 15, subjectId: 5, topic: 'OOP', date: ''),
      TopicResponse(id: 16, subjectId: 5, topic: 'Null Safety', date: ''),
    ];

getInterviewQuestion() => <InterviewQuestionResponse>[
            //INTRODUCTION- FLUTTER
            InterviewQuestionResponse(id: 1, topicId: 1, subjectId: 1, question: 'What is flutter?', answer: 'First alpha version was released on May 2017; and after 1.5 years, Flutter got its first stable 1.0 release on December 4th, 2018. \nFlutter is a new tool offered by Google that let developers build cross-platform applications that could be executed in different systems such as Android or iOS with just a common or single codebase. \n\nThis tool is is built in C and C++ and provides a 2D rendering engine, a React-inspired functional-reactive framework, and a set of Material Design widgets. \n\nFlutter run on mobile (Android/iOS) devices, it will run on desktop, embedded systems and now, the web. \n\nFlutter enables a smooth and easy cross-platform mobile app development. You don’t need to develop an iOS and Android app separately. All you need is one codebase for both platforms. - Is free and open source. \n\n- Is based on Dart – a fast, object-oriented programming language which is in itself easy to learn, \n- Provide its own widgets, drawn with its own high-performance rendering engine. They are fast, pretty and customizable, \n\n- Thanks to rich widgets, Flutter apps look and feel great (you can create your own custom app design, but also use readily available UI elements following specific platforms’ guidelines) \n\n- The architecture of Flutter is based on the very popular reactive programming of nowadays (the same that React has been made from) \n\n- It’s becoming a serious competitor to React Native, but also to native app development \n\n- It is a stiff rival to React Native. \n\nOR \n\nAs React native, flutter is also avails you with the reactive style views; flutter to deliver the high performance has taken slight different path then React native, instead of JavaScript bridging, it uses dart (language created by Google). The peculiarity of the dart is that it is compiled “ahead of time” (AOT) into native code for the multiple platform. As JavaScript bridge is not required, it also improves the startup time of the app. \n\nIn addition to support for Android and iOS platforms, Flutter will be the main framework for developing applications for Google’s upcoming operating system, Fuchsia.'),
            InterviewQuestionResponse(id: 2, topicId: 1, subjectId: 1, question: 'Exaplain flutter advantage & disadvantage?', answer: 'Advantage \n\n- Extremely Fast App Development: With features like Hot-reload, code changes in Flutter are reflected as soon as the alterations are made. The Hot-reload usually doesn’t take more than milliseconds, which in turn, helps developers to maintain high speeds and dynamicity for mobile app development. Flutter widgets assist in the creation of native interfaces within few minutes. \n\n- Faster Running of Applications: Flutter apps provide smooth and seamless scrolling experiences while in use, without much hangs or cuts. \n\n- Reduced Efforts of Testing: Since Flutter apps are cross-platform, the testers do not always require to run the same set of tests on different platforms, such as iOS and Android, for the same app. Cross-platform application development enables applications to run on multiple platforms by writing the programming code only once (follows the WORA concept). This saves the time of the testing team. Thus, Flutter is used extensively by every mobile app developer, Utah, for faster testing, delivery and deployment of mobile applications. \n\n- Access of Native Features: It is extremely simple to set-up Flutter. Application developers can easily have access to native features of low-level machines where Flutter is initiated. Since it is cross-platform in nature, codes written in existing Swift, Java, Objective-C, etc. can be reused again and again. \n\n- Excellent User Interfaces: With built-in design-centric widgets, high-end development tools, advanced APIs, scrolling and navigation features, etc., Flutter helps in the creation of stunning and expressive user interfaces. \n\n- Reactive Framework: With reactive framework, the developers do not need to update UI contents manually. Once the variables are updated, the UI changes will be visible automatically. \n\n- Good for MVP: Flutter is good for developing MVP (Minimum Viable Product) apps due to its speedy development process and cross-platform nature. The cross-platform concept also aids in reducing costs when apps are developed with Flutter. Many modern undertakings and SMEs are thus employing flutter to increase development speeds and get the maximum outputs at lower costs. \n\n Disadvantage\n\n- Needs Continuous Support: Since Flutter is comparatively new, it needs continuous integration support through maintenance of scripts, as CI platforms like Jenkins do not support Flutter on a large scale. \n\n- Limited Libraries: The libraries to be accessed by the mobile application developers is very limited in Flutter. They do not always provide all the functionalities needed by the developer. Such functionalities need to be developed by the application developers by themselves.'),
            InterviewQuestionResponse(id: 3, topicId: 1, subjectId: 1, question: 'What is flutter io?', answer: 'Flutter is a mobile app SDK for building high-performance, high-fidelity, apps for iOS and Android, from a single codebase. The goal is to enable developers to deliver high-performance apps that feel natural on different platforms.'),
            InterviewQuestionResponse(id: 4, topicId: 1, subjectId: 1, question: 'What is dart in flutter?', answer: 'Dart is an object-oriented programming language by Google, which aims to help the developer build modern web applications. It covers client, server and now mobile with Flutter.'),
            InterviewQuestionResponse(id: 5, topicId: 1, subjectId: 1, question: 'What is Google Fuchsia?', answer: 'Fuchsia is a capability-based operating system currently being developed by Google.'),
            InterviewQuestionResponse(id: 6, topicId: 1, subjectId: 1, question: 'What does flutter do?', answer: 'For users, Flutter makes beautiful app UIs come to life. For developers, Flutter lowers the bar to entry for building mobile apps. It speeds up development of mobile apps and reduces the cost and complexity of app production across iOS and Android. For designers, Flutter helps deliver the original design vision, without loss of fidelity or compromises. It also acts as a productive prototyping tool.'),
            InterviewQuestionResponse(id: 7, topicId: 1, subjectId: 1, question: 'Coding style', answer: '- Classes, enums, typedefs, and type parameters should capitalize the first letter of each word (including the first word), and use no separators. \n\n- DO name libraries, packages, directories, and source files using lowercase_with_underscores. \n\n- Use lowerCamelCase for constant variables, including enum values. Ex. defaultTimeout \n\n- DO capitalize acronyms and abbreviations longer than two letters like words. HTTPS , Id'),
            InterviewQuestionResponse(id: 8, topicId: 1, subjectId: 1, question: 'Online json to dart model class created', answer: 'https://javiercbk.github.io/json_to_dart/'),
            InterviewQuestionResponse(id: 9, topicId: 1, subjectId: 1, question: 'File extention use flutter', answer: '- .gitignore - This is a hidden file IDE used to store the list of files which needs to be ingored when the source code is uploaded/checked into to any Git versioning system like Github or Bitbucket. \n\n- .metadata - This also is a hidden file used by IDEs to track the properties of the Flutter project. \n\n- .packages - In every language or SDK, we require a package manager in order to manage third-party or reusable controls or components (like we have Nuget for Visual Studio and .Net). In case of Dart, the Package Manager calls Pub and this hidden file is used by Pub to manage the packages for the project. \n\n- android.iml - This is an XML file used by IntelliJ engine to get the configuration of JAVA_MODULE used by the proect. .iml => IntelliJ Module File. \n\n- pubspec.lock - Just like .packages, this file is also used by the Pub package manager in order to get the concrete versions and other identifying information for every immediate and transitive dependency a package relies on. \n\n- pubspec.yaml  - This is the only file in all these files in which we have to make changes  when we have to use any third-party flutter package. This file is used by Pub package manager to get and load the packages used in the project. Please read this documentation about how to make changes in this file. YAML => Yet Another Multicolumn Layout. \n\n- README.md - This is a Markdown file used to mention any information about the project. It’s an optional file. \n\n- .iml - Just like android.iml this file contains configuration information about the project components which are used by IntelliJ engine. \n\n- _android.iml - This file also contains Android configuration information about the project which is used by IntelliJ engine.'),
            InterviewQuestionResponse(id: 10, topicId: 1, subjectId: 1, question: 'Read file assets', answer: 'Future<String> _loadRecordsAsset() async { return await rootBundle.loadString("assets/data/records.json"); } \n\nFuture<RecordList> loadRecords() async { \nString jsonString = await _loadRecordsAsset(); \nfinal jsonResponse = json.decode(jsonString); \nRecordList records = new RecordList.fromJson(jsonResponse); \nreturn records; }'),
            InterviewQuestionResponse(id: 11, topicId: 1, subjectId: 1, question: 'VS Code Shot-cut', answer: 'Ctrl+T (macOS: Cmd+T) - Show Workspace Symbols \n\nCtrl+Shift+O (macOS: Cmd+Shift+O) - Show Document Symbols \n\nCtrl+Shift+P (macOS: Cmd+Shift+P) - Open Command Palette \n\nCtrl+Space - Open Code Completion \n\nCtrl+. (macOS: Cmd+.) - Open Quick Fixes \n\nF2 - Rename Symbol \n\nShift+Alt+F (macOS: Cmd+Shift+F) - Format Document \n\nF12 - Go To Definition \n\nShift+F12 - Find References \n\nAlt+Shift+O - Organize Directives \n\nF4 - Show Type Hierarchy \n\nDebug Key Bindings \n\nCtrl+Alt+D - Launch Dart DevTools \n\nF5 - Start Debugging \n\nCtrl+F5 - Start Without Debugging \n\nShift+F5 - Stop Debugging \n\nCtrl+Shift+F5 (macOS: Cmd+Shift+F5) - Restart Debugging (or Hot Restart when debugging Flutter apps) \n\nCtrl+F5 - Hot Reload when debugging Flutter apps \n\nF9 - Toggle Breakpoint \n\nF10 - Step Over \n\nF11 - Step In \n\nShift+F11 - Step Out'),
            InterviewQuestionResponse(id: 12, topicId: 1, subjectId: 1, question: 'Hot Reload', answer: 'Hot Reload page says “if the modified code won’t be re-executed as a result of rebuilding the widget tree, then you won’t see its effects after hot reload.” \n\nLimitation of Hot – Reload in flutter \n1) enum \n2)class used to constant value (fixed type) \n3) Generic types'),
            InterviewQuestionResponse(id: 14, topicId: 1, subjectId: 1, question: 'JSON and serialization', answer: 'Mobile app that doesn’t need to communicate with a web server or easily store structured data at some point. When making network-connected apps, the chances are that we need to consume some good old JSON. \n\nManual serialization \nManual JSON serialization refers to using the built-in JSON decoder in dart:convert. It involves passing the raw JSON string to the JSON.decode() method, and then looking up the values you need in the Map<String, dynamic> the method returns. \n\nSerializing JSON inside model classes \nUser.fromJson constructor, for constructing a new User instance from a map structure \ntoJson method, which converts a User instance into a map.'),
            InterviewQuestionResponse(id: 15, topicId: 1, subjectId: 1, question: 'fromJson', answer: 'fromJson is the method which is called every time when we need to parse a single class object. \n\nYou can find special named constructor <class>.fromJson which constructs class from Map<String,dynamic>. This map will be created by Dio from endpoint response.'),
            InterviewQuestionResponse(id: 16, topicId: 1, subjectId: 1, question: 'Uri.encodeFull', answer: 'Removes all the dashes or extra characters present in our Uri'),
            InterviewQuestionResponse(id: 17, topicId: 1, subjectId: 1, question: 'Protobuf', answer: 'Protocol Buffers, aka Protobuf, is a language-neutral, platform-neutral, extensible mechanism for serializing structured data, which happens to support: \nDart (maintained by Google) \nJava (maintained by Google) \nKotlin via Java bindings (Non-JVM Kotlin is not yet supported, but it’s not our problem) \nObjC (maintained by Google) \nSwift (maintained by Apple)'),
            InterviewQuestionResponse(id: 18, topicId: 1, subjectId: 1, question: 'Platform channel', answer: 'Platform channels provide a simple mechanism for communicating between your Dart code and the platform-specific code of your host app. This means you can expose a platform service in your host app code and have it invoked from the Dart side.'),
            InterviewQuestionResponse(id: 19, topicId: 1, subjectId: 1, question: 'How to make androidx app in flutter?', answer: 'flutter create –androidx project_name'),
            InterviewQuestionResponse(id: 20, topicId: 1, subjectId: 1, question: 'What is the name of the Google project to bring flutter or web?', answer: 'Humming Bird'),
            InterviewQuestionResponse(id: 21, topicId: 1, subjectId: 1, question: 'Arrow Operator in flutter?', answer: 'Arrow Operator is a short hand in Dart. only one line of code.'),
            InterviewQuestionResponse(id: 22, topicId: 1, subjectId: 1, question: 'what is Flutter inspector?', answer: 'The inspector is powerful tool for visualizing and exploring Flutter these widget trees. \n\nIt is very useful 1) Understanding existing layouts 2) Diagnosing layout issues \n\nAdvatage : \nSelect widget mode \n2) Refresh widget \n3) Show/hide performance overlay \n4) Toggle platform \n5) Show debug paint \n6) show paint baselines \n7) Enable slow animations'),

            //INSTALL- FLUTTER
            InterviewQuestionResponse(id: 1, topicId: 2, subjectId: 1, question: 'Flutter command line shortcut.', answer: '1) flutter doctor \n\n2) flutter doctor --android-licenses \n\n3) Create the new app commmand prompt using: flutter create - - org package_name -a kotlin application_name (flutter create - -org com.jdkgroup restaurant -a kotlin interview_question) \n\n4) flutter run - - release or flutter run debug \n\n5) flutter build apk --release \n\n6)flutter build apk --release && flutter install \n\n7) set PATH=%PATH%;C:\Program Files\Java\jdk-11.0.1\bin \n\n8) set Path=%path%;C:\Users\admin\Software\flutter_beta\bin \n\n9) flutter config  C:/Users/kamlesh/AppData/Local\Android/sdk'),
            InterviewQuestionResponse(id: 2, topicId: 2, subjectId: 1, question: 'Flutter download', answer: 'https://flutter.dev/docs/get-started/install \n\nhttps://flutter.io/docs/development/tools/sdk/archive'),
            InterviewQuestionResponse(id: 3, topicId: 2, subjectId: 1, question: 'Flutter path set SDK', answer: '.flutter_settings - (C:\Users\kamlesh\AppData\Roaming)'),
            InterviewQuestionResponse(id: 4, topicId: 2, subjectId: 1, question: 'set path install flutter doctor --android-licenses before', answer: 'ANDROID_HOME: C:\Users\%username%\AppData\Local\Android\Sdk \n\nJAVA_HOME: C:\Program Files\Android\Android Studio\jre \n\nPath: C:\Users\%username%\ flutter\ bin'),
            InterviewQuestionResponse(id: 5, topicId: 2, subjectId: 1, question: 'Status code', answer: 'HTTP Status-Code: 0 (Communication failed) \nHTTP Status-Code: 200 (OK) \nHTTP Status-Code: 201 (Created) \nHTTP Status-Code: 202 (Accepted) \nHTTP Status-Code: 203 (Non-Authoritative Information) \nHTTP Status-Code: 204 (No Content) \nHTTP Status-Code: 205 (Reset Content) \nHTTP Status-Code: 206 (Partial Content) \nHTTP Status-Code: 300 (Multiple Choices) \nHTTP Status-Code: 301 (Moved Permanently) \nHTTP Status-Code: 302 (Temporary Redirect) \nHTTP Status-Code: 303 (See Other) \nHTTP Status-Code: 304 (Not Modified) \nHTTP Status-Code: 305 (Use Proxy) \nHTTP Status-Code: 400 (Bad Request) \nHTTP Status-Code: 401 (Unauthorized) \nHTTP Status-Code: 402 (Payment Required) \nHTTP Status-Code: 403 (Forbidden) \nHTTP Status-Code: 404 (Not Found) \nHTTP Status-Code: 405 (Method Not Allowed) \nHTTP Status-Code: 406 (Not Acceptable) \nHTTP Status-Code: 407 (Proxy Authentication Required) \nHTTP Status-Code: 408 (Request Time-Out) \nHTTP Status-Code: 409 (Conflict) \nHTTP Status-Code: 410 (Gone) \nHTTP Status-Code: 411 (Length Required) \nHTTP Status-Code: 412 (Precondition Failed) \nHTTP Status-Code: 413 (Request Entity Too Large) \nHTTP Status-Code: 414 (Request-URI Too Large) \nHTTP Status-Code: 415 (Unsupported Media Type) \nHTTP Status-Code: 500 (Internal Server Error) \nHTTP Status-Code: 501 (Not Implemented) \nHTTP Status-Code: 502 (Bad Gateway) \nHTTP Status-Code: 503 (Service Unavailable) \nHTTP Status-Code: 504 (Gateway Timeout) \nHTTP Status-Code: 505 (HTTP Version Not Supported)'),
            InterviewQuestionResponse(id: 6, topicId: 2, subjectId: 1, question: 'Flutter web create using vs code.', answer: 'ctrl + shift + p press \n\nFlutter: New Web Project \n\nflutter upgrade --force \n\npub global activate webdev \n\nwebdev serve \n\nwebdev serve --auto reload \n\nflutter packages pub global run webdev serve \n\nGit path set command prompt: set PATH=C:\Program Files\Git\bin;%PATH%'),
            InterviewQuestionResponse(id: 7, topicId: 2, subjectId: 1, question: 'Create Angular js web vs code.', answer: 'pub global activate webdev \n\nstagehand web-angular \n\npub global activate webdev \n\nwebdev serve'),

            //ARCHITECTURE- FLUTTER
            InterviewQuestionResponse(id: 1, topicId: 3, subjectId: 1, question: 'Flutter lifecycle', answer: 'When a Widget starts, it runs the initState() and build() methods respectively. Then the didUpdateConfig() and setState() methods work according to the interaction with the user. When the last application is closed, the dispose() method works. \n\n1) createState() : When Flutter is instructed to build a StatefulWidget, it immediately calls createState(). This method must exist. A StatefulWidget rarely needs to be more complicated than this. \n\n class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() => new _MyHomePageState(); } \n\n2) mounted() true : When createState creates the state class, a buildContext is assigned to that state. All widgets have a bool this.mounted property. It is turns true when the buildContext is assigned. It is an error to call setState when a widget is unmounted. \n\nThis property is useful when a method on your state calls setState() but it is not clear when or how often that method will be called. Perhaps its being called in response to a stream updating. You can use if (mounted) {... to make sure the State exists before calling setState(). \n\n3) initState() :  initState() (must call super.initState()) \nThis is the first method called when the widget is created (after the class constructor, of course.) \nIt represents the time elapsed before the application is up and the user meets the interface. \n\ninitState is called once and only once. It must also call super.initState(). \nThis @override method is the best time to: \n1) Initialize data that relies on the specific BuildContext for the created instance of the widget. \n2) Initialize properties that rely on this widgets parent in the tree. \n3) Subscribe to Streams, ChangeNotifiers, or any other object that could change the data on this widget. \n4) The framework will call this method exactly once for each State object it creates. Override this method to perform initialization of objects that are relevant to State of the given Widget in Widget tree. \n\n5) build() : This method is called often (think fps + render). It is a required, @override and must return a Widget. \n\n6) didUpdateWidget(Widget oldWidget) :  didUpdateWidget() is called if the parent widget changes and has to rebuild this widget (because it needs to give it different data), but it is being rebuilt with the same runtimeType, then this method is called. This is because Flutter is re-using the state, which is long lived. In this case, required is to initialize some data again, as one would in initState(). \nIf the state of build() method relies on a Stream or other object that can change, unsubscribe from the old object and re-subscribe to the new instance in didUpdateWidget(). \n\nThis method is basically the replacement for initState() if it is expected the Widget associated with the widgets state need to be rebuilt! \n\n7) didChangeDependencies() : The didChangeDependencies method is called immediately after initState on the first time the widget is built. It will also be called whenever an object that this widget depends on data from is called. For example, if it relies on an InheritedWidget, which updates. build is always called after didChangeDependencies is called, so this is rarely needed. However, this method is the first change you have to call BuildContext.inheritFromWidgetOfExactType. This essentially would make this State listen to changes on a Widget it is inheriting data from. \nThe docs also suggest that it could be useful if you need to do network calls (or any other expensive action) when an InheritedWidget updates. \nWhen this section changes location, when the application is taken down, when the next page is changed, etc. in cases where we will be done. \nThe following example covers the cases followed when the application is taken. The didChangeAppLifecycleState() method was used for this. This method can be called an observer before we can use widgetsbindingobserv is to add to our class as follows, initstate we start listening in method. \nclass  _LifecycleWatcherState  extends  State < LifecycleWatcher > with  WidgetsBindingObserver {  Widget Build ... in @Override void  initState () { super . initState (); WidgetsBinding .instance. addObserver ( this ); } // initState } \n\n8) setState() : Notify the widget that the State of objects changes in setState callback. It is used to notify the framework that data has changed, and the widget at this build context should be rebuilt. setState() takes a callback which cannot be async. \n\nState() method actually allows the rendering engine to re-run. We have defined a Button and Text. And every time the button is pressed, we want the number in the Text to increase. Lets explain this by dividing it into 2 We can increase the number without using setState, but we can not see it on the screen. Because the screen is not updated. Using setState, we can see the number on the screen as we can increase the number. Because here the rendering engine runs again and the screen is updated. \n\nvoid  _arttir () { setState (() {counter ++ ;}); } \n\n9) deactivate() :  The framework calls this method whenever it removes this State object from the tree , but it might be reinserted before the current frame change is finished. This method exists basically because State objects can be moved from one point in a tree to another. \n\n10) dispose() : Called when object is removed from widget tree that never build again. \n@Override void dispose() { super.dispose(); } \n\n11) mounted is false : The state object can never remount, and an error is thrown is setState() is called.)'),
            InterviewQuestionResponse(id: 2, topicId: 3, subjectId: 1, question: 'Flutter lifecycle', answer: 'initState - Called when this object is inserted into the tree. \n\ndidChangeDependencies - Called when a dependency of this [State] object changes. \n\ndidUpdateWidget - Called whenever the widget configuration changes. \n\ndeactivate - Called when this object is removed from the tree. \n\ndispose - Called when this object is removed from the tree permanently.'),
            InterviewQuestionResponse(id: 3, topicId: 3, subjectId: 1, question: 'What is the pubspec.yaml file and what does it do?', answer: 'Manage all assets, third party libraries. \n\nThe Pubspec.yaml allows you to define the packages your app relies on, declare your assets like images, audio, video, etc. It also allows you to set constraints for your app. For Android developers, this is roughly similar to a build.gradle file, but the differences between the two are also evident.'),
            InterviewQuestionResponse(id: 4, topicId: 3, subjectId: 1, question: 'Route', answer: 'The application of top-level routing table. \nWhen a named route is pushed with [Navigator.pushNamed], the route name is looked up in this map. If the name is present, the associated WidgetBuilder is used to construct a MaterialPageRoute that performs an appropriate transition, including Hero animations, to the new route.'),
            InterviewQuestionResponse(id: 5, topicId: 3, subjectId: 1, question: 'Dart VM', answer: 'During development, your Flutter app runs in the Dart VM. When you invoke hot reload, the updated source code files are injected into the Dart VM. After this finishes, Flutter rebuilds the widget tree. This makes hot reload and some other features possible.'),
            InterviewQuestionResponse(id: 6, topicId: 3, subjectId: 1, question: 'AOT', answer: 'An AOT compiler runs during creation of the program, before runtime. AOT compilers are normally used with static languages, which know the types of the data. AOT programs are compiled into native machine code, which is executed directly by the hardware at runtime. \n\nThis means that the Dart code is compiled into machine code and uses a stripped version of the Dart VM which is incapable of loading source code dynamically, but it is much faster. This mode is used on production builds for maximum performance. \nThis way we get the best of the two worlds. We get nice development features while we work on our app. And we get the best performance in the deployed app. \n\nThe dart VM supports building of native ARM code for the platforms you are developing for.'),
            InterviewQuestionResponse(id: 7, topicId: 3, subjectId: 1, question: 'JIT', answer: 'A JIT compiler runs during execution of the program, compiling on the fly. JIT compilers are typically used with dynamic languages, where types are not fixed ahead of time. JIT programs run via an interpreter or a virtual machine (VM). \n\nDart also offers Just In Time compilation. Flutter leverages this ability in development to make for faster development cycles. Features like hot reloads are help you to quickly and easily experiment, build UIs, add features and fix bugs. '),
            InterviewQuestionResponse(id: 8, topicId: 3, subjectId: 1, question: 'MaterialApp VS Material', answer: 'You should have a MaterialApp near the root of your app. And then use widgets that introduce a Material instance (Such a Scaffold, Appbar, Dialog, ...) when you want to use Text or InkWell.'),
            InterviewQuestionResponse(id: 9, topicId: 3, subjectId: 1, question: 'builder', answer: 'builder property is used to have a widget wrap all Navigator routes.'),
            InterviewQuestionResponse(id: 10, topicId: 3, subjectId: 1, question: 'How is Flutter native?', answer: 'Flutter uses a graphics engine called Skia to perform all UI rendering on the application side. It means that it doesn’t depend on OEM widgets provided by the platform. It just needs platform’s canvas to draw its own renderings. This ensures predictability and developer’s full control over the widgets and layout. \n\nIn addition to that, Flutter keeps its structure as a tree of widgets. By the way, almost everything in Flutter is a widget, which enables you to build your app in the structure of widgets inside widgets. This internal tree stucture allows Skia to render only the widgets that need to be updated, and retrieve unchanged or even moved widgets from cache.'),
            InterviewQuestionResponse(id: 11, topicId: 3, subjectId: 1, question: 'No layout preview… is this a problem?', answer: 'Not at all!.. Flutter has a feature called “hot reload” which enables you to hot-swap code changes while app is running. It takes subsecond to see the effects of your changes on screen. It’s definitely fast, but also smart since it preserves app’s runtime state between hot reloads. As a result, you get something better and more useful than layout previews.'),
            InterviewQuestionResponse(id: 12, topicId: 3, subjectId: 1, question: 'How various are the widgets supported for both platforms?', answer: 'The widget set provided by Flutter is extensive, especially for Material components. Based on my hands-on experince, using complex components such as drawers, bottom navigation bars, or tab bars is much easier in Flutter compared to Android development. While you are wandering around the widgets of Flutter, you can encounter very interesting ones such as UserAccountsDrawerHeader. Yes, even this comes as a ready-to-use UI component with Flutter. \n\nFor Cupertino (iOS-style) widgets, I can’t say the same extensiveness applies to them. There are enough of them to cover most of the iOS widgets, but not as detailed as Material components. It’s actually not surprising when you consider that Flutter is a Google product. However, I cannot say that this is a serious issue because the widget set is so customizable that you can get whatever look you want by playing with parameters of widgets and placing almost any one of them inside any other.'),
            InterviewQuestionResponse(id: 13, topicId: 3, subjectId: 1, question: 'When the state changes, widgets …….', answer: 'rebuild'),
            InterviewQuestionResponse(id: 14, topicId: 3, subjectId: 1, question: 'What is the material library which contains Flutter widgets implementing Material Design?', answer: 'Material.dart'),
            InterviewQuestionResponse(id: 15, topicId: 3, subjectId: 1, question: 'What type of widgets are used by Flutter to achieve Pixcel Perfect in iOS UI?', answer: 'Cupertino'),
            InterviewQuestionResponse(id: 16, topicId: 3, subjectId: 1, question: 'Skia library is used by flutter for rendering. This helps flutter run fast. What is the other google product which uses Skia for rendering?', answer: 'Android'),
            InterviewQuestionResponse(id: 17, topicId: 3, subjectId: 1, question: 'FlutterActivity', answer: 'Activity which displays a fullscreen Flutter UI. \nFlutterActivity is the simplest and most direct way to integrate Flutter within an Android app. \nThe Dart entrypoint executed within this Activity is “main()” by default. The entrypoint may be specified explicitly by passing the name of the entrypoint method as a String in EXTRA_DART_ENTRYPOINT, e.g., “myEntrypoint”. \nThe Flutter route that is initially loaded within this Activity is “/”.'),
            InterviewQuestionResponse(id: 18, topicId: 3, subjectId: 1, question: 'Flutter uses ……. compilation to increase the speed while execting.', answer: 'Ahead-of-Time'),
            InterviewQuestionResponse(id: 19, topicId: 3, subjectId: 1, question: 'What Library is used for rendering by flutter?', answer: 'Skia'),
            InterviewQuestionResponse(id: 20, topicId: 3, subjectId: 1, question: 'FlutterActivity responsibilities?', answer: 'Displays an Android launch screen. \nDisplays a Flutter splash screen. \nConfigures the status bar appearance. \nChooses the Dart execution app bundle path and entrypoint. \nChooses Flutter’s initial route. \nRenders Activity transparently, if desired. \nOffers hooks for subclasses to provide and configure a FlutterEngine.'),
            InterviewQuestionResponse(id: 21, topicId: 3, subjectId: 1, question: 'Eliminates the Use of XML files', answer: 'Android application develop then work is separated into layout and code. Layout should be written in XML and Views written in java. Since flutter is everything widget.'),
            InterviewQuestionResponse(id: 22, topicId: 3, subjectId: 1, question: 'didChangeAppLifecycleState() in flutter?', answer: 'Called when the system puts the app in the background or returns the app to the foreground. \n@override \nvoid didChangeAppLifecycleState(AppLifecycleState state) { }'),

            //WIDGETS- FLUTTER
            InterviewQuestionResponse(id: 1, topicId: 4, subjectId: 1, question: 'Widgets', answer: '1) Text: The Text widget lets you create a run of styled text within your application. \n\n2) Row, Column: These flex widgets let you create flexible layouts in both the horizontal (Row) and vertical (Column) directions. Its design is based on the web’s flexbox layout model. \n\nColumn and Row have the same properties. \nCrossAxisAlignment Property \n\ncrossAxisAlignment: CrossAxisAlignment.start \nCrossAxisAlignment.center \nCrossAxisAlignment.end \nCrossAxisAlignment.stretch \nCrossAxisAlignment.baseline \n\nMainAxisAlignment Propery \n\nMainAxisAlignment.start \nMainAxisAlignment.center \nMainAxisAlignment.end \nMainAxisAlignment.spaceAround \nMainAxisAlignment.spaceBetween \nMainAxisAlignment.spaceEvenly \nMainAxisSize.max \nMainAxisSize.min  \n\n3) Stack: Instead of being linearly oriented (either horizontally or vertically), a Stack widget lets you stack widgets on top of each other in paint order. You can then use the Positioned widget on children of a Stack to position them relative to the top, right, bottom, or left edge of the stack. Stacks are based on the web’s absolute positioning layout model. \n A stack displays a list of children on top of one and other. This functions much like the position property in CSS. \n\n4) Container: The Container widget lets you create a rectangular visual element. A container can be decorated with a BoxDecoration, such as a background, a border, or a shadow. A Container can also have margins, padding, and constraints applied to its size. In addition, a Container can be transformed in three dimensional space using a matrix. \n\n5) Image: For displaying images. \n\n6) Icon: For displaying Flutter built in Material and Cupertino icons. \n\n7) Scaffold: This is the root of every page in your app, which gives your app a basic layout structure. It makes it easy to implement bottom navigations, appBars, back buttons, etc. \n\n8) InheritedWidget: Provider pattern allows you to gather data in an InheritedWidget to be shared in multiple places.'),
            InterviewQuestionResponse(id: 2, topicId: 4, subjectId: 1, question: 'TextDirection and VerticalDirection', answer: 'textDirection: TextDirection.ltr \n\nTextDirection Property \nDetermines the order to lay children out horizontally and how to interpret start and end in the horizontal direction. \ncrossAxisAlignment: CrossAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.start, \n\nVerticalDirection Property \nDetermines the order to lay children out vertically and how to interpret start and end in the vertical direction. \nverticalDirection: VerticalDirection.down, verticalDirection: VerticalDirection.up'),
            InterviewQuestionResponse(id: 3, topicId: 4, subjectId: 1, question: 'What does State mean? What is setState()?', answer: 'In simple terms, “State” is a collection of the variable values of your widget. Anything that can change like a counter count, text, etc. can be part of State. Imagine a counter app, the main dynamic thing is the counter count. When the count changes, the screen needs to be refreshed to display the new value. setState() is essentially a way of telling the app to refresh and rebuild the screen with the new values.'),
            InterviewQuestionResponse(id: 5, topicId: 4, subjectId: 1, question: 'Stateful Widgets', answer: 'A widget that has mutable state. \nState is information that \n(1) Can be read synchronously when the widget is built. \n\n(2) Might change during the lifetime of the widget. It is the responsibility of the widget implementer to ensure that the State is promptly notified when such state changes, using State.setState'),
            InterviewQuestionResponse(id: 6, topicId: 4, subjectId: 1, question: 'Key', answer: 'Key is unique identifier of the widget. \nUse : Two or more Container \n\nExample: Container(key:key(" "))'),
            InterviewQuestionResponse(id: 7, topicId: 4, subjectId: 1, question: 'scaffoldKey', answer: 'currentContext : _scaffoldKey has a  field named currentContext, with which you can access current context of the Scaffold widget and perform operations which are based on context. \n\nExample: Navigator.of(_scaffoldKey.currentContext).pushNamed(routeName); \n\ncurrentState : _scaffoldKey has a field named currentState, with the use of currentState we can show Snackbar or close Drawers and many more. \n\nExample: \n_scaffoldKey.currentState.openDrawer() \n_scaffoldKey.currentState.closeDrawer()'),
            InterviewQuestionResponse(id: 8, topicId: 4, subjectId: 1, question: 'App Components', answer: '- FutureBuilder: Widget that builds itself based on the latest AsyncSnapshots. It serves as a bridge between Futures and the widget’s UI. \n\n- Stateless Widget: Widgets that depend only upon their own configuration info, such as a static image in an image view. \n\nA stateless widget has no internal state to manage. e.g Text, IconButton, Icon are examples of a stateless widget. \n\n- Stateful Widget: Widgets that need to maintain dynamic information and do so by interacting with a State object. \n\nA stateful widget is dynamic. The user can interact with a stateful widget or it changes over the time. \nA StatefulWidget creates a new State onject for each BuildContext. \n\n- GridView Builder: To show a list of movies in grid view. Create a scrollable 2D array of widgets. \n\n- Futures: Flutter uses future objects to represent Asynchronous operation. If any code block takes a long time and if, we did not run the code block as an asynchronous the app freeze. Asynchronous operations let your program run without getting blocked. \n\n- Json Mapping: Json mapping helps you to a parse json response came from web service. \n\n- Paging: We’re gonna make a network request every time for new movie pages when a user reaches at the end of GridView.'),
            InterviewQuestionResponse(id: 9, topicId: 4, subjectId: 1, question: 'Custom Border', answer: 'RoundedRectangleBorder, BeveledRectangleBorder, StadiumBorder \n\nshape: RoundedRectangleBorder( borderRadius: BorderRadius.vertical(bottom: Radius.circular(10.0))),'),
            InterviewQuestionResponse(id: 10, topicId: 4, subjectId: 1, question: 'Listview and Gridview syntax', answer: '1) Listview : ListView.builder(itemCount: interviewQuestionList.length, itemBuilder: (context, position) {}) \n\nSecond way create listview: arrayListName.map((data) => _buildListItem(context, data)).toList() \n\n2) Gridview: GridView.count(crossAxisCount: 2, controller: new ScrollController(keepScrollOffset: false), shrinkWrap: true, scrollDirection: Axis.vertical, children: dashBoardResponseList.map((value) {}) \n\nGridView Properties: \n1) childAspectRatio:(MediaQuery.of(context).size.width / (2 * 100)) \n\n2) GridView Builder: To show a list of movies in grid view. Create a scrollable 2D array of widgets.'),
            InterviewQuestionResponse(id: 11, topicId: 4, subjectId: 1, question: 'GroupedListView library', answer: 'return GroupedListView<Group, String>(collection: [Group("Test1", 1), Group("Test2", 2), Group("Test1", 3),], groupBy: (Group g) => g.groupName, listBuilder: (BuildContext context, Group g) => ListTile(title: Text(g.value.toString())), groupBuilder: (BuildContext context, String name) => Text(name));'),
            InterviewQuestionResponse(id: 12, topicId: 4, subjectId: 1, question: 'ListItem (Static ListView)', answer: '- leading : It is a Widget that is placed before the title, it is usually an image representing the user or a letter inside a circle or CircleAvatar in Flutter. \n- title : Widget defining the first text line \n- subtitle : Widget defining the second text line, it is placed under the title. \n\nreturn ListView(padding: EdgeInsets.symmetric(vertical: 8.0), children: _buildContactList()); \n\nclass _ContactListItem extends ListTile { _ContactListItem(Contact contact) : super( title : Text(contact.fullName), subtitle: Text(contact.email), leading: CircleAvatar(child: Text(contact.fullName[0]) ) ); } \n\nListView(\nchildren: <Widget>[\nListTile(\nleading: Icon(Icons.wb_sunny), \nenabled: false, \ntrailing: Icon(Icons.home), \nisThreeLine: true, \nonLongPress: (){}  \nsubtitle: Text(""), \n title: Text(""))]);'),
            InterviewQuestionResponse(id: 13, topicId: 4, subjectId: 1, question: 'Expanded', answer: 'Creates a widget that expands a child of a [Row], [Column], or [Flex]. expand to fill the available space in the main axis.  If multiple children are expanded, the available space is divided among them according to the flex factor. \n\nexpandStyle(int flex, Widget child) => Expanded(flex: flex,child: child);'),
            InterviewQuestionResponse(id: 14, topicId: 4, subjectId: 1, question: 'TextFormField (Edittext)', answer: 'String mobile; \nfinal TextEditingController _mobileController = new TextEditingController(); \nnew TextFormField(controller: _mobileController, decoration: new InputDecoration(hintText: '', labelText: '', /*suffixIcon: GestureDetector(onTap: () { },child: Icon(Icons.keyboard_arrow_right)),*/),keyboardType: TextInputType.phone, inputFormatters: [ MaskedTextInputFormatterShifter(maskONE: "XXX XXX XXXX", maskTWO: "XXX XXX XXXX"),], validator: UIData.validateMobile, onSaved: (String val) { mobile = val; })'),
            InterviewQuestionResponse(id: 15, topicId: 4, subjectId: 1, question: 'Radio Button', answer: 'This required me to implement radio buttons widget which was my first time dealing with selection widgets. \nThe radio widget takes 3 parameters namely value, groupValue and onChanged wherein value takes the position of particular radio button. \nThe radio widget takes 3 parameters namely value, groupValue and onChanged wherein value takes the position of particular radio button.'),
            InterviewQuestionResponse(id: 16, topicId: 4, subjectId: 1, question: 'RadioListTile', answer: 'RadioListTile, which combines this widget with a ListTile so that you can give the radio button a label.'),
            InterviewQuestionResponse(id: 17, topicId: 4, subjectId: 1, question: 'CheckboxListTile', answer: 'A ListTile with a Checkbox. In other words, a checkbox with a label. \nThe entire list tile is interactive: tapping anywhere in the tile toggles the checkbox. \nThe value, onChanged, and activeColor properties of this widget are identical to the similarly-named properties on the Checkbox widget. \nThe title, subtitle, isThreeLine, and dense properties are like those of the same name on ListTile.'),
            InterviewQuestionResponse(id: 18, topicId: 4, subjectId: 1, question: 'ExpansionTile', answer: 'A single-line ListTile with a trailing button that expands or collapses the tile to reveal or hide the children. \n\nThis widget is typically used with ListView to create an "expand / collapse" list entry. When used with scrolling widgets like ListView, a unique PageStorageKey must be specified to enable the ExpansionTile to save and restore its expanded state when it is scrolled in and out of view.'),
            InterviewQuestionResponse(id: 19, topicId: 4, subjectId: 1, question: 'FilterChip', answer: ''),
            InterviewQuestionResponse(id: 21, topicId: 4, subjectId: 1, question: 'Backdrop', answer: 'Backdrop is a StatefulWidget whose state manages the position and animation of the front layer.'),
            InterviewQuestionResponse(id: 22, topicId: 4, subjectId: 1, question: 'Image set folder. Round shape', answer: 'Add pubspec.yaml: assets: - assets/foldername/ \n\nMaterial(elevation: 4.0, shape: CircleBorder(), color: Colors.transparent, \nchild: Ink.image(image: AssetImage("assets/profile_default.jpg"), \nfit: BoxFit.cover, \nwidth: 120.0, \nheight: 120.0, \nchild: InkWell(onTap: onTap: () {},child: null,)\n))'),
            InterviewQuestionResponse(id: 23, topicId: 4, subjectId: 1, question: 'Image online set', answer: 'new NetworkImage("https://i.imgur.com/BoN9kdC.png")'),
            InterviewQuestionResponse(id: 24, topicId: 4, subjectId: 1, question: 'BottomAppBar', answer: ' BottomAppBar based on AppBar and which provides the possibility of having our action bar in the bottom and adding a floating action button (FAB).'),
            InterviewQuestionResponse(id: 25, topicId: 4, subjectId: 1, question: 'RaisedButton', answer: ''),
            InterviewQuestionResponse(id: 26, topicId: 4, subjectId: 1, question: 'Direction', answer: '1)  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start \n2) MainAxisSize mainAxisSize = MainAxisSize.max \n3)  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center \n4) VerticalDirection verticalDirection = VerticalDirection.down'),
            InterviewQuestionResponse(id: 27, topicId: 4, subjectId: 1, question: 'Slider', answer: 'A Slider is an input widget where user can set a value by dragging to or pressing on desired position. There are only two required arguments: value and onChanged, while the others are optional.'),
            InterviewQuestionResponse(id: 28, topicId: 4, subjectId: 1, question: 'DateTime Picker', answer: 'DateTimePickerFormField(\ninputType: InputType.both, \nformat: DateFormat("EEEE, MMMM d, yyyy "at" h:mma"), \neditable: false, \n\ndecoration: InputDecoration(\nlabelText: "DateTime", \nhasFloatingPlaceholder: false), \n\nonChanged: (dt) { \nsetState(() => date1 = dt); \nprint("Selected date: + date1"); \n})'),
            InterviewQuestionResponse(id: 29, topicId: 4, subjectId: 1, question: 'BuildContext', answer: 'A BuildContext is nothing else but a reference to the location of a Widget within the tree structure of all the Widgets which are built. \n\nA BuildContext only belongs to one widget. \n\nAs a State object is associated with a BuildContext, this means that the State object is NOT (directly) accessible through another BuildContext!'),
            InterviewQuestionResponse(id: 30, topicId: 4, subjectId: 1, question: 'PageView', answer: 'A PageView is a widget which generates scrollable pages on the screen. This can either be a fixed list of pages or a builder function which builds repeating pages. PageView acts similar to a ListView in the sense of constructing elements. \n\nPageView.builder(controller: controller, itemBuilder: (context, position) {}, itemCount: 10)'),
            InterviewQuestionResponse(id: 32, topicId: 4, subjectId: 1, question: 'CurvedNavigationBar', answer: 'Tab animation'),
            InterviewQuestionResponse(id: 33, topicId: 4, subjectId: 1, question: 'SingleChildScrollView', answer: 'SingleChildScrollView(\nphysics: BouncingScrollPhysics(), \nColumn(crossAxisAlignment: CrossAxisAlignment.start, \nchildren: <Widget>[\nListView.builder( \nshrinkWrap: true, \nphysics: NeverScrollableScrollPhysics(), \nitemBuilder: (context, index) {return buildListViewItem(snapshot, index, context);},\nitemCount: snapshot.data.items.length, \n), \n]);'),
            InterviewQuestionResponse(id: 34, topicId: 4, subjectId: 1, question: 'ListTile.divideTiles', answer: 'If you want to add dividers between the rows then use the ListTile.divideTiles constructor. \n\nListView(children: ListTile.divideTiles(context: context, tiles: [ListTile(title: Text(""))]).toList());'),
            InterviewQuestionResponse(id: 35, topicId: 4, subjectId: 1, question: 'AnimatedList', answer: ''),
            InterviewQuestionResponse(id: 36, topicId: 4, subjectId: 1, question: 'ListView.separated', answer: 'Creates a fixed-length scrollable linear array of list "items" separated by list item "separators". \n\nListView.separated(separatorBuilder: (context, index) => Divider( color: Colors.black), itemCount: 20, itemBuilder: (context, index) => Padding(padding: EdgeInsets.all(8.0), child: Center(child: Text("Index"))))'),
            InterviewQuestionResponse(id: 37, topicId: 4, subjectId: 1, question: 'ActionChip', answer: 'Represents an action related to primary content.'),
            InterviewQuestionResponse(id: 38, topicId: 4, subjectId: 1, question: 'ChoiceChip', answer: ''),
            InterviewQuestionResponse(id: 39, topicId: 4, subjectId: 1, question: 'InputChip', answer: 'A chip that represents a complex piece of information, such as an entity (person, place, or thing) or conversational text, in a compact form.'),
            InterviewQuestionResponse(id: 40, topicId: 4, subjectId: 1, question: 'FormState', answer: 'A FormState object can be used to save, reset, and validate every FormField that is a descendant of the associated Form. \n\nWe need to create a global key to save and get form values at any time and for validating purpose too.'),
            InterviewQuestionResponse(id: 41, topicId: 4, subjectId: 1, question: 'AlignmentGeometry', answer: 'Align Widget position in Container with following properties. Consider you have Container of width 200 & height 200 and if you want to align child to topLeft or topRight or bottomCenter etc. \n\nAlignment.topLeft - Alignment(-1.0, -1.0) \n\nAlignment.topCenter- Alignment(0.0, -1.0) \n\nAlignment.topRight - Alignment(1.0, -1.0) \n\nAlignment.centerLeft - Alignment(-1.0, 0.0) \n\nAlignment.center - Alignment(0.0, 0.0) \n\nAlignment.centerRight - Alignment(1.0, 0.0) \n\nAlignment.bottomLeft - Alignment(-1.0, 1.0) \n\nAlignment.bottomCenter - Alignment(0.0, 1.0) \n\nAlignment.bottomRight - Alignment(1.0, 1.0)'),
            InterviewQuestionResponse(id: 42, topicId: 4, subjectId: 1, question: 'EdgeInsetsGeometry', answer: 'Padding applied to inside whereas margin applied to outside. EdgeInsets is used to provide margin & padding to Widget or child inside Container. To have space between widgets use margin and to have space inside Container use padding property. \n\nContainer(padding: EdgeInsets.all(10.0), margin: EdgeInsets.only(left: 10.0)) \n\nEdgeInsets has following methods: \n1) EdgeInsets.only(left: 10.0), \n2) EdgeInsets.symmetric(horizontal: 10, vertical: 10), \n3) EdgeInsets.fromLTRB(left, top, right, bottom)'),
            InterviewQuestionResponse(id: 43, topicId: 4, subjectId: 1, question: 'Spacer()', answer: 'Spacer creates an adjustable, empty spacer that can be used to tune the spacing between widgets in a Flex container, like Row or Column.'),
            InterviewQuestionResponse(id: 44, topicId: 4, subjectId: 1, question: 'CupertinoSwitch', answer: 'IOS style switch'),
            InterviewQuestionResponse(id: 45, topicId: 4, subjectId: 1, question: 'Divider', answer: 'Vertical: VerticalDivider(color: Colors.grey, width: 1) \nHorizontal: Divider(color: Colors.grey, height: 1)'),
            InterviewQuestionResponse(id: 46, topicId: 4, subjectId: 1, question: 'ExpansionPanelList', answer: 'ExpansionPanelList: It has 3 main constructor animationDuration, children & expansionCallback. \n1. AnimationDuration is used to define the time required to expand/collapse. \n2. Children take the ExpansionPanel as a parameter which means ExpansionPanel will be used to create the hidden view and header. \n3. ExpansionCallback works wherever view expands/collapses. \n\nExpansionPanel:- It has 3 main constructor headerBuilder, body and isExpanded. \n1. HeaderBuilder is used to design the visible part of the list or title of the list/row. \n2. Body take widget, we can have any widget to expand and collapse. \n3. IsExpanded indicates whether panel in expanded or not.'),
            InterviewQuestionResponse(id: 47, topicId: 4, subjectId: 1, question: 'OutlineButton', answer: ''),
            InterviewQuestionResponse(id: 48, topicId: 4, subjectId: 1, question: 'BottomAppBar', answer: ''),
            InterviewQuestionResponse(id: 49, topicId: 4, subjectId: 1, question: 'CircularProgressIndicator', answer: 'Widget showCircularProgressBar() { return new Center( child: new CircularProgressIndicator(valueColor: new AlwaysStoppedAnimation<Color>(Colors.blue), strokeWidth: 1.0)); }'),
            InterviewQuestionResponse(id: 50, topicId: 4, subjectId: 1, question: 'persistentFooterButtons', answer: 'persistentFooterButtons: <Widget>[new Text("")]'),
            InterviewQuestionResponse(id: 51, topicId: 4, subjectId: 1, question: 'FadeInImage', answer: 'Property: image: NetworkImage(), fit: Boxfit., placeholder: AssetImage("assets/image/")'),
            InterviewQuestionResponse(id: 52, topicId: 4, subjectId: 1, question: 'mainAxisAlignment and crossAxisAlignment?', answer: 'Row \n\nhorizontal – mainAxisAlignment \nvertical – crossAxisAlignment \n\nColumn \nhorizontal – crossAxisAlignment \nvertical – mainAxisAlignment'),
            InterviewQuestionResponse(id: 53, topicId: 4, subjectId: 1, question: 'Type of ListView in flutter?', answer: '1) ListView.builder \n2) ListView \n3) ListView.separated \n4) ListView.custom \n5) ListView(scrollDirection: Axis.horizontal, children: List.generate(filterItemList.length, (index) {});'),
            InterviewQuestionResponse(id: 54, topicId: 4, subjectId: 1, question: 'ListView which property use horizontal and vertical data set?', answer: '1) scrollDirection: Axis.vertical \n2) scrollDirection: Axis.horizontal \n\nAxis is returns horizontal or vertical.'),
            InterviewQuestionResponse(id: 55, topicId: 4, subjectId: 1, question: 'Types of gridview flutter?', answer: '1) GridView.count() \n2) GridView.builder() \n3) GridView.custom() \n4) GridView.extend()'),
            InterviewQuestionResponse(id: 56, topicId: 4, subjectId: 1, question: 'Each widgets is an ……. declaration of part of the user interface?', answer: 'immutable'),
            InterviewQuestionResponse(id: 57, topicId: 4, subjectId: 1, question: 'widget', answer: 'Widget as a visual component (or a component that interacts with the visual aspect of an application). \nFlutter, everything is a Widget, down to the final build.call() \nEvery Widget has its own build() and its context. \nThe BuildContext is the parent of the widget returned by the build() method. \nBuildContext of the Widget that calls build() is not the same as the build context of the widget returned by build().'),
            InterviewQuestionResponse(id: 58, topicId: 4, subjectId: 1, question: 'Context', answer: 'Context is indicates location of the widget in widget tree. \nA context only belongs to one widget. \nContext is a BuildContext instance which gets passed to the builder of a widget in order to let it know where it is inside the Widget Tree of your app. \nEach widget in Widget tree has own context, and context is directly attached to state of object. Attachment is permeant mean context of the widget will not be change in entire life time of the App. \nEach widget has its own BuildContext, which becomes the parent of the widget returned by the StatelessWidget.build or State.build function. (And similarly, the parent of any children for RenderObjectWidgets.) \nWidget we can imaging context in Parent/child manner. \nWidget tree like Container -> Column -> Text->Button->Image. Here Each Widget in widget tree has own context like Container has it’s own context. Column has it’s own context… same for others. And context is permanent for it’s widget. \nContainer widget known as Parent widget in Widget tree and others are child widgets. So same We can imagine Context of Container widget also know as Parent context and others are child context. \nState objects with a BuildContext after creating them with StatefulWidget.createState and before calling initState. The association is permanent: the State object will never change its BuildContext. However, the BuildContext itself can be moved around the tree. \nBuildContext objects are actually Element objects. The BuildContext interface is used to discourage direct manipulation of Element objects.'),
            InterviewQuestionResponse(id: 59, topicId: 4, subjectId: 1, question: 'of()', answer: 'Widgets that want to use the State of inherited widgets need to be able to reference those inherited widgets. This usually comes in the form of the of method.'),
            InterviewQuestionResponse(id: 60, topicId: 4, subjectId: 1, question: 'RenderObject', answer: 'When you create any Widget, then widget itself has only configuration information mean If you create Opacity widget then main work of Opacity widget is to manage ‘opacity’ property that either 0 or 1. They don’t care about it’s child. Actually Child is created/Render some where else. That’s why we called each time create widget is not more expensive. \nSo we can say Widget is only blue-print, Layout/Rendering has been done some where else.'),
            InterviewQuestionResponse(id: 61, topicId: 4, subjectId: 1, question: 'Element', answer: 'Element is nothing but instance of the widget at particular location in Widget tree. \nWhen widget created, It inflated into Element. And element get inserted it into the tree at particular location. \nWidget is immutable but element is mutable property. \nMost of Elements has single child property like, Container, Opacity, Center etc and Some Elements has multiple children call children property. Like Column, Row, ListView and Etc. \nElement are created by “createElement()” method.'),
            InterviewQuestionResponse(id: 62, topicId: 4, subjectId: 1, question: 'Flutter ListView shadow remove or disable?', answer: 'physics: ClampingScrollPhysics(); That is used to multiple listview in flutter application.'),
            InterviewQuestionResponse(id: 63, topicId: 4, subjectId: 1, question: 'Flutter or dart remove single items using BLoC pattern?', answer: 'List<DispatchResponse> removeJobId = state.dispatchList; \nremoveJobId.removeWhere((item) => item.jobId == "remove unquie id"); \nyield state.copyWith(jobId: null, dispatchList: removeJobId);'),
            InterviewQuestionResponse(id: 64, topicId: 4, subjectId: 1, question: 'Flutter circle image using assets folder.', answer: ' CircleAvatar(backgroundImage: ExactAssetImage(imageProfile))'),
            InterviewQuestionResponse(id: 65, topicId: 4, subjectId: 1, question: 'UserAccountsDrawerHeader set background color in flutter?', answer: 'UserAccountsDrawerHeader(decoration: BoxDecoration(color: Colors.red), accountName: Text(sessionUsername), accountEmail: Text(mail), currentAccountPicture: CircleAvatar(backgroundColor: Colors.red, backgroundImage: NetworkImage(gravatarUrl)))'),
            InterviewQuestionResponse(id: 66, topicId: 4, subjectId: 1, question: 'Flutter Text SingleLine and elipse ?', answer: 'Text(overflow: TextOverflow.ellipsis, maxLines: 1, style: TextStyle())'),
            InterviewQuestionResponse(id: 67, topicId: 4, subjectId: 1, question: 'Flutter Text align right side?', answer: 'Text(textAlign: TextAlign.right)'),
            InterviewQuestionResponse(id: 68, topicId: 4, subjectId: 1, question: 'Difference between NetworkImage and Image.network in flutter?', answer: 'NetworkImage class creates an object the provides an image from the src URL passed to it. It is not a widget and does not output an image to the screen. \nImage.network creates a widget that displays an image on the screen. It is just a named constructor on the Image class(a stateful widget). \nIt sets the image property using the NetworkImage . This image property is used finally to display the image. \nIf you just want to display the image as a widget on screen use Image.network and use NetworkImage wherever an ImageProvider is expected.'),
            InterviewQuestionResponse(id: 69, topicId: 4, subjectId: 1, question: 'ExactAssetImage in flutter?', answer: 'Creates an object that fetches the given image from an asset bundle. \nExactAssetImage(“assets/images/mobile_box.png”)'),
            InterviewQuestionResponse(id: 70, topicId: 4, subjectId: 1, question: 'FileImage in flutter?', answer: 'Decodes the given File object as an image, associating it with the given scale. Used to load images from the file system in the target device. e.g. To display a newly downloaded image. \nFileImage(file object)'),
            InterviewQuestionResponse(id: 71, topicId: 4, subjectId: 1, question: 'CircleAvatar change the background color in flutter?', answer: 'CircleAvatar(backgroundColor: Colors.black.withOpacity(0.2), backgroundImage: new FileImage(), radius: 65.0)'),

            //NAVIGATION - FLUTTER
            InterviewQuestionResponse(id: 1, topicId: 5, subjectId: 1, question: 'Route', answer: 'A route is an abstract version of a screen or page in flutter. Imagine an app with only one screen. Maybe it’s a screen filled with text and images inside a StatelessWidget. Or think of the demo app you see when you start a new project in flutter, i.e. a StatefulWidget app. Those are apps with one screen or a route.'),
            InterviewQuestionResponse(id: 2, topicId: 5, subjectId: 1, question: 'Navigation', answer: 'In the Navigate to a new screen and back recipe, we learned how to Navigate to a new screen by creating a new route and pushing it to the Navigator.'),
            InterviewQuestionResponse(id: 3, topicId: 5, subjectId: 1, question: 'Navigation second screen', answer: 'Navigator.pushNamed(context, pagename);'),
            InterviewQuestionResponse(id: 4, topicId: 5, subjectId: 1, question: 'Return screen', answer: 'Navigator.pop(context);'),
            InterviewQuestionResponse(id: 5, topicId: 5, subjectId: 1, question: 'Push', answer: 'The navigation history is saved in a stack. If you want to add the new screen to the stack while navigating, use Navigator.pushNamed function, with context as the first argument and the route name as the second argument.'),
            InterviewQuestionResponse(id: 6, topicId: 5, subjectId: 1, question: 'pop', answer: 'To pop a screen from history stack, use Navigator.pop with context as the first argument.'),
            InterviewQuestionResponse(id: 7, topicId: 5, subjectId: 1, question: 'Pop and Push Named', answer: ''),
            InterviewQuestionResponse(id: 8, topicId: 5, subjectId: 1, question: 'Push Replacement Named', answer: 'pushReplacementNamed is very similar to popAndPushNamed. The difference is the removed routes exit animation is not run.'),
            InterviewQuestionResponse(id: 9, topicId: 5, subjectId: 1, question: 'Back Press (WillPopScope)', answer: 'Widget build(BuildContext context) { return new WillPopScope(onWillPop: DialogExitCall,child: new Scaffold(appBar: new AppBar(title: new Text("On Back pressed", style: new TextStyle(color: Colors.white))),body: new Center()));}'),
            InterviewQuestionResponse(id: 10, topicId: 5, subjectId: 1, question: 'Full screen UI', answer: 'SystemChrome.setEnabledSystemUIOverlays([])'),
            InterviewQuestionResponse(id: 11, topicId: 5, subjectId: 1, question: '@required', answer: '@required to specify that a named parameter is not optional.'),
            InterviewQuestionResponse(id: 12, topicId: 5, subjectId: 1, question: '@override', answer: '@override to identify those APIs given by a patent class that are implemented in a child class.'),
            InterviewQuestionResponse(id: 13, topicId: 5, subjectId: 1, question: 'Flutter keyboard hide.', answer: 'FocusScope.of(context).requestFocus(FocusNode());'),

            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 1, question: 'Tween animation', answer: 'In this type, you have to define the start and end value of the animation. As an example If you need to change the position of the UI widget, you can use this type. In there you can specify the start position and end position. We don’t need to worry about what is happening in between the value changes. The framework will handle that.'),
            InterviewQuestionResponse(id: 2, topicId: 6, subjectId: 1, question: 'Physics-based animation', answer: 'This a more advanced animation category than the tween. This type of animation can handle how to show the animation in like when we toss a coin.n. In here I am using a tween animation. Because we only need to change the position of the button when someone clicks it. \n\nAnimationController is responsible the control part of the animation. You will need the AnimationController to start animation, reverse animation, reset animation etc.'),

            //BLOC PATTERN - FLUTTER
            InterviewQuestionResponse(id: 1, topicId: 7, subjectId: 1, question: 'MobX', answer: 'MobX is state – management library. That makes to connect the reactive data of your application with the UI. This wiring is completely automatic data feels very natural. \n\nMobX is a state-management library that makes it simple to connect the reactive data of your application with the UI. This wiring is completely automatic and feels very natural. As the application-developer, you focus purely on what reactive-data needs to be consumed in the UI (and elsewhere) without worrying about keeping the two in sync.'),
            InterviewQuestionResponse(id: 2, topicId: 7, subjectId: 1, question: 'Mobx principles', answer: '1) We have access to an Observable selection of state (i.e. variables that change over the course of our application). \n\n2) We can display these state items within our view and respond to Action intents. \n\n3) We can modify the state and thus, update our Observable and corresponding view(s).'),
            InterviewQuestionResponse(id: 3, topicId: 7, subjectId: 1, question: 'Mobx generate file', answer: '1) New file generate: flutter packages pub run build_runner watch \n\n2) Dublicate file remove new generate: flutter packages pub run build_runner build --delete-conflicting-outputs'),
            InterviewQuestionResponse(id: 4, topicId: 7, subjectId: 1, question: 'Mobx', answer: 'Observables are variables which represent the reactive-state of our application. They are also called ‘Event Generators’ because the state or value of an observable changes from time to time. \nObservable annotation is mostly used with variables which is going to change. \nFor example, let say we have a variable named a, on button click, we want to update the variable value, the variable value getting updated based on the user action then such a variable should be used with observable. \n\nActions are functions that decide how to mutate the observables. Because of this property, they are also called ‘Mutators’. \nAction is usually bound with methods. \nTaking the above scenario, if we want to update the variable on click, we need a function to update the variable, the function will be used with action annotation. \n\nComputed Observables are values which depend upon observables and get triggered when the observable they depend on, changes its state. \nComputed changes its value as Observable changes its value. Computed value depends on Observable. \n\nObserver Widgets are a special type of widget which acts as a listener to the observable properties being rendered on the screen, and simply changes the state and re-renders them whenever any change is observed.'),
            InterviewQuestionResponse(id: 5, topicId: 7, subjectId: 1, question: 'BLoC Pattern', answer: 'The BLoC(Bussiness Logic Component) Pattern was announced officially by Paolo Soares in the Dart Conference 2018. \n\nBLoC is a pattern created and used by Google; it will help us to achieve a few things: \n\n- Separate business logic from presentation logic. \n\n- Embrace the asynchronous nature of UI apps. \n\n- Can be reused across different Dart applications, regardless of being a Flutter app or an Angular Dart application. \n\n The idea behind BloC is very simple: \n\n- BloC exposes Sink APIs to describe asynchronous inputs to our component. \n\n- BloC exposes Stream<T> APIs to describe asynchronous outputs from our component. \n\n- Finally, we can use a StreamBuilder widget to manage the stream of data, removing from us the effort of maintaining a subscription to the stream and redraws of the widget tree. \n\n- The StreamController has two additional objects already built-in: sink (orders supervisor) and stream (orders inspector). \n\n- Sink: It’s the ability to add new data to be processed by our stream. Comparing to our analogy, it is our order supervisor. The order is not directly ship it to the stream, first, the sink will receive it and then, the same sink will hand it to the stream. \n\n- StreamSubscription - when you no longer need to listen to a stream, cancel the subscription;'),
            InterviewQuestionResponse(id: 6, topicId: 7, subjectId: 1, question: 'BlocDelegate Interface', answer: '- onTransition is a method that can be implemented to handle whenever a Transition occurs from any Bloc. It is a great place to add universal logging/analytics. \n\n- BLoC’s input and output interfaces are all Stream / Sink \n\n- BLoC of dependencies are always injectable and environment independent \n\n- There is no conditional branch for each environment in BLoC \n\n- Implementation is free as long as it complies with the above rules'),
            InterviewQuestionResponse(id: 7, topicId: 7, subjectId: 1, question: 'Bloc Interface', answer: 'initialState is the state before any events have been processed (before mapEventToState has ever been called). initialState must be implemented. \n\n- mapEventToState is a method that must be implemented when a class extends Bloc. The function takes two arguments: state and event. mapEventToState is called whenever an event is dispatched by the presentation layer. mapEventToState must convert that event, along with the current state, into a new state and return the new state in the form of a Stream which is consumed by the presentation layer. \n\n- dispatch is a method that takes an event and triggers mapEventToState. dispatch may be called from the presentation layer or from within the Bloc (see examples) and notifies the Bloc of a new event. \n\n- Transform is a method that can be overridden to transform the Stream<Event> before mapEventToState is called. This allows for operations like distinct() and debounce() to be used. \n\n- onTransition is a method that can be overridden to handle whenever a Transition occurs. A Transition occurs when a new Event is dispatched and mapEventToState is called. onTransition is called before a Bloc of state has been updated. It is a great place to add bloc-specific logging/analytics.'),
            InterviewQuestionResponse(id: 8, topicId: 7, subjectId: 1, question: 'Stream', answer: 'Note - Stream controllers must always be closed when not needed anymore to prevent memory leaks. \n\nStreams represent flux of data and events. Streams, you can listen to data and event changes, and just as well, deal with what’s coming from the Stream with listeners. \n\nA stream is like a pipe with two ends, one end is the entrance and the other end is the exit. When data enters the stream, it flows to the other end of the stream where the subscriber receives it. \n- The advantage of using a stream over simply passing a variable is that you can keep sending data using it and every time you do, the widget that is subscribed to this stream will re-render. \n- By default, a stream controller can have one subscriber, but it can be used to broadcast a stream to multiple subscribers. \n\n- Streams provide an asynchronous sequence of data or events. \n- Data sequences include user-generated events and data read from files. \n- You can process a stream using either await for or listen() from the Stream API. \n- Streams provide a way to respond to errors. \n- There are two kinds of streams: single subscription or broadcast. \n\n-A StreamBuilder takes a stream and a builder method that gets executed every time a new value is received. The builder method provides a context and a snapshot which holds information about the new value like the hasData method which tells if the value received is not null. \n\n- StreamBuilder is a Widget that can convert a stream of user defined objects, to widgets. For example ListView. A StreamBuilder listens to a Stream and, each time some data goes out that Stream, it automatically rebuilds, invoking its builder callback. \n\nThis takes two arguments \n1) A stream that you can subscribe to \n2) A builder, that can convert the elements of the stream to widgets \n\n- Suppose, you have a Stream, that updates if there is any UI update (may be from user interaction, or may be resulted from network updates). If your “main” widget, includes a StreamBuilder, which listens to the stream, it can act as the element in charge of translating your states to views.'),
            InterviewQuestionResponse(id: 9, topicId: 7, subjectId: 1, question: 'StreamBuilder', answer: 'StreamBuilder that builds itself based on the latest snapshot of interaction with a Stream, and when there’s a new flux of data the Widget reload to deal with the new data.'),
            InterviewQuestionResponse(id: 10, topicId: 7, subjectId: 1, question: 'StreamBuilder VS FutureBuilder', answer: '- Both StreamBuilder and FutureBuilder have the same behavior: They listen to changes on their respective object. And trigger a new build when they are notified of a new value. \n\n- So in the end, their differences is how the object they listen to works. \n\n- Future are like Promise in JS or Task in c#. They are the representation of an asynchronous request. Futures have one and only one response. A common usage of Future is to handle http calls. What you can listen on a Future is it is state. Whether it is done, finished with a success, or had an error. But that it.\n\n- Stream on the other hand are like async Iterator in JS. This can be assimilated to a value that can change over time. It usually is the representation of web-sockets or events (such as click). By listening to a Stream you will get each new value and also if the Stream had an error or completed. \n\n- A Future can not listen to a variable change. It is a onetime response. Instead you will need to use a Stream. \n\n- FutureBuider use firebase operation.'),
            InterviewQuestionResponse(id: 11, topicId: 7, subjectId: 1, question: 'builder', answer: 'The builder function which will be invoked on each widget build. The builder takes the [BuildContext] and current bloc state and must return a [Widget]. This is analogous to the `builder` function in [StreamBuilder].'),
            InterviewQuestionResponse(id: 12, topicId: 7, subjectId: 1, question: 'BlocProvider.of(context)', answer: 'A Flutter widget which provides a bloc to its children via BlocProvider.of(context). It is used as a DI widget so that a single instance of a bloc can be provided to multiple widgets within a subtree.'),
            InterviewQuestionResponse(id: 13, topicId: 7, subjectId: 1, question: 'StreamController', answer: 'A controller with the stream it controls. \n\nThis controller allows sending data, error and done events on its stream. This class can be used to create a simple stream that others can listen on, and to push events to that stream. \n\nIt is possible to check whether the stream is paused or not, and whether it has subscribers or not, as well as getting a callback when either of these change. \n\nIn simple words, its our Pizza house. It is responsible for taking the orders, processing it and giving out the output. But what are the methods that make StreamController a complete Pizza house or in other words what are the methods that are responsible for taking orders, processing it and giving output? \n\nStreamController has two getters one is sink another is stream .sink is Mia here who will take the orders from the customer and pass it to the stream(John and then collect office). In simple words sink will add data to the stream of the StreamController. Now let’s talk about stream .It will pass the data to the outside world(collect office) after doing some processing(John).'),
            InterviewQuestionResponse(id: 14, topicId: 7, subjectId: 1, question: 'Types of Streams', answer: '1) Single-subscription Streams: This type of Stream only allows a single listener during the whole lifetime of that Stream.\n\n 2) Broadcast Streams: This second type of Stream allows any number of listeners.'),
            InterviewQuestionResponse(id: 15, topicId: 7, subjectId: 1, question: 'Provider', answer: 'The most basic form of provider. It takes a value and expose it, whatever the value is.'),
            InterviewQuestionResponse(id: 16, topicId: 7, subjectId: 1, question: 'ListenableProvider', answer: 'A provider specific for Listenable object. Listenable will listen the object and ask widgets which depends on it to rebuild whenever the listener is called.'),
            InterviewQuestionResponse(id: 17, topicId: 7, subjectId: 1, question: 'changeNotifierProvider', answer: 'A specification of ListenableProvider for ChangeNotifier. It will automatically call changeNotifier.dispose wen needed.'),
            InterviewQuestionResponse(id: 18, topicId: 7, subjectId: 1, question: 'ValueListenableProvider', answer: 'Listen to a ValueListenable and only expose Valueistenable.value.'),
            InterviewQuestionResponse(id: 19, topicId: 7, subjectId: 1, question: 'StreamProvider', answer: 'Listen to a Stream and expose the latest value emitted.'),
            InterviewQuestionResponse(id: 20, topicId: 7, subjectId: 1, question: 'What is ChangeNotifier?', answer: 'A class that can be extended or mixed in that provides a change notification API using [VoidCallback] for notifications.'),
            InterviewQuestionResponse(id: 21, topicId: 7, subjectId: 1, question: 'InheritedWidget', answer: 'The InheritedWidget allows your child widgets to access data from the parent widget. Use it to save the troble of having to pass data around between widgets.'),
            InterviewQuestionResponse(id: 22, topicId: 7, subjectId: 1, question: 'RxDart', answer: 'Stream controllers must always be closed when not needed anymore to prevent memory leaks. \n\nRxDart has 3 main types of StreamControllers, all of them are broadcast StreamControllers and they all return an Observable instead of a stream but they have some differences. \n\n1) Publish Subject: This Subject allows sending data, error and done events to the listener. \n\nPublish Subject provides subscribers with data that gets added to stream the after they have subscribed. \n\n2) Behavior Subject: It also allows sending data, error and done events to the listener, but the latest item that has been added to the subject will be sent to any new listeners of the subject. But don’t you worry, after that, any new events will be appropriately sent to the listeners. \n\nBehavior Subject provides subscribers with the last piece of data that has been added to the stream before they have subscribed in addition to new data that gets added. \n\nDefault value set - BehaviorSubject<bool> _isLoading = BehaviorSubject<bool>.seeded(true); \n\nIn this case, the stream always has data because we initialized it with a value of 0 and the BehaviorSubject will return the last value added, so the progress indicator will never be shown. I just wanted to give you an idea about the snapshot. \n\n3) Replay Subject: The ReplaySubject allow us the same: sending data, error and done events to the listener. But with a crucial difference here. As items are added to the subject, the ReplaySubject will store them and when the stream is listened to, those recorded items will be emitted to the listener. \n\nReplay Subject provides subscribers with all the data that has been added to the stream before they have subscribed in addition to new data that gets added. \n\n4) Observable<T> class : Observable allow us to send a notification to Widgets which is observing it and then deal with the flux of data. Observable class in RxDart extends from Stream, which implies in some great things: \n\nAll methods defined on the Stream class exist on Observable as well. \n\nAll Observable can be passed to any API that expects a Dart Stream as an input (including for example StreamBuilder Widget).'),
            InterviewQuestionResponse(id: 23, topicId: 7, subjectId: 1, question: 'What about dartson?', answer: 'The dartson library uses runtime reflection, which makes it not compatible with Flutter. \n\nAlthough we cannot use runtime reflection with Flutter, some libraries give us similarly easy to use APIs but are based on code generation instead. This approach is covered in more detail in the code generation libraries section.'),
            InterviewQuestionResponse(id: 24, topicId: 7, subjectId: 1, question: 'dart:convert', answer: 'which includes a straightforward JSON encoder and decoder.'),
            InterviewQuestionResponse(id: 25, topicId: 7, subjectId: 1, question: 'Serializing JSON inside model classes', answer: 'We can combat the previously mentioned problems by introducing a plain model class, which we call User. Inside the User class, we have: \n\n- a User.fromJson constructor, for constructing a new User instance from a map structure \n\n- a toJson method, which converts a User instance into a map.'),
            InterviewQuestionResponse(id: 26, topicId: 7, subjectId: 1, question: 'ValueNotifier', answer: 'A ValueNotifier can be used to hold a single value, and notify its listeners when this changes.'),

            //KEYWORD- FLUTTER
            InterviewQuestionResponse(id: 1, topicId: 8, subjectId: 1, question: 'Key', answer: 'Key is a unique identifier of the widget. It can be used to identify two or more Container with a different key. \n\nContainer(key: Key(""))'),
            InterviewQuestionResponse(id: 2, topicId: 8, subjectId: 1, question: 'await', answer: 'Use : await only use inside the async \nIt is suspends currently running function until the result is completed. Result is completion pf future. \n\nUsing await helps us to reduce boilerplate codes. General form of await : await e (where e = unary expression) e.g. (await file.copy(newPath)) \n\nAwait expressions evaluates e, suspends currently running function until the result is ready (or until future is completed). Result of await expression is the completion of future. \n\nImportant point: you can use await only inside the async function.'),
            InterviewQuestionResponse(id: 3, topicId: 8, subjectId: 1, question: 'Async', answer: 'Async: Modifier \nUse: Get the data from internet. \nThis async func will get data from the internet. \n\nAn async function is a function whose body is marked with an async modifier. \nWhen you call an async function, it immediately returns a Future; the body of the function is scheduled for execution later. \n\nWhen the body has executed, the Future that was returned by the call is completed with the result. (Regardless error or response).'),
            InterviewQuestionResponse(id: 4, topicId: 8, subjectId: 1, question: 'Future', answer: 'Flutter uses future objects to represent Asynchronous operation. If any code block takes a long time and if, we did not run the code block as an asynchronous the app freeze. Asynchronous operations let your program run without getting blocked. \n\nFlutter uses future objects to represent Asynchronous operation. If any code block takes a long time and if, we did not run the code block as an asynchronous the app freeze. Asynchronous operations let your program run without getting blocked. \n\nCommunication with native is always asynchronous, so the return type will always be of type “Future<>“'),
            InterviewQuestionResponse(id: 5, topicId: 8, subjectId: 1, question: 'FutureBuilder', answer: 'Widget that builds itself based on the latest AsyncSnapshots. It serves as a bridge between Futures and the widget’s UI.'),
            InterviewQuestionResponse(id: 6, topicId: 8, subjectId: 1, question: 'Flutter select image gallery or camera get path.', answer: 'Future getImage() async { File image = await ImagePicker.pickImage(source: ImageSource.gallery); print("Image path: " + image.path); }'),
            InterviewQuestionResponse(id: 7, topicId: 8, subjectId: 1, question: 'Media query', answer: 'var deviceSize = MediaQuery.of(context).size; \ndeviceSize.height \ndeviceSize.width;'),
            InterviewQuestionResponse(id: 8, topicId: 8, subjectId: 1, question: 'Json Mapping', answer: 'Json mapping helps you to a parse json response came from web service.'),
            InterviewQuestionResponse(id: 9, topicId: 8, subjectId: 1, question: 'Paging', answer: 'We’re gonna make a network request every time for new movie pages when a user reaches at the end of GridView.'),
            InterviewQuestionResponse(id: 10, topicId: 8, subjectId: 1, question: 'path_provider', answer: 'We use the path_provider package to get the commonly used location such as TemporaryDirectory and ApplicationDocumentsDirectory.'),
            InterviewQuestionResponse(id: 11, topicId: 8, subjectId: 1, question: 'Fetures', answer: 'Future objects used to Asynchronous operations. \nIf you sometime your bloc long time of operation perform, we did not run the code block as an async the app freeze. \nAsynchronous operations let your program run without getting blocked. \n\nFor example: Shooping app'),

            //LIBRARY- FLUTTER
            InterviewQuestionResponse(id: 1, topicId: 9, subjectId: 1, question: 'Library name', answer: 'smooth_star_rating \nhttp \ncupertino_icons \nfont_awesome_flutter \nrxdart \nflutter_masked_text \nflutter_localizations \nflutter_launcher_icons \nshared_preferences \njson_annotation \npath_provider \nurl_launcher \nsqflite \nintl \nfluttertoast \njson_serializable \nflutter_cupertino_date_picker \ncarousel_pro \npage_view_indicator \nflutter_search_panel \nanimated_text_kit \nstrings \nquick_actions \ncharts_flutter \nquery_params \nimage_picker \nflutter_sparkline \nflutter_staggered_grid_view \nmask_shifter \nbuild_runner \ndio \nflutter_multiselect \nflutter_tagging \nmultiselect_formfield \nflutter_pattern_formatter \nphotofilters \nimage_cropper \nimage_crop \nflutter_chips_input \nflare_flutter \neasy_listview \nphotofilters \nimage_cropper \nimage_crop \nflutter_chips_input \nmaterial_switch \nrich_alert \ngroovin_widgets \nsuperpower \nadsorptionview \nanimatedloginbutton \ngrouped_listview \nclippy_flutter'),
            InterviewQuestionResponse(id: 2, topicId: 9, subjectId: 1, question: 'SharedPreferences', answer: 'SharedPreferences is used for storing data key-value pair in the Android and iOS. \n\nSharedPreferences in flutter uses NSUserDefaultson iOS and SharedPreferences on Android, providing a persistent store for simple data. \n\nWe can only add int, String, double and bool using SharedPreferences.'),

            //DEPLOYMENT- FLUTTER
            InterviewQuestionResponse(id: 1, topicId: 10, subjectId: 1, question: 'Keystore generate', answer: 'keystore generate \n1) keytool -genkey -v -keystore d:/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias alisname \n2) keytool -list -v -keystore d:key.jks -alias alisname -storepass password -keypass password (get detail sh1 key) \n\nbuild.gradle def keystoreProperties = new Properties() \ndef keystorePropertiesFile = rootProject.file(key.properties) \nif (keystorePropertiesFile.exists()) { \nkeystoreProperties.load(new FileInputStream(keystorePropertiesFile)) } \n\nsigningConfigs { \nrelease { \nkeyAlias keystoreProperties[keyAlias] \nkeyPassword keystoreProperties[keyPassword] \nstoreFile file(keystoreProperties[storeFile]) \nstorePassword keystoreProperties[storePassword]}} \n\nbuildTypes { \nrelease { \n/* TODO: Add your own signing config for the release build. Signing with the debug keys for now, so `flutter run --release` works. */ \nsigningConfig signingConfigs.release }} \n\ncreate file key.properties in android folder keyAlias=alisname \nkeyPassword=kamal123 \nstoreFile=d:/keystore.jks \nstorePassword=kamal123'),
            InterviewQuestionResponse(id: 2, topicId: 10, subjectId: 1, question: 'App change icon', answer: 'Add this library: flutter_launcher_icons \n\npubsoec.yaml add \nflutter_icons:image_path: "icon/icon.png" \nandroid: true \nios: true \n\ncommand line run: \n1) flutter pub get \n2) flutter pub pub run flutter_launcher_icons:main'),
            InterviewQuestionResponse(id: 3, topicId: 10, subjectId: 1, question: 'Plugin add git', answer: 'flutter_my_toast: \ngit: \nurl: "https://github.com/JDKKamal/flutter_my_toast.git"'),

            //INTRODUCTION- DART
            InterviewQuestionResponse(id: 1, topicId: 1, subjectId: 2, question: 'What is dart?', answer: 'Dart is an application programming language. It is used to build web, server and mobile applications. \n\nDart is a general-purpose programming language originally developed by Google and later approved as a standard by Ecma (ECMA-408). \nIt is used to build web, server and mobile applications, and for Internet of Things (IoT) devices. \nIt is open-source software under a permissive free software license (modified BSD license). \nDart is an object-oriented, class defined, single inheritance language using C# style syntax that transcompiles optionally into JavaScript. It supports interfaces, mixins, abstract classes, reified generics, and optional typing. \n\nDart is a language based on a single-threaded model. In Dart also has its own process (or called threads) mechanism, called an isolate . The APPs startup entry mainfunction is an isolate.'),
            InterviewQuestionResponse(id: 2, topicId: 1, subjectId: 2, question: 'What is dart?', answer: 'Dart is the object-oriented, garbage-collected programming language that you use to develop Flutter apps. It was also created by Google, but is open-source, so it has community inside and outside Google. \n\nOther than its Google origins, Dart was chosen as the language of Flutter for the following reason: It’s one of very few languages that can be compiled both AOT (ahead-of-time) and JIT (just-in-time). \n\n1) JIT compilation is used during app development process since it enables hot reloads (about which I will talk more in next questions) and fast development cycles by compiling code at runtime on the fly. \n\n2) AOT compilation is used when you are done with development and ready for release. Code is then compiled AOT to native code, enabling fast startup and performant execution of the app. \n\nPersonally, what I’ve experienced about Dart is that it takes only couple of days to get used to it if you are a developer who is already familiar with Java or similar languages. So, if you are an Android developer for instance, the learning curve for this language should be very low for you. \n\nWith its clean but flexible syntax, Dart can be identified as a language that includes only the most wanted features of any high level programming language exists.'),
            InterviewQuestionResponse(id: 3, topicId: 1, subjectId: 2, question: 'What are the features if Dart?', answer: 'Dart is a class-based programming language. \n- It is an object-oriented, single inheritance. \n\n- Dart supports interfaces and abstract classes, reified generics, lexical scoping, closures, and optional static typing \n\n- Dart used Single threaded (asynchronous) \nOptional typing / type annotations \n\n- It comes with Dart Editor and SDK to provide an integrated experience, features like refactoring, break points, virtual machine are supported with Dart. \n\n- Dart can be converted to javascript with the help of dart2js tool,  which is highly useful hence it can work on all modern browsers with minimal code and it can run on servers via Virtual Machine which is provided with SDK.'),
            InterviewQuestionResponse(id: 4, topicId: 1, subjectId: 2, question: 'How to define private method or variable in dart?', answer: 'Dart doesn’t have the keywords public, protected, and private. If an identifier starts with an underscore _, it’s private to its library.'),
            InterviewQuestionResponse(id: 5, topicId: 1, subjectId: 2, question: 'How to use iso-server in google Dart language?', answer: 'Dart iso-server display web server library that dynamically loads code from filesystem to handle HTTp requests. The purpose of iso \n\nserver: \nTo show, how to dynamically load scripts into an isolate. \nPay with one may to build a ‘hot-swapping’ server.'),
            InterviewQuestionResponse(id: 6, topicId: 1, subjectId: 2, question: 'How Google Dart will get Popular', answer: 'Google is doing its hard work to get Dart accepted by web developers and community and arranging support, tools and execution environment for Google Dart. \n1 - Google will provide support of Dart in Google Chrome by integrating native virtual Machine and it will encourage to Microsoft and Mozilla to do the same. \n2 - Google will provide a Cross Compiler which will convert Dart toECMAScript 3so that it can run on NonDart Browser. This will be the major step in getting Dart Virtual Machine integrated on all popular browser might take some time.'),
            InterviewQuestionResponse(id: 7, topicId: 1, subjectId: 2, question: 'Why Dart is better than JavaScript?', answer: '- Classes and interface - Dart also provide the better functionality of classes and interfaces, you can use it like an object - based programming language. \n\n- Inheritance - Classes is present and therefore does now the extends keyword. Pretty damn simple in compression to javascript. \n\n- Global namespace - Dart have libraries, means if you have a keyword library, you must be understood by what is public visisble outside of it. \n\n- Dart known foreach - In javascript for each loop is not present, but you can use foreach in dart.'),
            InterviewQuestionResponse(id: 8, topicId: 1, subjectId: 2, question: 'Isolates', answer: 'It’s worth noting that Dart isolates have their own private heap, independent of one another. As each isolate runs in a separate thread, garbage collection events for each isolate should not impact the performance of others. Using isolates is a great way to avoid blocking the UI and offloading process intensive activities.'),
            InterviewQuestionResponse(id: 9, topicId: 1, subjectId: 2, question: 'Concurrent', answer: 'Dart is a single-thread programming language, still it has isolates to handle concurrency programming.'),
            InterviewQuestionResponse(id: 10, topicId: 1, subjectId: 2, question: 'Memory management', answer: 'Memory management in Dart is automatic and is delegated to the underlying JavaScript execution environment when the applications are run in the browser and to the Dart VM garbage collector when run stand alone.'),
            InterviewQuestionResponse(id: 11, topicId: 1, subjectId: 2, question: 'Object-oriented', answer: 'Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes descend from Object. Mixin-based inheritance means that although every class (except for Object) has exactly one superclass (multiple inheritance it not allowed), a class body can be reused in multiple class hierarchies. Interfaces are not present in the language reverting Dart to the C++ way of using abstract classes to implement interfaces.'),
            InterviewQuestionResponse(id: 12, topicId: 1, subjectId: 2, question: 'Program to an Interface, not an Implementation', answer: '\n\n- Implemented is the central tenet of object-oriented programming. Unfortunately this tenet is often ignored or misunderstood. \n\n- Dart works hard to preserve this principle in several ways, though it does so imperfectly. \n\n- Dart types are based on interfaces, not on classes. As a rule, any class can be used as an interface to be implemented by other classes, irrespective of whether the two share implementation (there are a few exceptions for core types like numbers, Booleans and strings). \n\n1.2 Design Principles 3 \n\n- There are no final methods in Dart. Dart allows overriding of almost all methods (again, a very small number of built-in operators are exceptions). \n\n- Dart abstracts from object representation by ensuring that all access to state is mediated by accessor methods. \n\n- Dart’s constructors allow for caching or for producing instances of subtypes, so using a constructor does not tie one to a specific implementation.'),
            InterviewQuestionResponse(id: 13, topicId: 1, subjectId: 2, question: 'Dart ‘pub’', answer: 'The package manager of Dart is called ‘pub’. The Dart applications specify the ‘pubspec’, which lists the dependencies for that application.'),
            InterviewQuestionResponse(id: 14, topicId: 1, subjectId: 2, question: 'Dart tools', answer: 'In this article, the code written in Dart is executed using DartPad. However, as stated earlier, for advanced tasks, it would be better to have an IDE installed in the local machine. The official documentation has recommended the WebStorm IDE. \n\nIn the case of Web app development, the Dartium browser can be used. \n\nApart from the Dartium browser, the other command line tools such as pub build (for building a Web app) and pub serve (for serving a Web app) can also be used. \n\nThere are a few other important Dart tools such as: \nDartanalyzer – This tool is used to evaluate and report potential errors in your Dart code. \n\nDartfmt – This tool is for formatting the Dart code. The official Dart style guide is followed while formatting the code. \n\nTo summarise, Dart is an interesting programming language with features to facilitate Web, mobile and command line apps. Its major advantages are its stability and support base. The SDK is constantly updated and, at the same time, is very stable. In the case of Web applications, the combination with AngularDart makes it a very powerful tool. The mobile application development platform, Flutter, enables the building of apps for both Android and iOS from the same codebase. Overall, Dart is a programming language that is easy to learn, and it enables the developer to build various types of apps.'),

            InterviewQuestionResponse(id: 1, topicId: 2, subjectId: 2, question: 'Operator', answer: 'Operators are instance methods with special names. \n\nYou can override operators'),
            InterviewQuestionResponse(id: 2, topicId: 2, subjectId: 2, question: 'Precedence', answer: 'unary postfix expr++ expr-- () [] . \nunary prefix -expr !expr ~expr ++expr --expr \nmultiplicative * / % ~/ \nadditive + - \nshift << >> \nrelational	is is! >= > <= < \nequality == != === !== \nbitwise AND & \nbitwise XOR ^ \nbitwise OR | \nlogical AND && \nlogical OR || \nconditional	expr ? expr : expr \nassignment = *= /= ~/= %= += -= <<= >>= &= ^= |='),
            InterviewQuestionResponse(id: 3, topicId: 2, subjectId: 2, question: 'Arithmetic', answer: '+ add \n– subtract \n-expr unary negation (reverse the sign of the expression) \n* multiply \n/ divide \n~/ divide, returning an integer result \n% get the remainder'),
            InterviewQuestionResponse(id: 4, topicId: 2, subjectId: 2, question: 'Pre | Post]fix Operators', answer: '++var var = var + 1 (expression value is var + 1) \nvar++ var = var + 1 (expression value is var) \n--var var = var – 1 (expression value is var – 1) \nvar-- var = var – 1 (expression value is var)'),
            InterviewQuestionResponse(id: 5, topicId: 2, subjectId: 2, question: 'Assignment Operators', answer: '==	equal (see discussion below) \n!= not equal \n=== same instance \n!== not the same instance \n>	greater than \n<	less than \n>= greater than or equal to \n<= less than or equal to \nis true if the object has the specified type (see discussion below) \nis! false if the object has the specified type'),
            InterviewQuestionResponse(id: 6, topicId: 2, subjectId: 2, question: 'Logical Operators', answer: '*= \n/=	\n~/= \n%= \n+= \n-= \n<<=	\n>>= \n&= \n^=	\n|='),
            InterviewQuestionResponse(id: 7, topicId: 2, subjectId: 2, question: 'Other Operators', answer: 'expr inverts the following expression (changes false to true, and vice versa) \n|| logical OR \n&& logical AND'),
            InterviewQuestionResponse(id: 9, topicId: 2, subjectId: 2, question: 'What are the data types in dart language?', answer: '1) Numbers(num, int, double) \n2) String \n3) Booleans(b) \n4) Lists(Map, List) \n5) Dynamic type'),
            InterviewQuestionResponse(id: 9, topicId: 2, subjectId: 2, question: '=> Operaror', answer: '=> is known as the fat arrow notation in Dart. It can be used in two different ways. Both have to do with defining functions. \nThe first way it can be used is as a shorthand for returning something. \n\nSo => x simply means {return x;}'),
            InterviewQuestionResponse(id: 10, topicId: 2, subjectId: 2, question: '.. (Cascade notation)', answer: 'The cascade notation is a simple way to change properties of an object, usually while creating it, rather than getting a reference to the object and changing properties one by one. '),

            InterviewQuestionResponse(id: 1, topicId: 3, subjectId: 2, question: 'What are the types of List in dart?', answer: '1) Fixed Length List : (length fixed) \n2) Growable List: (Length can change at runtime.'),
            InterviewQuestionResponse(id: 2, topicId: 3, subjectId: 2, question: 'What is the syntax for declare the Map using a Map constructor?', answer: 'var identifier = new Map()'),
            InterviewQuestionResponse(id: 3, topicId: 3, subjectId: 2, question: 'What are the various types of operators in Dart?', answer: '1) Arithmetic Operators \n\2) Equality and Relational Operators \n3) Type test Operators \n4) Bitwise Operators \n5) Assignment Operators \n6) Logical Operators'),
            InterviewQuestionResponse(id: 4, topicId: 3, subjectId: 2, question: 'List filter', answer: '1) short : listName.sort((a,b) { return a.lastName.toLowerCase().compareTo(b.lastName.toLowerCase()); }); \n\n2) where : listName.where((i) => i.subjectId == subjectId && i.topicId == topicId).toList() \n\n3)forEach: var fruits = [‘banana’, ‘pineapple’, ‘watermelon’]; fruits.forEach((fruit) => print(fruit));  \n\n4) map : var mappedFruits = fruits.map((fruit) => ‘I love "fruit").toList(); print(mappedFruits); \n\n5) contains() : var numbers = [1, 3, 2, 5, 4]; print(numbers.contains(2)); \n\n6) sort number : numbers.sort((num1, num2) => num1 - num2); \n\n7) reduce() : var sum = numbers.reduce((curr, next) => curr + next); \n\n8) fold() : const initialValue = 10; var sum2 = numbers.fold(initialValue, (curr, next) => curr + next); print(sum2); \n\n9) every() : listName.every((user) => user[“age”] >= 18); \n\n10) firstWhere() : var nameJ = users.firstWhere((user) => user[“name”].startsWith(‘J’), orElse: () => null); print(nameJ); \n\n11) singleWhere() : var under18s = users.singleWhere((user) => user[“age”] < 18, orElse: () => null); print(under18s); \n\n12) take(), skip() : var fiboNumbers = [1, 2, 3, 5, 8, 13, 21]; print(fiboNumbers.take(3).toList()); // => [1, 2, 3] print(fiboNumbers.skip(5).toList()); \n\n13) List.from() : Creates a new list from the given collection \nvar clonedFiboNumbers = List.from(fiboNumbers); \n\n14) expand() : var pairs = [[1, 2], [3, 4]]; var flattened = pairs.expand((pair) => pair).toList(); \n\nvar input = [1, 2, 3]; var duplicated = input.expand((i) => [i, i]).toList(); print(duplicated);'),
            InterviewQuestionResponse(id: 5, topicId: 3, subjectId: 2, question: 'Dart collection', answer: '1) List : A List is simply an ordered group of objects. \n\n2) Set : Set represents a collection of objects in which each object can occur only once. The dart:core library provides the Set class to implement the same. \n\n3) Map : The Map object is a simple key/value pair. Keys and values in a map may be of any type. A Map is a dynamic collection. In other words, Maps can grow and shrink at runtime.  \n\n4) Queue : A Queue is a collection that can be manipulated at both ends. Queues are useful when you want to build a first-in, first-out collection. Simply put, a queue inserts data from one end and deletes from another end. The values are removed / read in the order of their insertion.'),
            InterviewQuestionResponse(id: 6, topicId: 3, subjectId: 2, question: 'Iterating Collections', answer: 'The Iterator class from the dart:core library enables easy collection traversal. Every collection has an iterator property. This property returns an iterator that points to the objects in the collection'),
            InterviewQuestionResponse(id: 7, topicId: 3, subjectId: 2, question: 'Group by', answer: 'Groups all items in the iterable using the provided functions. \n\nvar data = [ {"title": "Avengers", "release_date": "10/01/2019"}, {"title": "Creed", "release_date": "10/01/2019"}, {"title": "Jumanji", "release_date": "30/10/2019"}]; \n\nvar newMap = groupBy(data, (obj) => obj["release_date"]); \n//var newMap = groupBy(data, (obj) => obj["release_date"] == "10/01/2019"); \n\nprint(newMap);'),
            InterviewQuestionResponse(id: 8, topicId: 3, subjectId: 2, question: 'Fundamental Dart libraries', answer: 'The three most fundamental Dart libraries are listed below: \n\ndart:core – All basic functionalities of Dart such as strings, collections, dates and URIs are processed using this library. \n\ndart:html – This library is the wrapper for DOM manipulation which is much used with Web apps. \n\ndart:io – This library is used with command line apps.'),

            InterviewQuestionResponse(id: 1, topicId: 4, subjectId: 2, question: 'Control Flow', answer: 'A block statement supports sequencing of code. \n\nIterate or loop over a blocks of code.'),
            InterviewQuestionResponse(id: 2, topicId: 4, subjectId: 2, question: 'Control Flow Statements', answer: 'If Else \nFor Loop \nFor Loop with Callbacks \nFor In Loop \nFor Each Item \nWhile \nDo While \nBreak \nContinue \nSwitch \nAssert'),

            InterviewQuestionResponse(id: 1, topicId: 5, subjectId: 2, question: 'Class', answer: 'The root class is Object. \n\nA class is made up of constructors, instance members and static members. \n\nThe static members of a class are its static methods, getters, setters and static variables. \n\nEvery class has a single superclass except class Object which has no superclass. \n\nA class may implement a number of interfaces by declaring them in its implements clause. \n\nAn abstract class is a class that is either explicitly declared with the abstract modifier'),
            InterviewQuestionResponse(id: 2, topicId: 5, subjectId: 2, question: 'Dart parsing', answer: '1) parseInt() \n2) parseFloat() \n3) Number() \n\n1) String to int:  var one = int.parse("1"); \n2) String to double:  var onePointOne = double.parse("1.1"); \n3) int to String:  String oneAsString = 1.toString(); \n4) double to String: String piAsString = 3.14159.toStringAsFixed(2);'),
            InterviewQuestionResponse(id: 3, topicId: 5, subjectId: 2, question: 'Simple class', answer: 'imple class with only instance variables'),
            InterviewQuestionResponse(id: 4, topicId: 5, subjectId: 2, question: 'Class constructors ', answer: 'Constructor with instance parameters'),
            InterviewQuestionResponse(id: 5, topicId: 5, subjectId: 2, question: 'Private instance variables', answer: 'Private instance variables start with an underscore _lat'),
            InterviewQuestionResponse(id: 6, topicId: 5, subjectId: 2, question: 'What is method overriding in Dart?', answer: 'In Dart, Method Overriding is a technique that child class redefines a method in its parent class. \n\nvoid main() { Child c = new Child(); c.m1(12); } \n\nclass Parent { void m1(int a){ print(“value of a “);} } \n\nclass Child extends Parent { \n@override void m1(int b) { print(“value of b “); }}'),
            InterviewQuestionResponse(id: 7, topicId: 5, subjectId: 2, question: 'Functions', answer: '- unctions include function declarations, methods, getters, setters and function literals. \n\n- All functions have a signature and a body \n\n- A function body of the form  => e is equivalent to a body of the form {return e;} \n\n- If the last statement of a function is not a return statement, the statement returns null.'),
            InterviewQuestionResponse(id: 8, topicId: 5, subjectId: 2, question: 'Optional parameters', answer: 'Optional Parameters - by wrapping them in [ ] \n\nString say(String from, String msg, [String device]) {}'),

            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Constructors', answer: 'Constructors instantiate the object. \n\n- Constructors may be generative or they may be factories. \n\n- A constructor is a special member that is used in instance creation expressions to produce objects. \n\n- A constructor name always begins with the name of its immediately enclosing class or interface. \n\n- A constructor may optionally be followed by a dot and an identifier, called a named constructor. \n\n- If you don’t declare a constructor, a default constructor is provided for you. \n\n- Constant objects are referenced by canonical lookup. \n\n- The new expression invokes a constructor. \n\n- Constructors are not inherited from a superclass. \n\n- Interfaces can have constructor Signatures (but not bodies). \n\n- All uninitialized instance variables have the value null. \n\n- Subclasses don’t inherit constructors from their superclass.'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Constructor parts', answer: 'a. Generative \nb. Named \nc. Factory \nd. Inheritance'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Default constructor', answer: 'No class constructor given causes the use of the default constructor'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Succinct vs Elaborative Constructor', answer: 'Succinct constructor with instance parameters \n\nElaborative constructor with annotated parameter types'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Constructor initializers', answer: 'Initialize final variables in the constructor body after colon[ : ] .  After colon vars have no access to this'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Constant constructors', answer: 'Compile time instances'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Generative', answer: 'Object instantiation starts with the constructor. \n\n- Consists of a constructor name, a constructor parameter list, and either a redirect clause or an initializer list and an optional body. \n\n- Always operates on a fresh instance of its immediately enclosing class excluding constants. \n\n- Can redirect and is called a Named Constructor'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Named', answer: 'Named constructors are generative constructors redirected. \n\n- A named constructor invokes an generative constructor with arguments. \n\n-Named constructor is redirecting to the generative constructor with an initializer list of parameters.'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Factory', answer: 'A factory is a constructor prefaced by the built-in identifier factory. - The interface and its factory class must have the same number of type parameters. \n\n- Can be used to cache object instances in memory. \n\n- Factories mitigate the need for dependency injection. \n\n- Factory constructors have no access to this.'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Singleton Factory', answer: 'This instantiates a Logger singleton and will only instantiate once'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Simple factory', answer: 'Computational instance instantiation.'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Outside factory Instantiation', answer: 'Another example of instantiation possibilities.'),
            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 2, question: 'Multi-Instance factory cache', answer: 'Returning instances from cache'),

            InterviewQuestionResponse(id: 1, topicId: 7, subjectId: 2, question: 'What are the different types of Inheritance in Dart?', answer: '3 types: \n\nSingle - Every class can at the most extend from one parent class. \n\nMultiple - A class can inherit from multiple classes. Dart does not support multiple inheritance. \n\nMulti - level - A class can inherit from another child class.'),
            InterviewQuestionResponse(id: 2, topicId: 7, subjectId: 2, question: 'Multiple Interfaces', answer: 'A class can implement multiple interfaces. The interfaces are separated by a comma.'),
            InterviewQuestionResponse(id: 3, topicId: 7, subjectId: 2, question: 'Subclasses are of single inheritance only', answer: '- A class may override instance members that would otherwise have been inherited from its superclass \n\n- Subclasses don’t inherit constructors from their superclass. More on constructor inheritance here. \n\n- Abstract classes require subclasses.'),
            InterviewQuestionResponse(id: 4, topicId: 7, subjectId: 2, question: 'Constructors are not inherited and have to be called', answer: '- Subclasses don’t inherit constructors from their superclass. \n\n- If you want a subclass to be created with a named constructor defined in the superclass, you must implement that constructor in the subclass.'),
            InterviewQuestionResponse(id: 5, topicId: 7, subjectId: 2, question: 'What is Dart Interface?', answer: 'An interface defines how one may interact with an object. In interface you can declare a abstract method (means you can declare body in its sub class), basically it is used for solving the problem of multiple inheritance.'),
            InterviewQuestionResponse(id: 6, topicId: 7, subjectId: 2, question: 'Does Dart has a syntax for declaring interfaces?', answer: 'No, Dart has not syntax for declaring interface. Just use to implements keyword.'),
            InterviewQuestionResponse(id: 7, topicId: 7, subjectId: 2, question: 'An interface defines how one may interact with an object.', answer: '- Every class could be used as an interface implicitly \n\n- Use the keyword implements to implement a class with abstract methods as an interface \n\n- An interface has methods, getters, setters and constructors, and a set of superinterfaces. \n\n- The core library contains several utility interfaces for sorting, mapping and iterating. \n\n- Hashable use hashset requires both the hashable and equality methods. \n\n- Hashable hashcode computations can weigh down performance'),

            InterviewQuestionResponse(id: 1, topicId: 8, subjectId: 2, question: 'What Is Typedef In Dart?', answer: 'In Dart, A typedef (Or function types alias) helps to define pointer to execute code within memory. \n\nSyntax: typedef function_name(parameters)'),

            InterviewQuestionResponse(id: 1, topicId: 9, subjectId: 2, question: 'What is Libraries in dart? And what are types of Libraries?', answer: 'Libraries: In Dart, libraries is used to support web and web server development. Dart libraries not only provide APIs, but it is a unit of privacy: they can implement details such as private variables. There are some of libraries of Dart: \nI/O Library: Read and write files. \nDart core: data structure and operations. \nDart async: Support for asynchronous programming, with classes such as Future and Stream. \nDart math: Mathematical constants and functions, plus a random number generator. \nHtml Library: HTML5 DOM. \nIsolate Library: spawning and communicating with isolates \nCrypto Library: SHA1, MD5, SHA256 and HMAC support. \nJson Library: parse and produce JSON-encoded text. \nUnit Test Library: function and classes. \nDart convert: Encoders and decoders for converting between different data representations, including JSON and UTF-8.'),
            InterviewQuestionResponse(id: 2, topicId: 9, subjectId: 2, question: 'What are the Snapchots in Dart?', answer: 'Snapshots: Snapshots are a core part of the Dart VM. Snapshots are files which store objects and other runtime data. \n\nThere are three type of snapshots: \nScript snapshots: Dart programs can be compiled into snapshot files. These files contain all of the program code and dependencies preparsed and ready to execute. This allows fast startups. \nFull snapshots: The Dart core libraries can be compiled into a snapshot file which allows fast loading of the libraries. Most standard distributions of the main Dart VM have a prebuilt snapshot for the core libraries which is loaded at runtime. \nObject snapshots: art is a very asynchronous language. With this, it uses isolates for concurrency. Since these are workers which pass messages, it needs a way to serialize a message. This is done using a snapshot, which is generated from a given object, and then this is transferred to another isolate for deserializing.'),
            InterviewQuestionResponse(id: 3, topicId: 9, subjectId: 2, question: 'Dart 2.2', answer: 'const List<String> releases = ["Dart 2.0", "Dart 2.1", "Dart 2.2"]; \n\nSet<String> currencies = Set.of(["EUR", "USD", "JPY"]); \n\nconst Set<String> currencies = {"EUR", "USD", "JPY"}; \n\nSet<String> currencies = Set<String>()..add("EUR")..add("USD")..add("JPY"); \n\nconst Set<String> currencies =_UnmodifiableSet<String>({"EUR": null, "USD": null, "JPY": null});'),
            InterviewQuestionResponse(id: 4, topicId: 9, subjectId: 2, question: 'Dart 2.3', answer: '1) pread operator (…) \n2) Using if in a Collection \n3) Using for in a Collection'),

            //JAVA
            InterviewQuestionResponse(id: 1, topicId: 1, subjectId: 3, question: 'What is java', answer: 'Java is a programming language and a platform. \nJava is a high level, robust, object-oriented and secure programming language. \nPlatform: Any hardware or software environment in which a program runs, is known as a platform. Since Java has a runtime environment (JRE) and API, it is called a platform.'),
            InterviewQuestionResponse(id: 2, topicId: 1, subjectId: 3, question: 'Features of Java', answer: '1) Compiled and Interpreter \n- Generally, in a programming language the source code is first compiled and converted into machine code and then it will be executed. \n- But in Java this thing is different. \n- Java compile first converts the source code into byte code. This byte code is not a machine code. \n- Byte codes are machine instructions for the Java Virtual Machine. \n- This byte code then Interpreted by java runtime system called Java Virtual Machine (JVM). \n\n2) Plate form-Independent and Portable \n- Platform=hardware + Operating System \n- Java is platform independent so java program can run on any operating system and any hardware configuration.\n- It is because of the magic of Byte Code which is platform independent. \n- When java compiler compile any code then it generate the byte code not the machine native code. This byte code need a JRE to execute on a machine. \n- JRE contains JVM and JVM read that byte code and execute it. Different JVM is designed for different OS and byte code is able to run on different OS. \n- The most important feature of Java is a platform independent language. \n- Platform independence means that we can write and compile the java code in one platform (e.g. Windows) and can execute the class in any other supported platform e.g. (Linux, Solaris, etc). \n- Program can be easily run on different computer at anytime and anywhere. \n- A platform is the hardware or software environment in which a program runs.  \n- There are two types of platforms software-based and hardware-based. \n- Java provides software-based platform. \n- The Java platform differs from most other platforms in the sense that it is a software-based platform that runs on top of other hardware-based platforms. \n\n It has two components: \n1) Runtime Environment \n2) API(Application Programming Interface) \n- Java code can be run on multiple platforms e.g. Windows, Linux, Sun Solaris, and Mac/OS etc. Java code is compiled by the compiler and converted into bytecode. \n- This bytecode is a platform independent code because it can be run on multiple platforms i.e. Write Once and Run Anywhere (WORA). \n\n3) Object – oriented \n- In java everything is an Object. Java can be easily extended since it is based on the Object model. \n- Java was not designed to be source-code compatible with any other language. This allowed the Java team the freedom to design with a blank slate. One outcome of this was a clean, usable, pragmatic approach to objects. \n- All program code and data resides within objects and classes. \n- Object-oriented means we organize our software as a combination of different types of objects that incorporates both data and behavior. \n- Object-oriented programming (OOPs) is a methodology that simplify software development and maintenance by providing some rules. \n- All the object-oriented features like Object, Class, Inheritance, Polymorphism, Abstraction, and Encapsulation are provided in Java. \n- One of the central issues in software development is how to reuse code. Object-oriented programming provides great flexibility, modularity, clarity, and reusability through encapsulation, inheritance, and polymorphism. \n\n Note: Java uses primitive data types and hence is not a pure object oriented language. \n\n4) High Performance \n- Java programs are compiled one time and run one or more time. \n- It takes time only at compilation. \n- After compilation the JVM easily execute this byte code and gives the high performance. \n- Furthermore, multithreading also enhances the performance of execution of java program. \n\n5) Dynamic binding and Extensible \n- Java is a dynamic language. \n- Java is capable of dynamically linking in new class libraries, methods and objects. Because of this it reduces the memory consumptions when the programs are executed. \n- Java also supports functions written in other languages such as C and C++. \n- These functions are known as native methods. Native methods are linked dynamically at runtime. \n\n6) Simple \n- Java is partially modeled on C++, but greatly simplified and improved. Some people refer to Java as "C++" because it is like C++ but with more functionality and fewer negative aspects. \n- A simple Language because it contains many features of other Languages like c and C++ and Java Removes Complexity because it doesn’t use pointers, Storage Classes and Go to Statements and java doesn’t support Multiple Inheritance. \n- No need to remove unreferenced objects because there is Automatic Garbage Collection in java \n\n7) Interpreted \n- You need an interpreter to run Java programs. The programs are compiled into the Java Virtual Machine code called byte code. \n- The byte code is machine-independent and can run on any machine that has a Java interpreter, which is part of the Java Virtual Machine (JVM). \n\n8) Simple \n- Java is partially modeled on C++, but greatly simplified and improved. Some people refer to Java as "C++" because it is like C++ but with more functionality and fewer negative aspects. \n- A simple Language because it contains many features of other Languages like c and C++ and Java Removes Complexity because it doesn’t use pointers, Storage Classes and Go to Statements and java doesn’t support Multiple Inheritance. \n- No need to remove unreferenced objects because there is Automatic Garbage Collection in java \n\n9) Interpreted \n- You need an interpreter to run Java programs. The programs are compiled into the Java Virtual Machine code called byte code. \n- The byte code is machine-independent and can run on any machine that has a Java interpreter, which is part of the Java Virtual Machine (JVM). \n\n10) Multithreaded and Interactive \n- Multithreaded means handling multiple tasks simultaneously. For example, while listening song, one can edit document or scroll the document. \n- Java provides multithreading facility. \n- This means that we need not wait for the application to finish one task before beginning another. \n- This feature greatly improves the interactive performance of graphical applications. \n- Multithread programming is smoothly integrated in Java, whereas in other languages you have to call procedures specific to the operating system to enable multithreading. \n- We can write Java programs that deal with many tasks at once by defining multiple threads. \n- The main advantage of multi-threading is that it shares the same memory. Threads are important for multi-media, Web applications etc. \n\n11) Distributed \n- Client / Server are a concept that will distribute the independent processes over clients and servers, depending upon the suitability for the task of those clients and servers. \n- A distributed language for creating applications on networks.\n- It has the ability to share the data and programs. \n- Java applications can open and access remote objects on Internet as easily as they can do in a local system. \n- This enables multiple programmers at multiple remote locations to collaborate and work together on a single project. \n- We can create distributed applications in java. RMI and EJB are used for creating distributed applications. \n- We may access files by calling the methods from any machine on the intern.'),
            InterviewQuestionResponse(id: 3, topicId: 1, subjectId: 3, question: 'Compiler', answer: 'To convert your high language program into native machine code.'),
            InterviewQuestionResponse(id: 4, topicId: 1, subjectId: 3, question: 'Linker', answer: 'To combine different program files reference in your main program together.'),
            InterviewQuestionResponse(id: 5, topicId: 1, subjectId: 3, question: 'Loader', answer: 'To load the files from your secondary storage device like Hard Disk, Flash Drive, CD into RAM for execution. The loading is automatically done when your execute your code.'),
            InterviewQuestionResponse(id: 6, topicId: 1, subjectId: 3, question: 'Execution', answer: 'Actual execution of the code which is handled by your OS & processor. With this background, refer the following video & learn the working and architecture of the Java Virtual Machine.'),
            InterviewQuestionResponse(id: 7, topicId: 1, subjectId: 3, question: 'Virtual machine', answer: 'A virtual machine steps through the computer-friendly instructions.'),
            InterviewQuestionResponse(id: 8, topicId: 1, subjectId: 3, question: 'Application programming interface', answer: 'An application programming inter-face contains useful prewritten code.'),
            InterviewQuestionResponse(id: 9, topicId: 1, subjectId: 3, question: 'The Java Runtime Environment (JRE)', answer: '- This bundle includes a Java virtual machine and the Application Programming Interface. \n\n- With the JRE, you can run existing Java programs. \n\n- That’s all. You can’t create new Java programs, because you don’t have a Java compiler.'),
            InterviewQuestionResponse(id: 10, topicId: 1, subjectId: 3, question: 'The Java Development Kit (JDK)', answer: '- This bundle includes three tools a Java compiler, a Java virtual machine, and the Application Programming Interface. \n\n- With the JDK, you can create and run your own Java programs. \n\n- Another name for the JDK is the Java SDK the Java Software Development Kit. \n\n- Some people still use the SDK acronym, even though the folks at Sun Microsystems don’t use it anymore. (Actually, the original name was the JDK. Later Sun changed it to the SDK. A few years after that, Sun changed back to the name JDK. As an author, this constant naming and renaming drives me crazy.)'),
            InterviewQuestionResponse(id: 11, topicId: 1, subjectId: 3, question: 'Why is Java both interpreted and complied language?', answer: '1) Programming languages are classifies as \n2) Higher Level Language Ex. C++ , Java \n3) Middle Level Languages Ex. C \n4) Low Level Language  Ex Assembly \n5) Finally the lowest level as the Machine Language. \n\n- A compiler is a program which converts a program from one level of language to another. Example conversion of C++ program into machine code. \n\n- The java compiler is a convert’s high level java code into bytecode (which is also a type of machine code). \n\n- An interpreter is a program which converts a program at one level to another programming language at the same level. Example conversion of Java program into C++ \n\n- In Java, the Just in Time Code generator converts the bytecode into the native machine code which are at the same programming levels. \n\n- Hence java is both compiled as well as interpreted language.'),
            InterviewQuestionResponse(id: 12, topicId: 1, subjectId: 3, question: 'Why is Java slow?', answer: '- The two main reasons behind the slowness of Java are \n1) Dynamic Linking  \n- Unlike C, linking is done at run-time, every time the program is run in Java. \n\n2) Run-time Interpreter \n- The conversion of byte code into native machine code is done at run-time in Java which furthers slows down the speed. \n- However, the latest version of Java has addressed the performance bottlenecks to great extent.'),
            InterviewQuestionResponse(id: 13, topicId: 1, subjectId: 3, question: 'Java is programming language in available', answer: '- C/C++, the programmer is not manually allocating and free the dynamic memory. This sometimes leads to problems, because programmer will either forget to free memory that has been previously allocated or, worse try to free some memory that another part of their code is still using. \n\n- That reason available in java programming. \n\n- Java pointer is not support. \n\n- Pointer is a reference handle to a memory location. \n\n- Improper handling of pointers leads to memory leaks and reliability issues hence Java does not support the usage of pointers.'),
            InterviewQuestionResponse(id: 14, topicId: 1, subjectId: 3, question: 'Why Java is not fully object oriented? (Partly object)', answer: '- It does not support multiple inheritance. \n\n- It allows use of primitive data types which are not create an objects. \n\n- It allows static methods to call without creating the instance.'),
            InterviewQuestionResponse(id: 15, topicId: 1, subjectId: 3, question: '3 Ways of writing main() in Java', answer: '\n1) public static void main(String args[]){} //Routine way \n2) public static void main(String[] args){} // Pushing the square before \n3) public static void main(String []args){} \n4) public static void main(String...args){}'),
            InterviewQuestionResponse(id: 16, topicId: 1, subjectId: 3, question: 'Why main method is assigned as static?', answer: '- Why main method is static in Java", there are quite a few reasons around but here are few reasons which make sense to me: \n\n1) Since main method is static Java virtual Machine can call it without creating any instance (object) of class which contains main() method. \n\n2) Since C and C++ also has similar main method which serves as entry point for program execution, following that convention will only help Java. \n\n3) If main method were not declared static than JVM has to create instance of main Class and since constructor can be overloaded and can have arguments there would not be any certain and consistent way for JVM to find main method in Java. \n\n4) Anything which is declared in class in Java comes under reference type and requires object to be created before using them but static method and static data are loaded into separate memory inside JVM called context which is created when a class is loaded. If main method is static than it will be loaded in JVM context and are available to execution.5.List the advantages of an Interface.'),
            InterviewQuestionResponse(id: 17, topicId: 1, subjectId: 3, question: 'Java platform independent', answer: '- A Platform is the hardware or software Environment in which a program runs. We have already mentioned some of the popular platforms like Microsoft Windows, Linux, Solaris OS, and Mac OS. \n- Most platforms can be described as a combination of the operating system and underlying hardware. \n- The java platform differs from most other platform in that it’s a software-only platform that runs on top of other hardware-based platforms. \n\n- The java platform has two components: \n1) The java virtual machine. \n2) The java application programming interface (API). \n\n- As we‘ve already discussed about JVM; it’s the base for java platform and is ported onto various hardware-based platforms. \n- The API is a large collection of ready- made software components that provide many useful capabilities. \n- It is grouped into libraries of related classes and interfaces; these libraries are known as packages. \n\nHow Java Is Platform Independent?\n\n- In the java programming language, all source code files saved ending with the .java extension. \n\n- Those source files are then complied into .class files by the javac complier. \n\n- A ".class files"contains bytecodes (in the form of 0 & 1). \n\n- The java launcher tool then runs your application with an instance of java virtual machine. \n\n- JVM is available on many different operating system, the same ".class files" are capable of running on Microsoft Windows, the Solaris Operating System (Solaris OS), Linux, Mac OS. \n\n- Java programs that have been compiled into byte code still need an interpreter to execute them on any given platform. \n\n- The interpreter reads the byte code and translates it into the native language of the host machine on the fly. \n\n- Since the byte code is completely platform independent, only the interpreter and a few native libraries need to be ported to get Java to run on a new hardware or OS. \n\n- The rest of the runtime environment including the compiler and most of the class libraries are written in Java. \n\n- The concept of Write-once-run-anywhere (known as the Platform independent) is one of the important key feature of java language that makes java as the most powerful language. \n\n- Not even a single language is idle to this feature but java is more closer to this feature. \n\n- The programs written on one platform can run on any platform provided the platform must have the JVM.'),
            InterviewQuestionResponse(id: 18, topicId: 1, subjectId: 3, question: 'What is System.out.println?', answer: 'System.out.println prints the argument passed, into the System.out which is generally stdout. \nSystem \n- Is a final class and cannot be instantiated. \n- Therefore all its memebers (fields and methods) will be static and we understand that it is an utility class. As per javadoc,  \n-	“… Among the facilities provided by the System class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array…” \n\nout \n-	Is a static member field of System class and is of type PrintStream. \n- Its access specifiers are public final. This gets instantiated during startup and gets mapped with standard output console of the host. \n- This stream is open by itself immediately after its instantiation and ready to accept data. When running a program from windows command line, it is the standard console. \n\nprintln \n-	println prints the argument passed to the standard console and a newline. \n- There are multiple println methods with different arguments (overloading). \n- Every println makes a call to print method and adds a newline. print calls write() and the story goes on like that.'),
            InterviewQuestionResponse(id: 19, topicId: 1, subjectId: 3, question: 'System.out.println and Performance', answer: '- There is a general notion that SOPs are bad in performance. \n\n- When we analyze deeply, the sequence of calls are like println -> print -> write() + newLine().  \n\n- This sequence flow is an implementation of Sun/Oracle JDK. Both write() and newLine() contains a synchronized block. Synchronization has a little overhead, but more than that the cost of adding characters to the buffer and printing is high. \n\n- When we run a performance analysis, run multiple number of SOP and record the time, the execution duration increases proportionally. Performance degrades when we print more that 50 characters and print more than 50,000 lines. \n\n- It all depends on the scenario we use it. Whatever may be the case, do not use System.out.println for logging to stdout.'),
            InterviewQuestionResponse(id: 20, topicId: 1, subjectId: 3, question: 'System.err and System.in', answer: '- As a related section, I wish to discuss about ‘err’ and ‘in’. ‘in’ is associated with InputStream. Opposite to ‘out’, ‘in’ is used to get input from standard console generally keyboard. \n\n -‘err’ is associated with PrintStream and prints the argument to the standard error output stream. When you use eclipse kind of IDE you can see the difference in output between ‘out’ and ‘err’. \n\nSystem.err.println("Where is that file?");'),

            InterviewQuestionResponse(id: 18, topicId: 1, subjectId: 3, question: 'MCQ', answer: '- J2ME, J2SE, and J2EE editions of the Java 2 platform. \n\n- Compiled Java code is referred to as  bytecode. \n\n- A class is a description of an object. \n\n- An object is an instance of a class. \n\n- object is a Super class for all the classes \n\n- The main() method has to be declared as public static void main(String [] args). \n\n- A Java program written for Windows needs to be recompiled to run it on Linux or UNIX.  False \n\n- What are the two major components of an object?  Attributes and behaviors also referred to as fields and methods. \n\n- What does the JIT acronym stand for? What does it mean? JIT stands for Just-In-Time and refers to a JVM that compiles portions of the bytecode of a Java program into native code when the program is executed. \n\n- Any method that does not have the keyword static is an object method. \n\n- Java was first developed in 1991. \n\n- The old name of Java was Oak.\n\n- ADT: Abstaract Data Type \n\n- JVM: Java Virtual Machine \n\n- JDK: Java Development Kit \n\n- To compile a java program javac command is used. \n\n- To run a java program, java command is used. \n\n- The extension of a java source file is a .java \n\n- When the source file is successfully compiled, Bytecode is generated. \n\n- Java is a platform Independent language. \n\n- From these is the compulsory section class definition, main method and these is section not compouslary document section, package statement and import statement in a java. \n\n- Java support two types of methods in Java, called class methods and object methods. \n\n- Java also provides capabilities to read and write class objects directly. The process of reading and writing objects is called object serialisation. \n\n- String literals are treated as java.lang.String objects. A String object is immutable, meaning that once it is instantiated, its contents cannot be changed. \n\n- The String, StringBuffer, and StringBuilder classes are defined in java.lang. \n\n- Object-oriented programming allows classes to inherit commonly used state and behavior from other classes. \n\n- When a member is declared final, it is a constant which will not and cannot change. \n\n- The modifiers that are used into protection of the data members of the class is called access modifiers. \n\n- The abstract keyword can be used on classes and methods. \n\n- Classes declared with the abstract keyword are solely for the purpose of extension (inheritance) by other classes. \n\n- A string literal in Java is automatically instantiated into what data type? A String object. \n\n- Which two Java keywords have no implementation and cannot be used in Java? goto and const. \n\n- You can use the unsigned keyword to make an into store all positive values. False. Unsigned is not a Java keyword. \n\n- A reference in Java contains the memory address of an object, but there is no way for you to view or access that memory address. True. A reference holds a memory address, but you cannot use this fact in your Java programs. \n\n- Implicitly conversion is done automatically by Java. \n\n- Java Provide both types of Environments like CUI and Also GUI. \n\n- Java is both Compiled and Interpreter Language. \n\n- In Java All the Code in the java is written into the Classes So that it is called as Purely Languages. \n\n- Enumerations are also used to specify the input streams to a SequenceInputStream. \n\n- CLASSPATH and PATH both are environment variables. \n\n- import java.lang package it is by default loaded internally by the JVM. \n\n- In Java the arguments are always passed by value. \n\n- Primitive data types are passed by value. \n\n- Serialization is a mechanism by which you can save the state of an object by converting it to a byte stream. \n\n- The serializable interface is an empty interface; it does not contain any methods. So we do not implement any methods. \n\n- Checked exception are those which the Java compiler forces you to catch. \n\n- The purpose of finalization is to give an unreachable object the opportunity to perform any cleanup processing before the object is garbage collected. \n\n- A static variable is associated with the class as a whole rather than with specific instances of a class. \n\n- Non-static variables take on unique values with each object instance. \n\n- This() is used to invoke a constructor of the same class. \n\n- super() is used to invoke a superclass constructor. \n\n- Externalizable is an Interface that extends Serializable Interface. And sends data into Streams in Compressed Format. It has two methods, writeExternal(ObjectOuput out) and readExternal(ObjectInput in) \n\n- Only public and abstract modifiers are allowed for methods in interfaces. \n\n- Static variables and methods are instantiated only once per class. In other words they are class variables, not instance variables. If you change the value of a static variable in a particular object, the value of that variable changes for all instances of that class. Static methods can be referenced with the name of the class rather than the name of a particular object of the class (though that works too). Thats how library methods like System.out.println() work out is a static field in the java.lang.System class. \n\n- The main method can be declared final, in addition to being public static. \n\n- Interface cannot declared final. \n\n- BufferedInputStream program necessary class FileInputStrea \n\n- BuffereredReader program necessary class InputStreamReader \n\n- BufferedOutputStream program necessary class FileOutputStream \n\n- DataInputStream Program necessary class FileInputStream \n\n- StreamTockenizer  program necessary stream classes FileReaderBufferedReader \n\n- If you want to program number (int), long character and String is different output particular file to generate output then used to RandomAccessFile.  Then some function must be used number (int), long number (WriteLong) and String (WriteUTF). \n\n- All the action in Java programs takes place inside class blocks. \n\n- Java supports a set of character literals known as escape sequence which can not be printed. \n\n- It is possible that a variable of a parameterized type refers to an object that is not of that parameterized type. This situation is known as heap pollution. \n\n- In Java every statement ends with semicolon(;). \n\n- A class that cannot be subclassed is called a final class. \n\n- The implicit type conversion of int data type can be done to Long data type. \n\n- In java, if you do not give a value to variable before using it, Compiler will give an error. \n\n- The instance of operator return a Boolean value. \n\n- The new keyword is used to allocate memory to an object. \n\n- A constructor is a special type of method. \n\n- The keyword is used to refer to object of current class. \n\n- Method overloading is a way by which java achieves polymorphism. \n\n- When in a method normal variable is passed as parameter, it is call by value. \n\n- A recursion occurs when a method call itself. \n\n- When a variable is declared as private, it can be used in only within in class. \n\n- When a variable is declared as static, it is automatically initialized before an object of its class is created. \n\n- When final keyword is applied to a variable its value cannot be changed. \n\n- In case of inner and outer classes, the member of inner class cannot be accessed by outer class. \n\n- Before doing garbage collection, finalize() method is called. \n\n- The command line arguments are passed as array of strings. \n\n- In java, the method written in other language can be called by native keyword. \n\n- super keyword can be used to call super class’ constructor and access super class’ members. \n\n- When a method has same name and same type signature as a method in super class, then this method is said to be overridden. \n\n- Inheritance means ability to use properties of another class. \n\n- To inherit from a class extends keyword is used. \n\n- Java does not support multiple inheritance.'),

            InterviewQuestionResponse(id: 1, topicId: 3, subjectId: 3, question: 'What is the Java Virtual Machine? What is its role?', answer: '- Java was designed with a concept of ‘write once and run everywhere’. Java Virtual Machine plays the central role in this concept. \n\n- The Java Virtual Machine is a software that can be ported onto various hardware-based platforms. \n\n- The JVM is the environment in which Java programs execute. It is a software that is implemented on top of real hardware and operating system. \n\n- When the source code (.java files) is compiled, it is translated into byte codes and then placed into (.class) files. The JVM executes these bytecodes. \n\n- So Java byte codes can be thought of as the machine language of the JVM. \n\n- A JVM can either interpret the bytecode one instruction at a time or the bytecode can be compiled further for the real microprocessor using what is called a just-in-time compiler. \n\n- The JVM must be implemented on a particular platform before compiled programs can run on that platform. \n\n- When a Java program is compiled it is converted to byte code which is then executed bythe Java interpreter by translating the byte code into machine instructions. \n\n- Java interpreter is part of Java runtime environment. Byte code is an intermediate code independent of any machine and any operating system. \n\n- Program in Java run time environment, which is used to interpret byte code, is called Java Virtual Machine (JVM). \n\n- The Java compiler reads Java language source files, translates the source into Java byte codes, and places the byte codes into class files. \n\n- Any machine for which Java interpreter is available can execute this byte code. That’s why Java is called Machine independent and Architecture neutral. \n\n- The JVM plays the main role to making Java portable. It provides a layer of abstraction between the compiled Java program and the hardware platform and operating system. The JVM is central to Java’s portability because compiled Java programs run on the JVM, independent of whatever hardware is used.'),
            InterviewQuestionResponse(id: 2, topicId: 3, subjectId: 3, question: 'How garbage collector knows that the object is not in use and needs to be removed?', answer: 'Garbage collector reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations. This is done via bookkeeping the references to the objects. Any unreferenced object is a garbage and will be collected.'),

            InterviewQuestionResponse(id: 1, topicId: 4, subjectId: 3, question: 'Java OOP (Object Oriented Programming)', answer: 'Object-Oriented Programming is a paradigm that provides many concepts such as inheritance, data binding, polymorphism, etc. \nThe main aim of object-oriented programming is to implement real-world entities for example object, classes, abstraction, inheritance, polymorphism, etc. \n\n1) Object \n- Any entity that has state and behavior is known as an object. For example a chair, pen, table, keyboard, bike, etc. It can be physical or logical. \n- An Object can be defined as an instance of a class. An object contains an address and takes up some space in memory. Objects can communicate without knowing the details of each other of data or code. The only necessary thing is the type of message accepted and the type of response returned by the objects. \n\n2) class \n- Collection of objects is called class. It is a logical entity. \n- A class can also be defined as a blueprint from which you can create an individual object. Class does not consume any space. \n\n3) Inheritance \n- When one object acquires all the properties and behaviors of a parent object, it is known as inheritance. It provides code reusability. It is used to achieve runtime polymorphism. \n\n4) Polymorphism \n- If one task is performed by different ways, it is known as polymorphism. For example: to convince the customer differently, to draw something, for example, shape, triangle, rectangle, etc. \n- In Java, we use method overloading and method overriding to achieve polymorphism. \n- Another example can be to speak something; for example, a cat speaks meow, dog barks woof, etc. \n\n5) Abstraction \n- Hiding internal details and showing functionality is known as abstraction. For example phone call, we does not know the internal processing. In Java, we use abstract class and interface to achieve abstraction. \n\n6) Encapsulation \n- Binding (or wrapping) code and data together into a single unit are known as encapsulation. For example capsule, it is wrapped with different medicines. \n- A java class is the example of encapsulation. Java bean is the fully encapsulated class because all the data members are private here.'),
            InterviewQuestionResponse(id: 2, topicId: 4, subjectId: 3, question: 'What is the difference between an object-oriented programming language and object-based programming language?', answer: 'Object-based programming language follows all the features of OOPs except Inheritance. JavaScript and VBScript are examples of object-based programming languages.'),
            InterviewQuestionResponse(id: 3, topicId: 4, subjectId: 3, question: 'Data Abstraction', answer: '\n- Abstraction refers to the act of representing essential features without including the background details (inner details) or explanations. \n\nOR\n \n- The purpose of abstraction is to hide information that is not relevant or rather show only relevant information and to simplify it by comparing it to something similar in the real world. \n\nOR\n\n- Abstraction is converting real world objects into a class in Java. \n\nAbstraction means “The process of forming of general and relevant concept from more complex scenarios”. \n\nNote 1: \n\n– Abstraction is used to build complex systems. \n\n– Key to simplify a complex design into smaller, manageable parts which then become the components of a bigger and complex system. \n\n– The idea of hiding the complexity within a smaller/simple component of a system. \n\nNote 2: \n\n– Abstraction is not a feature of Object oriented concepts alone. Even in procedural language programming, abstraction can be achieved to a limited extent by hiding complex internals through well formed business logic and functions. \n\n- Classes use the concept of abstraction and are defined as a list of abstract attributes such as size, weight and methods that operate on those attribute. They encapsulate all the essential properties of the objects that are to be created. \n\n- Abstraction refers to the act of representing essential features without including the background details to distinguish objects / functions from other objects / functions.  \n\n- In case of structured programming, functional abstraction was provided by telling, which task is performed by function and hiding how that task is performed. \n\n- There are also strong benefits to abstraction: \n\n- When you change your code that implements an abstraction, the user of the abstraction does not have to change their code. As long as the abstraction does not change, the users will not have to change their code. \n\n- When you write code that uses an abstraction, you can write code once that will be reusable against any new code that implements that abstraction. You can write less code to do more. \n\nAbstraction has advantages \n\n- By using abstraction, we can separate the things that can be grouped to another type. \n\n- Frequently changing properties and methods can be grouped to a separate type so that the main type need not undergo changes. This adds strength to the OOAD (Object oriented analysis and Design) principle -"Code should be open for Extension but closed for Modification".\n\n- Simplifies the representation of the domain models. \n\n- Abstraction can be implemented by using abstract classes & interfaces.'),
            InterviewQuestionResponse(id: 4, topicId: 4, subjectId: 3, question: 'Polymorphism', answer: 'Poly = many     morphisam = shape \nPolymorphism means the ability to take more than one forms by a single entity. \n\nOR\n\n The ability to define more than one function with the same name is called Polymorphism. \nWhen one task is performed by different ways i.e. known as polymorphism. \nA single function name can be used to handle different no and different type of argument. \nPolymorphism is the existence of the classes or methods in different forms or single name denoting different implementations. \nInheritance, Overloading and Overriding are used to achieve polymorphism. \nIt plays an important role in allowing objects having different internal structures to share the same external interface. \nPolymorphism manifests itself in Java in the form of multiple methods having the same name. \n“One interface and multiple implementation” means one function is used in different shape. For example class Shape is used in different form. Such as rectangle, circle, oval, square etc. \nExample class Father{void van(int ,int){} } class Son extends Father{void van(int, int, int, int){} }\nYou have already used two types of polymorphism (overloading and overriding) \n\nThere are two types of polymorphism \n1) Compile time polymorphism or static binding or early binding \n2) Run time polymorphism or dynamic binding or late binding. \n\nCompile time polymorphism \n\n- Function Overloading – within same class more than one method having same name but differing in signature. \n\n- Resolved during compilation time. \n\n- Return type is not part of method signature. \n\n- Method overloading. \n\n- Compile time polymorphism or static method dispatch is a process in which a call to an overloading method is resolved at compile time rather than at run time. In this process, we done overloading of methods is called through the reference variable of a class here no need to super class. \n\nRuntime time polymorphism \n\n- Runtime polymorphism is done using inheritance and interface. That is achieved through Overriding. \n\n- Runtime polymorphism or dynamic method dispatch is a process in which a call to an overridden method is resolved at runtime rather than at compile-time. \n\n- In this process, an overridden method is called through the reference variable of a superclass. The determination of the method to be called is based on the object being referred to by the reference variable. \n\nNote: From a practical programming viewpoint, polymorphism manifests itself in three distinct forms in Java: \n\n- Method overloading \n\n- Method overriding through inheritance \n\n- Method overriding through the Java interface \n\n- Runtime Polymorphism cannot be achieved by data members. \n\n- Polymorphism can be implemented using the abstract and interface keywords, which enforce to implement the methods in the sub types. More on this on Method overriding and overloading. \n\nFunction Overriding \n\n- Keeping the signature and return type same, method in the base class is redefined in the derived class. \n\n- Resolved during run time. \n\n- Which method to be invoked is decided by the object that the reference points to and not by the type of the reference. \n\n- In Overloading we can reuse the same method name by changing the arguments. \n\nOverloaded methods- Must and Must Not Facts: \n\n- The Overloaded method must have different argument lists, \n\n- Can have different return types but in that case it is mandatory to have different argument list. \n\n- Can have different access modifiers and \n\n- Can throw different exceptions \n\n- Methods can be overloaded in the same as well as the sub classes. \n\nOverriding \n\n- Redefining a super class method in a sub class is called method overriding. \n\n- The method signature i.e. method name, parameter list and return type have to match exactly. \n\n- The overridden method can widen the accessibility but not narrow it, i.e. if it is private in the base class, the child class can make it public but not vice versa. \n\n- When you override methods, JVM determines the proper methods to call at the program’s run time, not at the compile time. Overriding occurs when a class method has the same name and signature as a method in parent class.'),
            InterviewQuestionResponse(id: 5, topicId: 4, subjectId: 3, question: 'Encapsulation', answer:'- Encapsulation is a technique used for hiding the properties and behaviors of an object and allowing outside access only as appropriate. It prevents other objects from directly altering or accessing the properties or methods of the encapsulated object. \n\n- Encapsulation refers to the hiding of items of data and methods within an object. \n\nOR\n\nEncapsulation means the localization of the information or knowledge within an object. \n\nOR\n\n- Grouping methods & corresponding data into a single capsule is called encapsulation. \n\n- Encapsulation is also called as “Information Hiding”. \n\n- Encapsulation is binding methods and variable together in a class. \n\n OR \n\nBinding (or wrapping) code and data together into a single unit is known as encapsulation. \n\n- The wrapping up of data and methods into a single unit (called class) is known as encapsulation. Encapsulation binds the data to the methods which operate on them. \n\n- Encapsulation is a very important OOP concept. \n\n- Encapsulation is one of the fundamental principal in object oriented programming. \n\n- Encapsulation is the process of combining instance variables and methods into a type of structure usually called as "Class". In java language we ca not write a single tiny program without using class. \n\n- In Java, the basis of encapsulation is the class. \n\n- A class defines the structure and behavior (data and code) that will be shared by a set of objects. Each object of a given class contains the structure and behavior defined by the class, as if it were stamped out by a mold in the shape of the class. \n\n- You can completely encapsulate a member be it a variable or method in Java by using the private keyword and you can even achieve a lesser degree of encapsulation in Java by using other access modifiers like protected or public. \n\n- The public interface of a class represents everything that external users of the class need to know, or may know. The private methods and data can only be accessed by code that is a member of the class. \n\n- Encapsulation in java can be implemented by allowing all the data members of a class to be declared as public, private or protected. A public data member of a class is accessible by any function. \n\nEach object has 2 views. \n\nAn internal view and an external view \n\nEncapsulation is a form of protection \n- Also called Information Hiding. \n- The outside world does not have direct access to the internal implementation or representation of an object. \n- As long as the external view does not change, the internal view can take on any form without affecting the outside world. \n- By hiding data and providing methods to gain access to it, an object can maintain high data integrity. \n- Methods have the responsibility of maintaining data integrity. \n\nprivate visibility offers full encapsulation \n- protected and default offer limited encapsulation. \n- public offers no encapsulation. \n\nThere some definite benefits to encapsulation: \n- The user of your code does not depend on parts of your program that are likely to change. When you change your program, they do not have to change their code. \n- You are more in control of exactly how your code and state changes over the lifetime of your program. You must handle fewer scenarios, and will have fewer unexpected problems to fix. \n- Abstraction is using extension points to let the choice be deferred to a different part of which exact code is run. That choice could be made elsewhere in your program, in another program, or dynamically at runtime. \n- The functionality where in we can change the implementation code without breaking the code of others who use our code is the biggest benefit of Encapsulation. \n- Here in encapsulation we hide the implementation details behind a public programming interface. By interface, we mean the set of accessible methods our code makes available for other code to call in other words, our code of API. \n- By hiding implementation details, We can rework on our method code at a later point of time, each time we change out implementation this should not affect the code which has a reference to our code, as our API still remains the same.'),
            InterviewQuestionResponse(id: 6, topicId: 4, subjectId: 3, question: 'Object', answer: '- Object is a bundle of related variables and functions (also known methods). \n\n- Object Oriented Programming is a paradigm that provides many concepts such as inheritance, data binding, polymorphism etc. \n\n- In OOP your complex program is divided in modules like data (member variables) and methods (functions). \n\n- These data and methods are wrapped into a single unit which is known as class. Now as needed you can make objects of this class i.e. variable of your data type. \n\n- Now through this object you can use methods of this class. \n\n- Thus, a class is a template or an Abstract Data Type (ADT) and object is instance or variable of this data type. \n\n- Similar is considered as the first object-oriented programming language. The programming paradigm where everything is represented as an object is known as truly object-oriented programming language. \n\n- Smalltalk is considered as the first truly object-oriented programming language. \n\n- An object is a region of storage that defines state & behavior. \n1) State is represented by a set of variables & the values they contain. \n2)  Behavior is represented by a set of variables & the logic they implement. \n\n- Thus, an object is a combination of a data & the code that acts upon it. \n\n- Objects are instance of a class. \n\n- Objects are the basic runtime entities is an object – oriented system. \n\n- Object take up space in memory and have an associated address like a record in Pascal or structure in C. \n\n- The arrangement of bits or the data in an object’s memory space determines that object’s state at given moment. \n\n- Objects are runtime instance of some class. \n\n- Object is created in the new keyword. \nFor Example: Person p1, p2; p1 = new person (); p2 = new person (); \n\n- Everything a software object knows (State) and can do (Behavior) is represented by variables and methods (functions) in the object respectively.'),

            InterviewQuestionResponse(id: 1, topicId: 5, subjectId: 3, question: 'Variable', answer: '-A variable is a named piece of memory that you use to store information in your Java program a piece of data of some description. \n\n- Each named piece of memory that you define in your program is able to store data only of one particular type. \n\n- The variable is the basic unit of storage in a java program. \n\n- Each variable that you declare can store values only of a type consistent with the data type of that variable. \n\n- A variable is a named location that stores a value. \n\n- There are three types of variables: local, instance and static. \n\n- A variable is defined by the combination of identifiers, a type and an optional initialize. \n\n- All variables have a scope, which defines their visibility and a life time.'),
            InterviewQuestionResponse(id: 2, topicId: 5, subjectId: 3, question: 'Variable type', answer: '1) Primitive variables \n2) Reference variables \n\nPrimitive variables: Primitive variables can be used to represent primitive values. Example: int x=10; \n\nReference variables: Reference variables can be used to refer objects. \n\nVariables \n1) Global Variables \n2) Local Variables \n\n Global Variables \n\n- The variables that are declared outside any function body. \n\n- These variables exist for the entire life-cycle of the program. \n\n- Global variables can be accessed from anywhere within the program. \n\n Local Variables \n\n- The variables that are declared within a function body. \n\n- Their scope is limited to within the function body. \n\n- Local variables cannot be accessed outside the function body.'),
            InterviewQuestionResponse(id: 3, topicId: 5, subjectId: 3, question: 'The scope & Lifetime of Variables', answer: '- All the variables used have been declared at the start of the main ( ) method. Java allows variables to be declared within any block. \n\n- A block defines a scope. Thus, each time you start a new block, you are creating a new scope. \n\n- A scope determines what objects are visible to other parts of your program. It also determines the lifetime of those objects. \n\n- Many other computer languages define two general categories of scope: \n1) Global \n2) Local \n\n- In java, the two major scopes are those defined by a class and those defined by method. \n\n- As a general rule, variable declared inside a scope are not visible (accessible) to code that is defined outside that scope. \n\n- Thus, when you declare a variable within a scope you are localizing that variables and the scope rules provide the foundation for encapsulation. \n\n- Scopes can be nested. \n\n- For example, each time you create a block of code, you are creating a new rested scope. When this occurs, the outer scope encloses the inner scope. This means that objects declared in the outer scope will be visible to code within the inner scope. However, the reverse is not true. Objects declared within the inner scope will not be visible outside it. \n\n- Variables are created when their scope is entered and destroyed when their scope is left. \n\n- This means that a variable will not hold its value it has gone out of scope. \n\n- Therefore, variables declared within a method will not hold their values between calls to that method. \n\n- If a variable declaration includes an initialize then that variable will be reinitialized each time the block in which it is declared is entered.'),
            InterviewQuestionResponse(id: 4, topicId: 5, subjectId: 3, question: 'Variable Type', answer: '1) Local variable \nA variable that is declared inside the method is called local variable.\n\nOR \n\nLocal variables are declared and used inside methods, for example, for index counters in loops, temporary variables or to hold values that you need only inside the method definition itself. \n\nOR \n\nAutomatic or local variable is created on entry to a method and has only method scope. \n\n2) Instance variable \nA variable that is declared inside the class but outside the method is called instance variable. It is not declared as static. \n\nOR \n\nInstance variables are used to define the attributes of a particular object. \n\n3) static variable \n\nA variable that is declared as static is called static variable. It cannot be local. \n\n4) class variable \nClass variables are similar to instance variables, except their values apply to all the instances of a class (and to the class itself) rather than having different values for each object. \n\nOR \n\nclass variable is a static variable and does not belong to instance of class but rather shared across all the instances. \n\n5) Member variable \nMember variable belongs to a particular instance of class and can be called from any method of the class.'),
            InterviewQuestionResponse(id: 5, topicId: 5, subjectId: 3, question: 'Call by Value (Pass by Value)', answer: 'When values of built in types are passed as arguments to a function. It is known as Call by value. \n\nOr \n\nWhen we pass normal variable in method, it is passed by value. But when we pass object as parameter, it is passes by reference. \n1) When passing primitives, it passes a copy of the variable to the method. Any change made in the method does not reflect in the calling method. \n2) When dealing with objects, a copy of their reference/address is passed. Thus the change made to the object is reflected in the calling method. \n\n- There is only call by value in java, not call by reference. If we call a method passing a value, it is known as call by value. The changes being done in the called method, is not affected in the calling method. \n\n- Pass by Value is when we pass primitives (int, short, long, double, boolean, float etc) to the method or constructor arguments. \n\n- Call by value method passes the copy of variable into formal parameter. So any changes made on that variable will not affect to the actual variables. \n\n- But when we pass object as parameter to a method, a reference to a method, a reference to that object is passed, so any changes made to that object will effect on actual variable.'),
            InterviewQuestionResponse(id: 6, topicId: 5, subjectId: 3, question: 'Call by Reference (Pass by Reference)', answer: '- Pass by reference means, passing the address itself rather than passing the value. \n\n- The changes made to formal parameters in the called function are not reflected in the actual arguments class. \n\n- In this approach, an object is passed as an argument, which is assigned to an object reference are directly reflected to actual argument. \n\n- Pass by reference is when we pass the reference of the object to the method as a parameter. \n\n- When we pass by value, another variable (memory location) is created where the value from the original variable is copied into the new variable. \n\n- Change of value in the method does not affect the original copy of the variable. \n\n- When we pass by value, another reference is created. Both references points to the same object. Any reference changing the value will have effect on second reference also as both refers to the same object. \n\n- Primitive data type operations deal only with value.  \n\n- For Example, the following code shows that assigning primitive data variable i to another named j simple passes a copy of the value in i into j. \n\n- That is, a data value passes and not a reference or pointer to a data location.'),

            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 3, question: 'Data Types', answer: '- Java specifies eight simple types of data: byte, short, int, long, char, float, double, and boolean. \n- These data types are classified into four groups: \nWhole numbers – byte, short, int, long \nFloating-point numbers – float, double \nCharacter values – char \nBoolean values – boolean \n\n- Every variable has a data type, every expression has a type, and every type is strictly defined. \n\n- All assignments, whether explicit or via parameter passing in method calls, are checked for type compatibility. \n\n- There is no automatic coercion or conversion of conflicting types as in some language. \n\n- There java compiler check all expressions and parameters to ensure that the types are compatible.'),
            InterviewQuestionResponse(id: 2, topicId: 6, subjectId: 3, question: 'Derived Data Type (String, Array, etc.)', answer: '- Derived data types are those whose variables allow us to store multiple values of same type. But they never allows to store multiple values of different types. \n\n- These are the data type whose variable can hold more than one value of similar type. \n\n- In general derived data type can be achieve using array. \nint a; //valid \na = 10, 20, 30; //invalid'),
            InterviewQuestionResponse(id: 3, topicId: 6, subjectId: 3, question: 'Types of data type', answer: '- There are two types of data types \n1) Primitive types \n2) Non primitive types \n\n1) Primitive types \n\n- Java provides eight primitive types of data: byte, short, int, long, char, float, double, Boolean \n\n- The primitive types are commonly referenced to as simple types. \n\n- They allow you to define variables for storing data that fall into one of three categories: \n1) Numeric values, which can be either integer or floating point. \n2) Variables that store the code for a single Unicode character. \n3) Logical variables that can assume the values true or false. \n\n2) Non-Primitive Data Types \nDerived Data Type (String, Array, etc.) \nUser - Defined Data Type (class, interface, enum, etc.)'),
            InterviewQuestionResponse(id: 4, topicId: 6, subjectId: 3, question: 'Reference Data type', answer: '- In addition to its eight primitive types, java defines two additional categories of data types: classes and arrays. \n\n- Java programs consist of class definitions; each class defines a new data type that can be manipulated by java programs. \n\n- For example, a program might define a class named point and use it to store and manipulated x, y points in a Cartesian coordinate system. This makes point a new type in that program. \n\n- An array type represents a list of values of some other type. char is a data type, and an array of char value is another data type, written char[]. An array of point objects is a data type, written point[]. An array of pointer arrays is yet another type, written point[][]. \n\n- As you can see, there are an infinite number of possible class and array data types. Collectively, these data types are also known as reference types. \n\n- However, what is important to understand is that class and array types differ significantly from primitive types, in that they are compound, or composite types. A primitive data type holds exactly one value. Classes and arrays are aggregate types that contain multiple values. \n\n- The point type, for example, holds two double values representing the x and y coordinates of the point. And char[] is obviously a compound type because it represents a list of characters. By their very nature, class and array types are more complicated than the primitive data types.'),

            InterviewQuestionResponse(id: 1, topicId: 7, subjectId: 3, question: 'Flow Controls', answer: '- A programming language has control statements which control the flow of execution of the program. \n- There are there are three types of control statements \n1) condition statements \n2) Looping statements \n- Loop is very common control flow statement in programming languages such as java. We are going to describe the basics of “java loop”. In this post, we will learn various ways to use loop in day-to-day programming habits. \n3) Jump statements'),
            InterviewQuestionResponse(id: 2, topicId: 7, subjectId: 3, question: 'condition statements', answer: '- Condition statements are those statements which executes one of the blocks of statement. \n- There are two types of condition statements \n1) if - else statement \n2) switch statement'),
            InterviewQuestionResponse(id: 3, topicId: 7, subjectId: 3, question: 'Switch', answer: '- The expression type must be the byte, short, int and char. \n\n- Each case value must be a unique literal (constant not a variable). Duplicate case value not allowed. \n\n- The each case value compare with expression if match found than corresponding statement will be executed. If no match is found than default statement will be executed. Default case if optional. \n\n- The break statement use to terminate statement sequence, if break statement is not written than all statement execute after match statement. \n\n- The switch statements java multi way branch statement. This is an easier implementation to the if-else statements. \n\n- The keyword "switch" is followed by an expression that should evaluates to byte, short, char or int primitive data types, only. In a switch block there can be one or more labeled cases. \n\n- The expression that creates labels for the case must be unique. The switch expression is matched with each case label. Only the matched case is executed, if no case matches then the default statement (if present) is executed. \n\n- It provides an easy way to dispatch execution to different parts of your code based on the value of an expression. \n\n- As such, it often provides a better alternative than a large series of if-else-if statement. '),
            InterviewQuestionResponse(id: 4, topicId: 7, subjectId: 3, question: 'Loop Statements (Repeatation Statement)', answer: '- A statement that executes repeatedly while some condition is satisfied is called loop. \n\n- Loop statements are those statements which executes a block of statements for a specific number of times. \n\n- There is a condition which controls the execution of loop. \n\n- There are three types of Loop statements \n1) while \n2) do \n3) for : - Simple for loop, - Enhance for loop,- Functional operation for loop'),
            InterviewQuestionResponse(id: 5, topicId: 7, subjectId: 3, question: 'while (Entry Control) ', answer: '- While loop is Java fundamental looping statement. \n\n- It repeats a statement or block while its controlling expression is true. \n\nSyntax while(condition) { body of loop } \n\n- The condition can be any boolean expression. \n\n- The body of the loop will be executed as long as the conditional expression is true. \n\n- When condition becomes false, control passes to the next line of code immediately following the loop. \n\n- A while statement (pre test) checks at the beginning of a loop to see whether the next loop iteration should occur. \n\n- The curly braces are unnecessary if only a single statement is being repeated.'),
            InterviewQuestionResponse(id: 6, topicId: 7, subjectId: 3, question: 'do (Exit – controlled loop)', answer: '- In while loop the conditional expression is evaluated first. If it is true than the block of statements will be executed otherwise the block will be skipped. \n\n- In do loop the placement of conditional expression is evaluated at the end of the block. \n\nSyntax : do { block of statements } while(condition); \n\n- The block of statements is executed first. After this execution the condition will be checked. \n\n- If this condition is true then and then only the block of statement inside the curly brace will be executed. Otherwise the next statement after the while statement will be executed. \n\n- A do while statement (post test) checks at the end of a loop to see whether the next iteration of a loop should occur. The do statement will always execute the loop body at least once.'),
            InterviewQuestionResponse(id: 7, topicId: 7, subjectId: 3, question: 'for', answer: '- The for loop is very powerful and versatile construct. Here is the general form of for statement: \n\nfor(initialization; condition; iteration) { block of statements; } \n\n- The initialization part of this construct will initialize the variable. The condition statement can be any expression which produces boolean value. \n\n- The iteration part may contain increment statement or decrement statement. \n\n- When the control enters into the loop the initialization part evaluated first. Then the condition will be checked. \n\n- If it is true then the block of statements inside the curly braces will be executed. \n\n- In the next iteration of the loop the iteration part will be executed first. After that the condition will be checked. \n\n- This procedure continues until the condition is false.'),
            InterviewQuestionResponse(id: 8, topicId: 7, subjectId: 3, question: 'break', answer: '- By using break, you can force immediate termination of a loop, by passing the conditional expression and any remaining code in the body of the loop. \n\n- When break statement encountered inside a loop, the loop is terminated and program control resumes at the next statement following the loop.'),
            InterviewQuestionResponse(id: 9, topicId: 7, subjectId: 3, question: 'Continue', answer: '- Sometimes you want to skip some part of the loop on some condition for a particular iteration of the loop. \n\n- The continue statement performs such an action. In while and do- while loops, a continue statement causes control to be transferred directly to the conditional expression that controls the loop. \n\n- In a for loop, control first goes to the iteration portion of the for statement and then to the conditional expression. \n\n- For all three loops, any intermediate code is bypassed.'),
            InterviewQuestionResponse(id: 10, topicId: 7, subjectId: 3, question: 'Jump Statements', answer: '- Jump statements change the flow of control in a program to a labeled statement. You label a statement byplacing a legal identifier (the label) followed by a colon (:) before the statement. \n\n- Use the unlabeled form of the break statement to terminate the innermost switch, for, while, or do-while statement. \n\n- Use the labeled form of the break statement to terminate an outer switch, for, while, or do-while statement with the given label. \n\n- A continue statement terminates the current iteration of the innermost loop and evaluates the boolean expression that controls the loop. \n\n- The labeled form of the continue statement terminates the current iteration of the loop with the given label. \n\n- Use return to terminate the current method.'),
            InterviewQuestionResponse(id: 11, topicId: 7, subjectId: 3, question: 'Decision - Making Statements ', answer: '- In the case of the basic if statement, a single statement block is executed if the boolean expression is true. \n\n- In case of an if statement with a companion else statement, the if statement executes the first block if the boolean expression is true; otherwise, it executes the second block of code. \n\n- Use else if to construct compound if statements. \n\n- Use switch to make multiple-choice decisions based on a single integer value. \n\n- It evaluates an integer expression and executes the appropriate case statement. '),
            InterviewQuestionResponse(id: 12, topicId: 7, subjectId: 3, question: 'break vs continue statements', answer: '\nBreak \n- In java the break statement has 3 uses. \n- It terminates a statement sequence in a switch statement. \n- It can be used to exit a loop. \n- It can be used as a civilized form of go to statement. \n- Syntax : break; \n\ncontinue \n- In while and Do while loops, a continue statements causes the control to be transferred directly to conditional expression and then to continue the iteration process. \n- In the case of loop, the increment section of the loop is executed before the test condition is evaluated. \nSyntax : continue; \n\n- The statements break and continue in Java alter the normal control flow of compound statements. \n\n- The break and continue statements do not make sense by themselves. Without labels (see below), break and continue refer to the most closely enclosing for, while, do, or switch statement. With labels the break statement is legal in a labled if statement or a labeled { } block. \n\n- The break statement immediately jumps to the end (and out) of the appropriate compound statement. \n\n- The continue statement immediately jumps to the next iteration (if any) of the appropriate loop. \n\n- A continue statement does not apply to a switch statement or a block statement, only to compound statements that loop: for, while, and do. \n\n- Java does not have a general goto statement. But the statements break and continue take the place of most of uses of the goto. Java does allow any statement to be labeled as in.'),
            InterviewQuestionResponse(id: 13, topicId: 7, subjectId: 3, question: 'Loop constructs', answer: '\n- Use the while statement to loop over a block of statements while a boolean expression remains true. The expression is evaluated at the top of the loop. \n\n- Use the do-while statement to loop over a block of statements while a boolean expression remains true. The expression is evaluated at the bottom of the loop, so the statements within the do-while block execute at least once. The for statement loops over a block of statements and includes an initialization expression, a termination condition expression, and an increment expression. '),
            InterviewQuestionResponse(id: 14, topicId: 7, subjectId: 3, question: 'Using Code of Block', answer: '- Java allows two or more statements to be grouped into blocks of code also called code blocks. \n\n- This is done by enclosing the statements between opening and closing curly braces. \n\n- Once a block of code has been created, it becomes a logical unit that can be used any place that a single statement can. \n\n- For example, a block can be a target for Java’s if and for statements. \n\n- Expression, which is a series of variables, operators, and method calls that evaluates to a single value. \n\n- You can write compound expressions by combining expressions as long as the types required by all of the operators involved in the compound expression are correct. \n\n- But remember Java platform evaluates the compound expression in the order dictated by operator precedence. \n\n- We discussed three kinds of statements: expression statements, declaration statements, and control flow statements.'),

            InterviewQuestionResponse(id: 1, topicId: 8, subjectId: 3, question: 'Adapter class', answer: '- Adapter class is a simple java class that implements an interface only with empty implementation for every method.\n\n- If we implement an interface directly for each and every method compulsory we should provide implementation whether it is required or not. This approach increases length of the code and reduces readability.'),
            InterviewQuestionResponse(id: 2, topicId: 8, subjectId: 3, question: 'class', answer: '- A class is a subclass of itself. \n\n- A class is a template from which objects are created. That is objects are instance of a class. \n\n- Everything in Java is either a class, a part of a class, or describes how a class behaves. \n\n- When you create a class, you are creating a new data – type. You can use this to declare objects of this type. \n\n- Class defines structure and behavior (data & code) that will be shared by a set of objects. \n\n- A class is declared by use of the class keyword. Classes may contain data and code both. \n\n- A class is a group of objects that have common property. It is a template or blueprint from which objectsare created. \n\n- A class in java can contain: data member, method, constructor and block. \n\n- Class is user define data type. \n\n- Class is collection of object. \n\n- Class is a blueprint. \n\n- A class is declared by use of the class keyword. Classes may contain data and code both.'),
            InterviewQuestionResponse(id: 3, topicId: 8, subjectId: 3, question: 'Defining Classes', answer: '- A class is a collection of fields (data) and methods (procedure or function) that operate on that data. \n\n- The fields (data) or variables are also called the instance variables. \n\n- The method and variables defined within a class are called member of the class. \n\n- Instance variables are also known member variables or data. \n\n- Methodname1, methodname2, method name – n are methods that return value of type return type. \n\n- The formal parameters are specified with the data type in parenthesis. These methods are also known member functions. \n\n- The constructor is a method that has same name as a class name. \n\n- Note that in general form we have not specified the main method because the main method is not compulsory for all classes. Only one class of your program can contain main method which is the starting point of program execution. \n\n- Blueprint for objects (of same type). \n\n- Exists at compile time.'),
            InterviewQuestionResponse(id: 4, topicId: 8, subjectId: 3, question: 'A class definition must have the following', answer: '- The keyword "class" followed by the name of the class. \n\n- The class body. \n\n- Before the keyword "class" is the optional modifier "public". \n\n- If a class is public, it must be defined within a file which is the same name as the class with a ".java" extension. \n\n- Most classes are declared public.'),
            InterviewQuestionResponse(id: 5, topicId: 8, subjectId: 3, question: 'Defining Instance Variables', answer: 'Instance variables are declared using the same syntax as ordinary variables.'),
            InterviewQuestionResponse(id: 6, topicId: 8, subjectId: 3, question: 'Variables can be prefixed with a visibility modifier', answer: '- Variables can have one of 4 different visibilities: \n- 1) public – The variable can be directly accessed from anywhere \n- 2) private – The variable can only be directly accessed from within the class \n- 3) protected - The variable can be access directly from within the class, within the package, or from within any subclass. \n- 4) default (no modifier specified) - the variable can be accessed directly from within the package. \n\n- By default variable public. Example: double width; \n\n- To preserve encapsulation, instance variables should be declared private. \n\n- Each object contains its own copy of each variable defined by the class. \n\n- So, every Box object contains its own copy of the instance variable width, height and depth. \n\n- To access these variables, you will use the dot (.) operator. The dot operator links the name of the object with the name of an instance variable.'),
            InterviewQuestionResponse(id: 7, topicId: 8, subjectId: 3, question: 'Object', answer: 'Two types are using object created: \n1) New keyword using \n2) Anonymous object //name less \n- A runtime entity that has state and behaviour is known as an object. \n- For example: chair, table, pen etc. \n- It can be tangible or intangible (physical or logical). \n\nAn object has three characteristics: \n- State: represents the data of an object. \n- Behaviour: represents the behaviour of an object. \n- Identity: Object identity is typically implemented via a unique ID. The value of the ID is not visible to the external user, but is used internally by the JVM to identify each object uniquely. \n- For Example: Pen is an object. Its name is Reynolds, colour is white etc. known as its state. It is used to write, so writing is its behaviour. \n- Object is an instance of a class. Class is a template or blueprint from which objects are created. So object is the instance (result) of a class.'),
            InterviewQuestionResponse(id: 8, topicId: 8, subjectId: 3, question: 'Initializing Object References – new', answer: '- To initialize an object reference, you must assign it the address of an object \n- A new keyword is used to allocate memory at runtime, new keyword is used for create an object of class. \n- The new operator creates a new instance and returns the address of the newly created object. \n- new allocates memory for the object \n- new also invokes a method on the object called a constructor \n- new returns the address of the memory allocated for the object. \n\nEmployee obj; [...] obj = new Employee(); \n\n- new is a keyword which is used when we are creating an object of class for storing all the data like variables and member functions of class there is some memory space that is to be needed so that with the help of new keyword and object is instantiated or simply an object reserves. \n- Some memory or some new memory is allocated to class object for storing data and member functions of class so every object must are created with the help of new keyword so for allocating new memory area. \n- Each object is having its own copy of instance variable. \n- String type and we have not assigned any value it is null. But integer type so its default value is 0.'),
            InterviewQuestionResponse(id: 9, topicId: 8, subjectId: 3, question: 'Assigning Object References', answer: '- Assigning one reference to another results in two references to the same object \n- If two references contain the same memory address, they are referring to the same object. \n- Remember testing for equality of Strings using == \n- Each object has a reference count \n- When an object of reference count becomes zero, it will be collected by the garbage collector \n\nclass_name obj = new class_name(); \nclass_name obj = class_name;'),
            InterviewQuestionResponse(id: 10, topicId: 8, subjectId: 3, question: 'Anonymous object', answer: '- Anonymous simply means nameless. An object that have no reference is known as anonymous object. \n- If you have to use an object only once, anonymous object is a good approach.'),
            InterviewQuestionResponse(id: 11, topicId: 8, subjectId: 3, question: 'Instance variable', answer: '- A variable that is created inside the class but outside the method is known as instance variable. Instance variable does not get memory at compile time. \n\n- It gets memory at runtime when object (instance) is created. That is why, it is known as instance variable. \n\n- Instance variables are variables within a class but outside any method. These variables are instantiated when the class is loaded.  Instance  variables  can  be  accessed  from  inside  any  method, constructor or blocks of that particular class \n\n- Java primitive types (int, short, long, double, char, boolean, float byte) will have default value which is assigned to instance variable while creating an object.. String is a java class so it is pointing to null.'),
            InterviewQuestionResponse(id: 12, topicId: 8, subjectId: 3, question: 'Variable', answer: '- “A variable is name of data type which is stored value of data type”. Variable is the basic unit of storage in a java program. \n\n- A variable is defined by the combination of identifiers, a type and an optional initialize. \n\n- All variable have a scope, which defines their visibility and a life time. \n\n- All variable must be declared before they can be used. The basic form variable declaration and initialization are following. \n\nDeclaration: When we create new variable then it is known as declaration. \nSyntax : Datatype identifier1, identifier2;'),
            InterviewQuestionResponse(id: 13, topicId: 8, subjectId: 3, question: 'Local variable', answer: '- The Local variable is declared inside the method. When method is invoked then local variable is executed. The Local has no default value. \n\n- The name of local variable is same as static and instance variable but in that case the local variable hides the static and instance variable. \n\n- The scope is the region (place) where the local variable is executed.  	 \n\n- Local variables are always created on stack memory. Stack memory is part of RAM. Objects are created on HEAP memory. Heap memory is also part of RAM. In our case instance variables rollno and name are created on Heap memory while local variables rollno and name (which defined in the arguments of setValues method are created on RAM memory.'),
            InterviewQuestionResponse(id: 14, topicId: 8, subjectId: 3, question: 'What is variable? How to declare and initialize variable in java?', answer: 'In java three type of variable \n1) Instance variable (to call object through) \n2) Static variable \n3) Local variable (Internal) '),
            InterviewQuestionResponse(id: 15, topicId: 8, subjectId: 3, question: 'instanceof', answer: '- instanceof is a keyword. \n\n- It checks if an object reference is an instance of a type, and returns a boolean value; \n\n-  The <object-reference> instanceof Object will return true for all non-null object references, since all Java objects are inherited from Object. instanceof will always return false if <object-reference> is null. \n\nSyntax : <object-reference> instanceof typeName'),
            InterviewQuestionResponse(id: 16, topicId: 8, subjectId: 3, question: 'static fields, also called class variables', answer: '- A given class will have only one copy of each of its static fields or class variables, and these will be shared between and among all the objects of the class. \n\n- Each class variable exists even if no objects of the class have been created. \n\n-Class variables belong to the class, and they can be referenced by any object or class method, not just methods belonging to instances of that class. \n\n- If the value of a static field is changed, the new value is available equally in all the objects of the class. \n\n-This is quite different from non-static fields, where changing a value for one object does not affect the values in other objects. \n\n- A static field must be declared using the keyword static preceding the type name.'),
            InterviewQuestionResponse(id: 17, topicId: 8, subjectId: 3, question: 'Method', answer: '- In java, a method is like function i.e. used to expose behaviour of an object. \n\n- The methods that you define for a class provide the actions that can be carried out using the variables specified in the class definition. \n\n- The method returns a value, in which case a primitive data type or reference is passed back to the caller of the method.\n\n- The method does not return a value, in which case the return value is declared as void. \n\n- The method throws an exception, which is thrown back to the caller of the method. Exceptions are “Exception Handling” document. \n\nTypes of methods: Instance method, Class method, static method, final method, abstract method etc. \n\n1) Instance method \n- Instance method requires an object of its class to be created before it can be called while static method does not require object creation. \n- Instance methods are associated with an object and use the instance variables of that object. This is the default. \n- Any instance method that accesses only static variables and methods. \n\n2) Class method  \n- A method that is invoked without reference to a particular object. Class methods affect the class as a whole, not a particular instance of the class. \n\n3) static method \n- The main() method is static, because it must be executed before any object of that class it created. \n- Class variables, class methods are declared using the keyword static, so they are sometimes referred to as static methods. \n- Static methods can be executed when there are no objects in existence, they cannot refer to instance variables. \n- Static methods may not access the instance variables of their class (or any other class for that matter), other than via some object reference. \n- All static methods are automatically final. \n- Static methods and variable are in a sense inherited, but not in the same strong sense that instance variables and methods are. \n- Static methods in Java can be called without creating an object of class. \n- Static methods only have access to static variables and methods of the class. Static methods may even access private instance variables in their class via some object reference.'),
            InterviewQuestionResponse(id: 18, topicId: 8, subjectId: 3, question: 'Advantage of method', answer: '1) Code Reusability \n2) Code Optimization'),
            InterviewQuestionResponse(id: 19, topicId: 8, subjectId: 3, question: 'new keyword', answer: 'The new keyword is used to allocate memory at runtime.'),
            InterviewQuestionResponse(id: 20, topicId: 8, subjectId: 3, question: 'What are the different ways to create an object in Java?', answer: 'There are many ways to create an object in java. They are: \n1) By new keyword \n2) By new Instance() method \n3) By clone() method \n4) By factory method etc.'),
            InterviewQuestionResponse(id: 21, topicId: 8, subjectId: 3, question: 'Method with variable no. of arguments', answer: '- In Java, we can pass variable number of arguments of same data type to a method. In the method header, we specify the parameter type followed by ellipsis ( ... ) and the object which stores the passed arguments. \n\n- Only one variable length parameter can be present and that must be the last parameter. Other parameters must come before the variable length parameter.'),
            InterviewQuestionResponse(id: 22, topicId: 8, subjectId: 3, question: 'The Parameter List', answer: '- The parameter list appears between the parentheses following the method name. \n\n- This specifies the type of each value that can be passed as an argument to the method, and the variable name that is used in the body of the method to refer to each argument value passed to the method when it is called.  \n\nThe difference between a parameter and an argument is sometimes confusing because people often, in correctly, use them interchangeably. I will try to differentiate them consistently, as follows: \n\n- A parameter has a name and a type and appears in the parameter list in the definition of a method. A parameter defines the type of value that can be passed to the method when it is called. \n\n- An argument is a value that is passed to a method when it is executed, and the value of the argument is referenced by the parameter name during execution of the method. Of course, the type of the argument value must be consistent with the type specified for the corresponding parameter in the definition of the method.'),
            InterviewQuestionResponse(id: 23, topicId: 8, subjectId: 3, question: 'Final Parameters', answer: '- You can specify any of the parameters for a method as final. This has the effect of preventing modification of any argument value that is substituted for the parameter when you call the method.  \n\n- The compiler will check that your code in the body of the method does not attempt to change any final parameters. \n\n- Since the pass-by-value mechanism makes copies of values of the basic types, final really makes sense only when it is applied to parameters that are references to class objects. \n\n- Specifying a parameter of a class as final is of limited value.  \n\n- It does prevent accidental modification of the object reference that is passed to the method, but it does not prevent modification of the object itself.'),
            InterviewQuestionResponse(id: 25, topicId: 8, subjectId: 3, question: 'Invoking instance methods', answer: '- To invoke a method on an object, use the . (dot) operator \nobject Reference.methodName(parameters); - If there is a return value, it can be used as an expression \n\nIntroducing Methods type name (parameter - list) { body of method } \n\nWhere \nType: Specific the type of data returned by the method. If the method does not return a value its return type must be void. \nName: Specifies the name of the method. \nParameter - list: \n- It is a sequence of type & identifiers pairs separated by commas.\n- Parameters are variables that receive the value of the argument passed to the method when it is called. If the method has no parameters, then the parameter list will be empty. \n- Methods that have a return type other than void return a value to calling routine using the following form of the return statement;return value;'),
            InterviewQuestionResponse(id: 26, topicId: 8, subjectId: 3, question: 'Types of methods', answer: '1) Does not return value – void \n2) Returning a value \n3) Method which takes parameter'),
            InterviewQuestionResponse(id: 27, topicId: 8, subjectId: 3, question: 'Types of method', answer: '- In java, a method is like function i.e. used to expose behaviour of an object. \n- The methods that you define for a class provide the actions that can be carried out using the variables specified in the class definition. \n- The method returns a value, in which case a primitive data type or reference is passed back to the caller of the method. \n- The method does not return a value, in which case the return value is declared as void. \n- The method throws an exception, which is thrown back to the caller of the method. Exceptions are “Exception Handling” document. \n\n- Types of methods: Instance method, Class method, static method, final method, abstract method etc. \n Instance method \n- Instance method requires an object of its class to be created before it can be called while static method does not require object creation. \n- Instance methods are associated with an object and use the instance variables of that object. This is the default. \n- Any instance method that accesses only static variables and methods. \n\nClass method \n- A method that is invoked without reference to a particular object. Class methods affect the class as a whole, not a particular instance of the class. \n\nstatic method \n- The main() method is static, because it must be executed before any object of that class it created. \n- Class variables, class methods are declared using the keyword static, so they are sometimes referred to as static methods. \n- Static methods can be executed when there are no objects in existence, they cannot refer to instance variables. \n- Static methods may not access the instance variables of their class (or any other class for that matter), other than via some object reference. \n- All static methods are automatically final. \n- Static methods and variable are in a sense inherited, but not in the same strong sense that instance variables and methods are. \n- Static methods in Java can be called without creating an object of class. \n- Static methods only have access to static variables and methods of the class. Static methods may even access private instance variables in their class via some object reference'),
            InterviewQuestionResponse(id: 28, topicId: 8, subjectId: 3, question: 'Constructor', answer: '- Constructor is a special type of method that is used to initialize the state of an object. Constructor is in invoked at the time of object creation. \n- It constructs the values i.e. data for the object that is why it is known as constructor. \n- Constructor is just like the instance method but it does not have any explicit return type. \n- Constructors are methods defined inside a class which have the same name as the class, and which are used to create an instance of a class. \n- This can also be called  creating an object, as in: Car c = new Car(); \n- Constructors are also used for the initialization of objects. \n- Every class has at least one its own constructor. \n- Constructor creates an instance for the class. \n- Constructor initiates (initialize) something related to the class of methods. \n- Constructor is the method which name is same to the class. \n- Another thing is that when a class is instantiate the constructor is called automatically. \n- Constructors must have the same name as the class itself. \n- The only action taken by the implicit default constructor is to call the superclass constructor using the super() call. Constructor arguments provide you with a way to provide parameters for the initialization of an object. \n- Constructor is a special method that is used to initialize a newly created object and is called just after the memory is allocated for the object. \n- It can be used to initialize the objects, to required, or default values at the time of object creation. It is not mandatory for the coder to write a constructor for the class. \n\n- If no user defined constructor is provided for a class, compiler initializes member variables to its default values. \n- numeric data types are set to 0. \n- char data types are set to null character(‘\0’). \n- reference variables are set to null. \n\n Constructors have the following characteristics \n- Constructor name is a class name. \n- There is no return type.  Not even void. \n- Constructor’s definitions should not be static. Because constructors will be called each and every time whenever an object is creating. \n- Constructor should not be private provided an object of one class is created in another class (Constructor can be private provided an object of one class created in the same class). \n- Constructors will not be inherited from one class to another class (Because every class constructor is meant for initializing its own data members). \n- The access specifier of the constructor may or may not be private. \n- The method name is the same name as the class. \n- Constructors can be overloaded. \n- Constructor may be virtual. \n- Constructor of one class can call constructor of other class using super keyword. \n- Constructor is used to initialize object. \n- Generally constructor is declared as public mode. \n- Constructor need not call; it calls automatically when object creates. \n- Constructor name and class name must be same. \n- The name of the constructor must match the name of the class. \n- Constructor can be overloaded like regular methods. \n\n In order to put the object into a usable state, its instance variables should be initialized to usable values \n1) This could be accomplished by calling the various set methods \n2) This is not always possible because it is not required that all instance variables have set methods. \n- Java provides for another method of initializing objects. \n- When an object is created (using new), a constructor is invoked. The responsibility of the constructor method is to initialize the object into a usable state. \n\nWhen an object is created (using new) the compiler determines which constructor is to be invoked by the parameters passed \n\n Multiple constructors allow the class programmer to define many different ways of creating an object. \n\nIf no constructors are defined for a class, the compiler automatically generates a default, no argument constructor : All instance variables are initialized to default values. \n- However, if any constructor is defined which takes parameters, the compiler will NOT generate the default, no argument constructor : If you still need one, you have to explicitly define one. \n\nRules for creating constructor \n- There are basically two rules defined for the constructor. \n1) Constructor name must be same as its class name. \n2) Constructor must have no explicit return type.'),
            InterviewQuestionResponse(id: 29, topicId: 8, subjectId: 3, question: 'Constructor type', answer: '1) Default constructor (No – argument constructor) \n- Default Constructor is also called as Empty Constructor which has no arguments automatically called when we creates the object of class but remember name of Constructor is same as name of class. \n- The only action taken by the implicit default constructor is to call the super class constructor using the super() call.  \n- Constructor arguments provide you with a way to provide parameters for the initialization of an object. \n\nOr \n- A constructor with no parameters is referred to as a default constructor. \n\n2) Parameterized Constructor \n- Constructor which takes parameter during the time of invocation is called parameterized constructor. \n\n3) Copy constructor \n- Takes object as an argument. It copies one object into another object.'),
            InterviewQuestionResponse(id: 30, topicId: 8, subjectId: 3, question: 'Constructor chaining', answer: '- Consider a scenario where a base class is extended by a child .Whenever an object of the child class is created, the constructor of the parent class is invoked first. This is called Constructor chaining. \n\n- Call one Constructor from other Constructor is called Constructor Chaining. \n\n- Constructor chaining occurs through the use of inheritance. There can be any number of classes in the inheritance. Each constructor will call the chain until it reaches the super class and initialized. Then it initialized the subclasses and go to original subclass. \n\n- this() and super() statement is used to call one constructor from other. \n\n- this() is used to call constructor from same class but super() is used to call constructor from the super class'),
            InterviewQuestionResponse(id: 31, topicId: 8, subjectId: 3, question: 'Destructor', answer: 'Destructors are called just before an object is destroyed and can be used to run clean-up code. You can’t control when a destructor is called.'),
            InterviewQuestionResponse(id: 32, topicId: 8, subjectId: 3, question: 'Method Overloading', answer: 'If a class has multiple (two or more) methods by same name but different parameters, it is known as Method Overloading.  If argument is same then compiler generates ambiguity. Method overloading is a compile time and achieved polymorphism. \n\nArgument lists could differ in \n1) Number of parameters. \n2) Data type of parameters. \n3) Sequence of Data type of parameters. \n- This feature is known as Method overloading/ Static Polymorphism. In case of method overloading the binding of method call to its definition happens at Compile time. \n\nPoints to Note \n1) Static Polymorphism is also called as compile time binding or early binding. \n2) Static binding is used for supporting overloaded methods in java. \n- Method overloading is a way by which java achieve polymorphism. \n- Method overloading enables you to specify different type of information (Parameter) to send to a method, to overload a method you declare another with the same name but different parameter. \n- Java allows you to define several methods in a class with the same name, as long as each method has a unique set of parameters. \n- When in a class there is more than one method with same name but different number and / or types of parameters, the method is said to be overloaded and this process known as method overloading. \n- The number and type of parameters of a method is known as type signature. \n- Remember that return type is not considered in type signature. \n- So you can say that if there is more than one method in a class with same name but different type signature, the method is said to be overloaded. \n- When a method is called, java matches, java invokes that method. If no exact type of parameter is matched, java tries to convert type.  \n- If it can be done implicitly, java does it and calls that method. \n- If you have two or more methods with same type signature but with different return types, it is not method overloading.  \n- In this case, you will get an error saying “method is already defined in class”. \n- The benefit of method overloading is that it allows you to implement methods that support the same semantic operation but differ by argument number or type.'),
            InterviewQuestionResponse(id: 33, topicId: 8, subjectId: 3, question: 'Overloaded method note', answer: '- Overloaded methods must change the argument list. \n- Overloaded methods can change the return type. \n- Overloaded methods can change the access modifier. \n- Overloaded methods can declare new or broader checked exceptions. \n- A method can be overloaded in the same class or in a subclass.'),
            InterviewQuestionResponse(id: 34, topicId: 8, subjectId: 3, question: 'Different ways to overload the method', answer: '1) By changing number of arguments. \n2) By changing the data type.'),
            InterviewQuestionResponse(id: 35, topicId: 8, subjectId: 3, question: 'Can we overload main() method?', answer: '•	Yes, by method overloading. You can have any number of main methods in a class by method overloading.'),
            InterviewQuestionResponse(id: 36, topicId: 8, subjectId: 3, question: 'Why method overloading is not possible by changing the return type of method?', answer: '•	In java, method overloading is not possible by changing the return type of the method because there may occur ambiguity.'),
            InterviewQuestionResponse(id: 37, topicId: 8, subjectId: 3, question: 'Constructor Overloading', answer: '- When we create more than one constructor with different parameters, it is called constructor overloading. If argument is same then compiler generates ambiguity. \n- Sometimes it is needed to create objects with less or no parameters. \n\nOverloading Rules \n- First and foremost rule to overload a method in Java is to change method signature. Method signature is made of number of arguments, type of arguments and order of arguments if they are of different types. \n- Return type of method is not part of method signature, so just changing the return type will not overload method in Java. \n\n- Constructor overloading is a technique in Java in which a class can have any number of constructors that differ in parameter lists. The compiler differentiates these constructors by taking into account the number of parameters in the list and their type.'),
            InterviewQuestionResponse(id: 38, topicId: 8, subjectId: 3, question: 'Does constructor return any value?', answer: 'Yes, that is current class instance (You cannot use return type yet it returns a value).'),
            InterviewQuestionResponse(id: 39, topicId: 8, subjectId: 3, question: 'Copying the values of one object to another like copy constructor in C++', answer: '1) By constructor \n2) By assigning the values of one object into another \n3) By clone() method of Object class'),
            InterviewQuestionResponse(id: 40, topicId: 8, subjectId: 3, question: 'Can constructor perform other tasks instead of initialization?', answer: '•	Yes, like object creation, starting a thread, calling method etc. You can perform any operation in the constructor as you perform in the method.'),
            InterviewQuestionResponse(id: 41, topicId: 8, subjectId: 3, question: 'Constructor and Method', answer: '- Constructor name is same as class name. Method name can not be class name. \n- Constructor does not have return type. Method always has return type. \n- Constructor are called at the time of object creation process. Methods are called using operator after object is created. \n- Constructor are called internally from each other using this and super. Methods are called with method-name. \n- Constructor is mainly used for initialization of the instance variables. Methods are used mainly for providing functionality to the class.'),
            InterviewQuestionResponse(id: 42, topicId: 8, subjectId: 3, question: 'Command line argument', answer: '- Sometimes you will want to pass information into a program when you run it. \n- This is accomplished by passing command-line arguments to main() method. This can be done at runtime. \n- A command-line argument is the information that directly follows the program’s name on the command line when it is executed. \n- To access the command-line arguments inside a Java program is quite easy they are stored as strings in a String array passed to the args parameter of main(). \n- The first command-line argument is stored at args[0], the second at args[1], and so on. \n- The command-line argument is an argument passed at the time of running the java program. \n- The argument can be received in the program and used as an input. \n- So, it provides a convenient way to check out the behavior of the program on different values. \n- You can pass Numbers of arguments from the command prompt.'),
            InterviewQuestionResponse(id: 43, topicId: 8, subjectId: 3, question: 'Recursion', answer: '- The methods you have seen so far have been called from within other methods, but a method can also call itself. \n- A method that calls itself is described as a recursive method, and the process is referred to as recursion.  \n- A Recursion is function which call itself. This enables the function to repeat itself several times, outputting the result and the end of each iteration. \n- You can also have indirect recursion where a method A calls another method B, which in turn calls the method A.'),
            InterviewQuestionResponse(id: 44, topicId: 8, subjectId: 3, question: 'static ', answer: '- The static keyword is used in java mainly for memory management. We may apply static keyword with variables, methods and blocks. \n- The static keyword belongs to the class than instance of the class. \n- Normally we can access member variables and methods by the object of its class. But sometimes we need to define a class member that can be used without object of its class. \n- The static members are initialized and static method are executed before any its class are created. \n- The main() method is static, because it must be executed before any object of that class is created. \n\nThere are some rules for static members: \n- The static members can call only static methods and access only static variables. \n- They cannot refer to this or super. (super keyword is related to inheritance and is discussed in next topic). \n- The static method of other class can be called by the class name in which it is defined. You don’t have to create an object in this case. \n\nThe static can be: \n1) Variable (also known as class variable). \n2) Method (also known as class method). \n3) Block.'),
            InterviewQuestionResponse(id: 45, topicId: 8, subjectId: 3, question: 'static variable', answer: '- If you declare any variable as static, it is known static variable. \n- Static variable is shared all object of its class. To created static variable the keyword static is used before variable name. \n- The static variable can be used to refer the common property of all objects (that is not unique for each object) e.g. company name of employees, college name of students etc. \n- The static variable gets memory only once in class area at the time of class loading. \n\nSyntax \nstatic data type var_name; \nFor example: static int a; \n\n- The static variable has by default zero value when its class loads into memory. (Object create to its class) \n- The static variable is direct related to class. A static variable is exit within class.'),
            InterviewQuestionResponse(id: 46, topicId: 8, subjectId: 3, question: 'Advantage of static variable', answer: 'It makes your program memory efficient (i.e. it saves memory).'),
            InterviewQuestionResponse(id: 47, topicId: 8, subjectId: 3, question: 'static method', answer: '- If you apply static keyword with any method, it is known as static method. \n\nExample: static void static_method() { } \n\n- A static method belongs to the class rather than object of a class. \n- A static method can be invoked without the need for creating an instance of a class. \n- static method can access static data member and can change the value of it. \n- They cannot use this or super() anyway.'),
            InterviewQuestionResponse(id: 48, topicId: 8, subjectId: 3, question: 'Restrictions for static method', answer: 'There are two main restrictions for the static method. They are: \n1) The static method cannot use non static data member or call non - static method directly. \n\n2) this and super cannot be used in static context.'),
            InterviewQuestionResponse(id: 49, topicId: 8, subjectId: 2, question: 'Can we override static method?', answer: 'We cannot override static methods. Static methods are belogs to class, not belongs to object. Inheritance will not be applicable for class members.'),
            InterviewQuestionResponse(id: 50, topicId: 8, subjectId: 3, question: 'Why main method is static?', answer: 'Because object is not required to call static method if it were non-static method, JVM creates object firstthen call main() method that will lead the problem of extra memory allocation.'),
            InterviewQuestionResponse(id: 51, topicId: 8, subjectId: 3, question: 'static block / Initializer block', answer: '-You may define static block of statement to be executed when a class is loaded into memory. This known as static initialization block. \n- Is used to initialize the static data member. \n- It is executed before main method at the time of class loading. \n- Initialize block defined using the keyword static. \n- Executed once when the class loaded. \n- Can initialize only static data member of the class. \n\nSyntax class cls_name { static { statement block; } }'),
            InterviewQuestionResponse(id: 52, topicId: 8, subjectId: 3, question: 'Can we execute a program without main() method?', answer: 'Yes, one of the way is static block but in previous version of JDK not in JDK 1.7.'),
            InterviewQuestionResponse(id: 54, topicId: 8, subjectId: 3, question: 'System class', answer: '- The “SYSTEM” class provides facilities like input streams, output stream s, error streams. \n- The System class cannot be instantiated to create objects. The System class display Java related Environment properties.'),
            InterviewQuestionResponse(id: 55, topicId: 8, subjectId: 3, question: 'Super keyword', answer: '- Like this in java one most important keyword is there i.e. super. super in Java has a wide use and it is mainly used to call the super class constructor explicitly by the user and implicitly used by the JVM to initialize the super class property. \n\n- The Super is a java keyword. \n\n- If you have “child class” overriding methods in “parent class”, you can invoke overridden methods using super keyword. \n\n- super is a reference variable that is used to refer immediate parent class object. \n\n- super is used to access the members of the super class. \n\n- It is used for two purposes in java. \n\n1) The first use of keyword super is to access the hidden data variables of the super class hidden by the sub class. \n- E.g. suppose class A is the super class that has two instance variables as int a and float b. class B is the subclass that also contains its own data members named a and b. then we can access the super class (class A) variables a and b inside the subclass class B just by calling the following command. \n\n- It has advantage so that you don’t to have to perform operations in the “parent class” again. \n\n- Only the immediate “parent class” data and methods can be accessed.\n\n- In the preceding ex, classes derived from Box were not implemented as efficiently as they, could have been. For ex, The constructor for BoxWeight explicitly initializes the width, height and depth fields of Box(). \n\n- Not only does this duplicate code found in its super class, which is inefficient, but it implies that a subclass must be granted access to these members. \n\n- However, sometimes you want to create a super class that keeps the details of its implementation to itself (i.e. it keeps its data members private). In this case, there would be no way for a subclass to directly access or initialize these variables on its own. \n\n- Since encapsulation provides a solution to this problem. Whenever a subclass needs to refer to its immediate super class, it can do so by use of the keyword super. \n\n- super is a keyword which is used to access the method or member variables from the superclass. If a method hides one of the member variables in its superclass, the method can refer to the hidden variable through the use of the super keyword. In the same way, if a method overrides one of the methods in its super class, the method can invoke the overridden method through the use of the super keyword.'),
            InterviewQuestionResponse(id: 56, topicId: 8, subjectId: 3, question: 'Super note', answer: '- You can only go back one level. \n- In the constructor, if you use super(), it must be the very first code, and you cannot access any this.xxx variables or methods to compute its parameters. \n\nThere are two types of super keyword \n1) It calls super class constructor. \n2) It is used to access a member of the super class that has been hidden by member of subclass. (variable or method). \n3) super is used to invoke immediate parent class method. \n\nThe super keyword is used when argument of super constructor or method is passed into argument of sub constructor or method. \n\nSyntax : super (args); \n\n- If user does not used super or this keyword then compiler automatically called super keyword. \n\n- The super keyword must be declared before this keyword if both keyword is used simultaneously.'),
            InterviewQuestionResponse(id: 57, topicId: 8, subjectId: 3, question: 'Important points regarding super in java', answer: '- If there are no constructor then a default constructor is invoke by the JVM to place a super() which will call the super-class constructor. \n\n- If we have any constructor with some implementation then also compiler will place one super() to call super-class constructor. \n\n- If we have a parameterized constructor and in which first statement is this( value ) , then it will recursively call the sub-class constructor and hence there will no chance to call super-class constructor. In this case compiler will give compilation error. \n\n- Always make sure that if a class in inheriting another class then there must  be a super() call through sub-class constructor either explicitly by the user or implicitly by the JVM to initialize the super-class property , otherwise compiler will give compilation error.'),
            InterviewQuestionResponse(id: 58, topicId: 8, subjectId: 3, question: 'Important uses of super', answer: '- It is used to initialize the super-class property by invoking super-class constructor from sub-class constructor. \n\n- Inherited members are accessible with the help of super. \n\n- If we have member defined in the sub-class and super-class with the same name then super is used to refer the super-class member where as this is used to refer current class member. \n\n- It is used to refer the member of current object which is inherited from super-class. \n\n- In a inheritance hierarchy at last super() is calling to object class constructor which indicates the end of calling super - class constructor.'),
            InterviewQuestionResponse(id: 59, topicId: 8, subjectId: 3, question: 'What is the difference between super() and this()?', answer: 'super() is used to call super class constructor, whereas this() used to call constructors in the same class, means to call parameterized constructors.'),

            InterviewQuestionResponse(id: 1, topicId: 9, subjectId: 3, question: 'Arrays', answer: '- An array is a group of like - typed variables that are referred to by a common (same) name. \n\n- Contains static methods to sort, search, compare, hash, copy, resize, replace string convert to string, and fill arrays of primitives and objects. \n\n- Arrays of any type can be created and may have one or more dimensions.  \n\n- A specific element in an array is accessed by its index. Arrays offer a convenient means of grouping related information. \n\n- A variable which can hold multiple values of similar data type. \n\n- Each element is differentiated by a number called index number. \n\n- Index number starts with 0. \n\n- Use new keyword to create an array. Array is the collection of homogeneous (same) type values. \n\n- Array takes sequential memory allocation.'),
            InterviewQuestionResponse(id: 2, topicId: 9, subjectId: 3, question: 'Advantage of Array', answer: '- Code Optimization: It makes the code optimized, we can retrieve or sort the data easily. \n\n- Random access: We can get any data located at any index position.'),
            InterviewQuestionResponse(id: 3, topicId: 9, subjectId: 3, question: 'Disadvantage of Array', answer: '•	Size Limit: We can store only fixed size of elements in the array. It does not grow its size at runtime. To solve this problem, collection framework is used in java.'),
            InterviewQuestionResponse(id: 4, topicId: 9, subjectId: 3, question: 'Allocation', answer: 'Allocation: to allocate memory of array into disk is known as allocation for this purpose we used a keyword "new". Which is allocate memory of array. \n\nSyntax : array_namec = new datatype[size];'),
            InterviewQuestionResponse(id: 5, topicId: 9, subjectId: 3, question: 'One - Dimensional Array', answer: '- A one - dimensional array is, essentially, a list of like-typed variables.  To create an array, you first must create an array variable of the desired type. \n\nSyntax : type var - name[];'),
            InterviewQuestionResponse(id: 6, topicId: 9, subjectId: 3, question: 'Multidimensional Arrays', answer: '- In Java, multidimensional arrays are actually arrays of arrays. These, as you might expect, look and act like regular multidimensional arrays. \n\n- However, as you will see, there are a couple of subtle differences. \n\n- To declare a multidimensional array variable, specify each additional index using another set of square brackets. \n\nSyntax : Datatype name_of_array[][] = new datatype[total rows][total columns];'),
            InterviewQuestionResponse(id: 7, topicId: 9, subjectId: 3, question: 'Ragged Array', answer: '- Ragged array is an array which is having two or more dimensions and we can assign different size of dimensions. \n\nExample \nint[][] array = new int[2][]; \narray[0] = new int[4]; \narray[1] = new int[6];'),
            InterviewQuestionResponse(id: 8, topicId: 9, subjectId: 3, question: 'Jagged Arrays – Varying Column Size Arrays', answer: '•	In Jagged arrays, each row, in a two-dimensional array, may contain different lengths. Let us design a two-dimensional array with 4 rows where the first row contains 4 elements, the second row with 1 element, the third row with 2 elements and the fourth row with 3 elements.'),
            InterviewQuestionResponse(id: 9, topicId: 9, subjectId: 3, question: 'Anonymous Arrays', answer: '- Sometimes we can create an array without name such type of nameless arrays are called anonymous arrays. \n\n- The main objective of anonymous arrays is “just for instant use”. \n\nWe can create anonymous array as follows. \nnew int[]{10,20,30,40};(valid) \nnew int[][]{{10,20},{30,40}};(valid) \n\n- At the time of anonymous array creation we can’t specify the size otherwise we will get compile time error.'),
            InterviewQuestionResponse(id: 10, topicId: 9, subjectId: 3, question: 'Array are passed by reference', answer: '•	Arrays are passed to functions by reference, or as a pointer to the original. This means anything you do to the Array inside the function affects the original.'),
            InterviewQuestionResponse(id: 11, topicId: 9, subjectId: 3, question: 'Type Conversion and Casting', answer: '- It is common to assign a value of one type to a variable of another type. \n\nOR\n\n The process of converting one data type to another is called Casting. \n\n- If the two types are compatible than type conversion takes place. \n\n- This conversion is done automatically (Implicit) by Java. \n\n- For example, an integer value is automatically assigned to a long variable.  \n\n- If you will store an int value into a byte variable directly, this will be illegal operation. For storing your calculated int value in a byte variable you will have to change the type of resultant data which has to be stored. \n\n- It is not necessary that this type of automatic type conversion takes place. There are two rules to convert a value from one type to another type. \n1) The two types are compatible. (Explicit Conversion) \n2) The destination type is larger than the source type. (Implicit Conversion)'),
            InterviewQuestionResponse(id: 12, topicId: 9, subjectId: 3, question: 'Implicit Conversion (Automatically conversion or Widening conversion)', answer: '- When you are converting data from small sized data type to big sized data type, i.e. when you are converting data from left-placed data type to right-placed data type in the above order, auto widening will be used. \n\n- The implicit conversion take place automatically when the types are compatible and the destination type is larger than the source type. \n\n- Implicit conversions do not require any operator. They are automatically performed when a value is copied to a compatible type. \n\n- For example, if we assign type value to a long type variable, it will be converted automatically. \n\n- The first point says that the source and destination should be compatible. It means that if one is in numeric form than another one must be in numeric form. It is not possible to assign a numerical value to a boolean variable. \n\n- char and boolean type are not compatible with each other.  \n\nThe final result of an expression is converted tp the type of the variable on the left of the assignment sign before assigning the value to it. However, the following changes are introduced during the final assignment. \n- float to int causes truncation of the fractional part. \n- double to float causes rounding of digits. \n- long to int causes dropping of the excess higher order bits.'),
            InterviewQuestionResponse(id: 13, topicId: 9, subjectId: 3, question: 'Explicit type conversion (Narrowing conversion)', answer: '- The second point says that the source should be smaller than the destination variable in type, the conversion will not be done automatically. \n\n- When you are converting data from right-placed data type to left-placed data type in the above order, explicit narrowing will be used. \n\n- For example it is possible that a integer type value is automatically converted into byte. \n\nOR \n\n- Explicit casting in the process in which the complier are specifically informed to about transforming the object. \n\n- There are occasions’ where the automatic type conversion does not take place. \n\n- For example, what if you want to assign an int value to a byte variable? \n\n- This conversion will not be performed automatically, because byte is smaller than int. \n\n- This type of conversion is sometimes called a narrowing conversion, since you are explicitly making the value narrower so that it will fit into the target type. \n\n- To create a conversion between two incompatible types, you must use a cast. \n\n- A cast is simply an explicit type conversion. \n\n- It has this general form: (target-type) value \n\n- Here target-type specifies the desired type to convert the specified value to. \n\n- For example, the following fragment casts an int to a byte. \n\n- If the Integer of value is larger than the range of a byte. \n\n- It will be modulo (the remainder of an integer division by the) byte of range. \n\n- For example, int a=128; byte b; b=(byte)a; \n- Here variable b will contain 1 as the calculation of 128%127.'),
            InterviewQuestionResponse(id: 14, topicId: 9, subjectId: 3, question: 'Type casting', answer: '- Type casting in java or simply casting is used to convert data from one data type to another data type. Please note that by using casting, data cannot be modified but only type of data can be modified. \n\nThere are two types of casting: \n1) Primitive Casting \n2) Derived Casting \n\nPrimitive Casting \n- Primitive Casting is used to convert data from one primitive data type to another primitive data type. \n- Consider primitive data types in java which represent the numbers. \nWhen you put them in the increasing order of their memory size, you getbyte < short < int < long < float < double. \nPlease remember this order we will be using this order in below examples. byte is the smallest data type and double is the biggest data type in terms of memory size. \n\nThere are two types in primitive casting: \n1) Auto Widening \n2) Explicit Narrowing \n\nDerived Casting \nDerived casting is used to change the type of object from one user defined data type to another user defined data type in the class hierarchy. \n\nThere are two types in derived casting: \n1) Auto-up Casting \n2) Explicit Down Casting. \n\nAuto-Up Casting \n- Auto-Up Casting is used to change the type of object from sub class type to super class type. i.e an object of sub class type is automatically converted to an object of super class type. \n\nExplicit Down Casting \n- Explicit down Casting is used to change the type of object from super class type to sub class type. i.e. you have to explicitly convert an object of super class type to an object of sub class type.'),

            InterviewQuestionResponse(id: 1, topicId: 10, subjectId: 3, question: 'What is package?', answer: '- Packages are containers for classes that are used to keep the class name space compartmentalized. \n\n- Packages are stored in a hierarchical manner and are explicitly imported into new class definitions. \n\n- The Java libraries are divided into packages, including java.lang, which contains most of the classes we have used so far, and java.awt, the Abstract Window Toolkit (AWT), which contains classes for windows, but-tons, graphics, etc. \n\n- To use a class defined in another package, you have to import it. \n\n- Class was taken from the same namespace. This means that a unique name had to be used for each class to avoid name collisions. \n\n- The package is both a naming and a visibility control mechanism. You can define classes inside a package that are not accessible by code outside that package. \n\n- You can also define class members that are only exposed to other members of the same package. \n\n- A Java package is a naming context for classes and interfaces. A package is used to create a separate name space for groups of classes and interfaces. Packages are also used to organize related classes and interfaces into a single API unit and to control accessibility to these classes and interfaces. \n\n- For example: The Java API is grouped into libraries of related classes and interfaces; these libraries are known as package.'),
            InterviewQuestionResponse(id: 2, topicId: 10, subjectId: 3, question: 'Defining a Package', answer: '- Simply include a package command as the first statement in a Java source file. Any classes declared within that file will belong to the specified package. \n\n- The package statement defines a name space in which classes are stored. If you omit the package statement, the class names are put into the default package, which has no name. (This is why you haven’t had to worry about packages before now.) While the default package is fine for short, sample programs, it is inadequate for real applications. Most of the time, you will define a package for your code.'),
            InterviewQuestionResponse(id: 3, topicId: 10, subjectId: 3, question: 'Access modifiers', answer: '- Access modifiers in java are used to control the visibility of a field, method, class and constructor. \n\nPrivate \n- Private members of a class whether it is a field or method or constructor can not be accessed outside the class.\n\nInheritance of Private Members - Private members will not be inherited to sub class. \n\n Important Note \n 1) Class can not be a private except inner classes. Inner classes are nothing but again members of outer class. So members of a class (field, method, constructor and inner class) can be private but not the class itself. \n 2) We can’t create sub classes to that class which has only private constructors. \n\nDefault or Package or No-Access Modifiers \nUsage of Default members \nDefault members or members with No-Access modifiers are accessed or visible within the package only. It applies to outer classes also. \nInheritance of Default Members - Default members can be inherited to sub classes within package. \n\nProtected \n- Usage of Protected Member - Protected member can be used within the package only. \n- Inheritance of Protected Member - Protected Member can be inherited to any sub classes. \n\nImportant Note \n1) Outer class can not be protected. \n2) We can create sub classes to a class which has only protected constructors but we can’t create objects to that class outside the package. \n\nPublic \n- Usage of Public members - Public members can be used anywhere. \n- Inheritance of Public Members - Public members can be inherited to any sub class.'),

            InterviewQuestionResponse(id: 1, topicId: 11, subjectId: 3, question: 'Inheritance', answer: 'Inheritance in Java is a mechanism in which one object acquires all the properties and behaviors of a parent object. It is an important part of OOPs (Object Oriented programming system). \n\nThe idea behind inheritance in Java is that you can create new classes that are built upon existing classes. When you inherit from an existing class, you can reuse methods and fields of the parent class. Moreover, you can add new methods and fields in your current class also. \n\nInheritance represents the IS-A relationship which is also known as a parent-child relationship.'),
            InterviewQuestionResponse(id: 2, topicId: 11, subjectId: 3, question: 'Why use inheritance in java', answer: '- For Method Overriding (so runtime polymorphism can be achieved). \n- For Code Reusability.'),
            InterviewQuestionResponse(id: 3, topicId: 11, subjectId: 3, question: 'Sub Class/Child Class', answer: 'Subclass is a class which inherits the other class. It is also called a derived class, extended class, or child class.'),
            InterviewQuestionResponse(id: 4, topicId: 11, subjectId: 3, question: 'Super Class/Parent Class', answer: 'Superclass is the class from where a subclass inherits the features. It is also called a base class or a parent class.'),
            InterviewQuestionResponse(id: 5, topicId: 11, subjectId: 3, question: 'Types of inheritance in java', answer: '1) single inheritance \n- In this type of inheritance there is a single derived class which inherits from a single base class. \n\n2) Multi-level Inheritance \n- In this type of inheritance there are several classes in the hierarchy forming multiple levels. Each level contains a base class and a derived class. \n\n3) Multiple Inheritance \n- In this type of inheritance a single derived class can inherit from two or more base classes.  \n\n4) Hierarchical Inheritance \n- In this type of inheritance, two or more derived classes inherit from a common base class. A is the base class and B, C and D are derived classes. \n\n5) Hybrid Inheritance \n- As the name itself implies, hybrid inheritance is a combination of any two or more of the above mentioned four types of inheritance.'),
            InterviewQuestionResponse(id: 6, topicId: 11, subjectId: 3, question: 'What types of inheritance does Java support?', answer: '- Java supports all types of inheritance mentioned above except multiple inheritance. Java doesn’t allow multiple inheritance in case of classes but it allows multiple inheritance in case of interfaces. \n-  For example, consider that a derived class C inherits from classes A and B (multiple inheritance). Suppose there are is a variable by the name X in both classes A and B. Now, if I access X in class C (which is valid due to inheritance) where does X value come from. Does it come from A or B?'),
            InterviewQuestionResponse(id: 7, topicId: 11, subjectId: 3, question: 'What is diamond problem of multiple inheritance?', answer: '- Consider the below diagram which shows multiple inheritance as Class D extends both Class B & C. \n- Now let’s assume we have a method in class A and class B & C overrides that method in their own way. Wait!! here the problem comes  \n- Because D is extending both B & C so if D wants to use the same method which method would be called (the overridden method of B or the overridden method of C). Ambiguity. That’s the main reason why Java doesn’t support multiple inheritance.'),
            InterviewQuestionResponse(id: 8, topicId: 11, subjectId: 3, question: 'Hierarchical inheritance and Hybrid inheritance are different?', answer: '- Yes, Hierarchical inheritance is different than hybrid inheritance. \n- Hierarchical inheritance is possible to have in java even using the classes alone itself as in this type of inheritance two or more classes have the same parent class or in other words a single parent class has two or more child classes, which is quite possible to have in java.'),
            InterviewQuestionResponse(id: 9, topicId: 11, subjectId: 3, question: 'Disadvantages of inheritance', answer: '- Both classes (super and subclasses) are tightly-coupled. \n- As they are tightly coupled (binded each other strongly with extends keyword), they cannot work independently of each other. \n- Changing the code in super class method also affects the subclass functionality. \n- If super class method is deleted, the code may not work as subclass may call the super class method with super keyword. Now subclass method behaves independently.'),
            InterviewQuestionResponse(id: 10, topicId: 11, subjectId: 3, question: 'Member access and inheritance', answer: 'A subclass includes all the members of its super class but it cannot access those members of the super class that have been declared as private.'),
            InterviewQuestionResponse(id: 11, topicId: 11, subjectId: 3, question: 'Method overriding', answer: '- When a method in a subclass same name and same type signature as a method in super class then this method is called overridden method and this process is called method overriding. \n- In a class hierarchy, when a method in a subclass has the same name and type, then the method in the subclass is said to override the method in the super class. When an overridden method is called from within a subclass, it will always refer to the version of that method defined by the sub class. \n- The version of the defined by the super class will be hidden. \n- Having the same method in the subclass as declared in the parent class is known as method overriding. If a sub class provides a specific implementation of a method that is already provided by its super class, it is known as Method Overriding. \n- Method overriding occurs when sub class declares a method that has the same type arguments as a method declared by one of its super class. The key benefit of overriding is the ability to define behavior that’s specific to a particular subclass type. \n- Whenever same method name is existing in both base class and derived class with same types of parameters or same order of parameters is known as method overriding. \n- Without Inheritance method overriding is not possible.'),
            InterviewQuestionResponse(id: 12, topicId: 11, subjectId: 3, question: 'Method overriding note', answer: '- The overriding method cannot have a more restrictive access modifier than the method being overridden (Example: You can’t override a method marked public and make it protected). \n- You cannot override a method marked final. \n- You cannot override a method marked static.'),
            InterviewQuestionResponse(id: 13, topicId: 11, subjectId: 3, question: 'Advantage of method overriding', answer: '- Method Overriding is used to provide specific implementation of a method that is already provided by its super class. \n- Method Overriding is used for Runtime Polymorphism.'),
            InterviewQuestionResponse(id: 14, topicId: 11, subjectId: 3, question: 'Rules for method overriding', answer: '- Method must have same name as in the parent class. \n- Method must have same parameter as in the parent class. \n- Must be IS - A relationship (inheritance). \n- The argument list should be exactly the same as that of the overridden method. \n- The return type should be the same or a subtype of the return type declared in the original overridden method in the super class. \n- The access level cannot be more restrictive than the overridden method of access level. For example: if the super class method is declared public then the overriding method in the sub class cannot be either private or public. However the access level can be less restrictive than the overridden method of access level. \n- Instance methods can be overridden only if they are inherited by the subclass. \n- A method declared final cannot be overridden. \n- A method declared static cannot be overridden but can be re - declared. \n- If a method cannot be inherited then it cannot be overridden. \n- A subclass within the same package as the instance of superclass can override any superclass method that is not declared private or final. \n- A subclass in a different package can only override the non - final methods declared public or protected. \n- An overriding method can throw any uncheck exceptions, regardless of whether the overridden method throws exceptions or not. However the overriding method should not throw checked exceptions that are new or broader than the ones declared by the overridden method. The overriding method can throw narrower or fewer exceptions than the overridden method. \n- Constructors cannot be overridden.'),
            InterviewQuestionResponse(id: 15, topicId: 11, subjectId: 3, question: 'How to prevent a method from being overridden?', answer: 'By specifying final keyword to the method you can avoid overriding in a subcalss. Similarlly one can use final at class level to prevent creating subclasses.'),

            InterviewQuestionResponse(id: 1, topicId: 12, subjectId: 3, question: 'What is abstract class?', answer: 'A class which is declared as abstract is known as an abstract class. It can have abstract and non-abstract methods. It needs to be extended and its method implemented. It cannot be instantiated. \n\n- abstract class must be declared with an abstract keyword. \n- It can have abstract and non-abstract methods. \n- It cannot be instantiated. \n- It can have constructors and static methods also. \n- It can have final methods which will force the subclass not to change the body of the method.'),
            InterviewQuestionResponse(id: 2, topicId: 12, subjectId: 3, question: 'Abstract method', answer: 'A method which is declared as abstract and does not have implementation is known as an abstract method. \nabstract void printStatus();'),
            InterviewQuestionResponse(id: 3, topicId: 12, subjectId: 3, question: 'Abstraction Advantage', answer: '- By using abstraction, we can separate the things that can be grouped to another type. \n- Frequently changing properties and methods can be grouped to a separate type so that the main type need not undergo changes. This adds strength to the OOAD principle -"Code should be open for Extension but closed for Modification".'),
            InterviewQuestionResponse(id: 4, topicId: 12, subjectId: 3, question: 'Abstract class Use', answer: '- Java Abstract classes are used to declare common characteristics of subclasses. \n- A method with method body is called concrete method. In general any class will have all concrete methods.  \n- A method without method body is called abstract method. \n- A class that contains abstract method is called abstract class. \n- It is possible to implement the abstract methods differently in the subclasses of an abstract class. These different implementations will help the programmer to perform different tasks depending on the need of the sub classes. Moreover, the common members of the abstract class are also shared by the sub classes. \n- The abstract methods and abstract class should be declared using the keyword abstract. We cannot create objects to abstract class because it is having incomplete code. Whenever an abstract class is created, subclass should be created to it and the abstract methods should be implemented in the subclasses, then we can create objects to the subclasses.'),
            InterviewQuestionResponse(id: 5, topicId: 12, subjectId: 3, question: 'Abstract class and method rules', answer: '- Java Abstract classes are used to declare common characteristics of subclasses. \n- A method with method body is called concrete method. In general any class will have all concrete methods. \n- A method without method body is called abstract method. \n- A class that contains abstract method is called abstract class. \n- It is possible to implement the abstract methods differently in the subclasses of an abstract class. These different implementations will help the programmer to perform different tasks depending on the need of the sub classes. Moreover, the common members of the abstract class are also shared by the sub classes. \n- The abstract methods and abstract class should be declared using the keyword abstract. We cannot create objects to abstract class because it is having incomplete code. Whenever an abstract class is created, subclass should be created to it and the abstract methods should be implemented in the subclasses, then we can create objects to the subclasses. \n\n Abstract class and method rules\n- Variable cannot be made abstract, its only behavior or methods which would be abstract. \n-  If a class extends an abstract class or interface it has to provide implementation to all its abstract method to be a concrete class. Alternatively this class can also be abstract. \n- An abstract class may also have concrete (complete) methods. \n- For design purpose, a class can be declared abstract even if it does not contain any abstract methods \n- Reference of an abstract class can point to objects of its sub-classes thereby achieving run-time polymorphism Ex: Shape obj = new Rectangle(); \n- A class must be compulsorily labeled abstract, if it has one or more abstract methods. \n- A class that is declared as abstract is known as abstract class. \n- Abstract class is a class which contains one or more abstract methods, which has to be implemented by sub classes. \n- An abstract class can contain no abstract methods also i.e. abstract class may contain concrete methods. \n- Abstract methods must be declared using abstract key word and class must be declared using abstract key word. \n- The abstract method must be in abstract class. \n- The abstract methods do not have body (No Implement). \n- Abstract class definition begins with the keyword “abstract” keyword followed by Class definition. \n- Abstract classes are useful in a situation when some general methods should be implemented and specialization behavior should be implemented by subclasses. \n- Abstract class can contain private as well as protected members. \n- A class extending an abstract class need not implement any of the methods defined in the abstract class. (The bodies of these methods are omitted.) \n- The abstract class must be extended by at least one subclass. \n- The subclass of abstract class must override all abstract methods of super class or it must be declared as abstract class. \n- All the abstract methods must be overridden. \n- Abstract class cannot be instantiated; they must be sub classed, and actual implementations must be provided for the abstract methods. \n- An abstract class is a class in which one or more methods are declared, but not defined. \n- You can only go back one level. \n- In the constructor, if you use super(), it must be the very first code, and you cannot access any this.xxx variables or methods to compute its parameters. \n- Any child class must either override the abstract method or declare itself abstract. \n- An abstract class is a class with zero or more abstract methods \n- An abstract class contains instance variables & concrete methods in addition to abstract methods. \n- It is not possible to create objects to abstract class. But we can create a reference of abstract class type. \n- All the abstract methods of the abstract class should be implemented in its sub classes. \n- If any method is not implemented, then that sub class should be declared as ‘abstract’. \n- Abstract class reference can be used to refer to the objects of its sub classes. \n- Abstract class references cannot refer to the individual methods of sub classes. \n- A class cannot be both abstract & final. \n- It cannot be instantiate means we cannot create object of an abstract class. \n- An abstract class can have instance member.\n- Abstract class does not have any method implementation instead can have only method declaration. \n- We cannot make an inner class as abstract.\n- We cannot use static method but can use static variable in the abstract class. \n- Extending abstract class means we need to override the abstract methods defined in the abstract class. \n- If we do not want to override abstract in its sub-class then declare that sub-class as abstract. \n- An abstract class may or may not have an abstract method. \n- Constructor of the abstract class will be used to instantiate the abstract class instance variable. \n- Overridden abstract class methods will be accessed by its sub-class object. \n- We can be able to create and reference variable for an abstract class.'),
            InterviewQuestionResponse(id: 6, topicId: 12, subjectId: 3, question: 'Can we create abstract classes without any abstract methods?', answer: 'Yes, we can create abstract classes without any abstract methods.'),

            InterviewQuestionResponse(id: 1, topicId: 13, subjectId: 3, question: 'What is interface?', answer: 'An interface is a collection of method prototypes (method name followed by parameters list without any body).'),
            InterviewQuestionResponse(id: 2, topicId: 13, subjectId: 3, question: 'Nested Interfaces', answer: 'An interface which is declared inside a class or another interface is called a nested interface or a member interface. A nested interface can be declared as public, private or protected.'),
            InterviewQuestionResponse(id: 3, topicId: 13, subjectId: 3, question: 'What is marker interface in java and why required?', answer: '- Marker interface in java is interface with no member variable or methods or in simple word empty interface called marker interface in Java, also known as tagging interface. E.g.  Serializable, Clonnable. \n\n- Marker interface used to indicate something to compiler or JVM. So if JVM sees a Class is Serializable it done some special operation on it, similar way if JVM sees one Class is implement Clonnable it performs some operation to support cloning.'),
            InterviewQuestionResponse(id: 4, topicId: 13, subjectId: 3, question: 'Partial implementation', answer: 'If a class includes an interface but does not fully implement the method defined by that interface, then that class must be declared as abstract.'),
            InterviewQuestionResponse(id: 5, topicId: 13, subjectId: 3, question: 'Extending interface', answer: '- An interface can extends another interface like the way to the class extends another class using extends keyword. The child interface inheritance the method and member variable of parent interface. \n\n- One interface can inherit another by use of the keyword extends. The syntax is the same as for inheriting classes. \n\n- When a class implements an interface that inherits another interface, it must provide implementations for all methods defined within the interface inheritance. \n\n- Any class that implements an interface a must implement all methods defined by that interface, including any that are inherited form other interfaces.'),
            InterviewQuestionResponse(id: 6, topicId: 13, subjectId: 3, question: 'What if a class extends 2 interfaces having same abstract method?', answer: 'Since the implementation of abstract method is provided by the class which implements the interfaces, there is no ambiguity even if two interfaces declares same abstract method.'),
            InterviewQuestionResponse(id: 7, topicId: 13, subjectId: 3, question: 'Multiple inheritance by interface', answer: 'A class cannot extend two classes but it can implement two interfaces.'),
            InterviewQuestionResponse(id: 8, topicId: 13, subjectId: 3, question: 'What is marker or tagged interface?', answer: 'An interface that have no member is known as marker or tagged interface. For example: Serializable, Cloneable, Remote etc. They are used to provide some essential information to the JVM so that JVM may perform some useful operation.'),
            InterviewQuestionResponse(id: 9, topicId: 13, subjectId: 3, question: 'Dynamic method dispatch or virtual method invocation.', answer: 'When one interface is implemented by two or more classes, method calling using interface reference depends on the reference pointing to which object at the runtime. This is called dynamic method dispatch.'),
            InterviewQuestionResponse(id: 10, topicId: 13, subjectId: 3, question: 'Can we have static methods in interface?', answer: 'new feature called "default methods".'),

            InterviewQuestionResponse(id: 1, topicId: 14, subjectId: 3, question: 'Exception', answer: '- Dictionary Meaning: Exception is an abnormal condition. \n- In java, exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime.'),
            InterviewQuestionResponse(id: 2, topicId: 14, subjectId: 3, question: 'List out some of the source of errors in programming.', answer: '- Errors are classified into two types \n1) Compilation time errors \n2) Run time errors \n\ncompilation time errors \n- Missing semicolons \n- Miss match brackets in classes and methods \n- Misspelling of identifiers and keywords \n- Undeclared variables \n\n Run time Errors \n- Dividing on integer by zero \n- Out of the bounds of an array \n- Trying to store a value into an array of incompatible class or type'),
            InterviewQuestionResponse(id: 3, topicId: 14, subjectId: 3, question: 'synchronized', answer: '- In multithreading programming, different threads access different methods of the class and execute it simultaneously. \n\n- If you want to put a watch to make sure that one method can be accessed by only one thread until execution of the method finish. \n\n- This can be achieved by the process called synchronization. This synchronization can be achieved with use of synchronized modifier.'),
            InterviewQuestionResponse(id: 4, topicId: 14, subjectId: 3, question: 'finalize method', answer: '- finalize() method is used to garbage collection. \n\n- Java finalize methods provide a mechanism for performing resource management operations, and so are superficially similar to C++ destructor methods. \n\n- A method that is invoked before an object is discarded by the garbage collector, allowing it to clean up its state. \n\n- Should not be used to release non-memory resources like file handles, sockets, database connections etc because Java has only a finite number of these resources and you do not know when the garbage collection is going to kick in to release these non-memory resources through the finalize() method. \n\n- This similarity is due to the fact that both C++ destructors and Java finalize methods are invoked as part of the process of de - allocating memory. \n\n- Java, however, does not require explicit de - allocation of objects. \n\n- Rather, it uses an independent garbage collection thread which is responsible for finding objects which are candidates for garbage collection, invoking their finalize methods and de - allocating their memory. \n\n- In effect, the invocation of a Java finalize method is asynchronous to the execution of the user code. \n\n- The strongest statement that can be made about the timing of finalize method invocations is that, at some stage after an object becomes a candidate for garbage collection, and prior to it being collected, the finalize method will be invoked. \n\n- This unpredictable invocation time and order, means that the authors of finalize methods must take great care to ensure correct program behavior. \n\n- The finalize method has this general form: protected void finalize() { //finalization code here }'),
            InterviewQuestionResponse(id: 5, topicId: 14, subjectId: 3, question: 'Throw', answer: '- We saw that an exception was generated by the JVM when certain run - time problems occurred. \n\n- It is also possible for our program to explicitly generate an exception. This can be done with a throw statement. Its form is as follows: throw object; \n\n- Here, object must be of type java.lang.Throwable. Otherwise, a compiler error occurs. \n\n- Inside a catch block, you may throw the same exception object that was provided as an argument. This can be done with the following syntax: catch(ExceptionType param) { throw param; } \n\n- Alternatively, you may create and throw a new exception object as follows: throw new ExceptionType(args); \n\n- Here, exception Type is the type of the exception object and args is the optional argument list for its constructor. \n\n- When a throw statement is encountered, a search for a matching catch block begins. Any subsequent statements in the same try or catch block are not executed.'),
            InterviewQuestionResponse(id: 6, topicId: 14, subjectId: 3, question: 'Throws', answer: '\n- If a method s capable of causing an exception that it does not handle, it must specify this behavior so that callers of the method can guard themselves against that exception. \n\n- You do this by including a throws clause in the method of declaration. \n\n- A throw clause lists the type of exceptions that a method might throw. This is necessary for all exceptions, except those of type Error or RuntimeException, or any of their subclasses. \n\n- All other exceptions that a method can throw must be declared in the throws clause. \n\n- This is general form of a method declaration that includes a throws clause: type method - name(parameter - list) throws exception - list { //body of method }'),
            InterviewQuestionResponse(id: 7, topicId: 14, subjectId: 3, question: 'Give the list of Java Object class methods.', answer: 'clone() - Creates and returns a copy of this object. \n\nequals() - Indicates whether some other object is "equal to" this one. \n\nfinalize() - Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. \n\ngetClass() - Returns the runtime class of an object. \n\nhashCode() - Returns a hash code value for the object. \n\nnotify() - Wakes up a single thread that is waiting on this object of monitor. \n\nnotifyAll() - Wakes up all threads that are waiting on this object of monitor. \n\ntoString() - Returns a string representation of the object. \n\nwait() - Causes current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.'),
            InterviewQuestionResponse(id: 8, topicId: 14, subjectId: 3, question: 'Nested try statements', answer: '- The try statement can be nested. That is, try statements can be inside the block of another try. \n\n- Each time a try statement is entered, the content of that exception is pushed on the stack. \n\n- If an inner try statement does not have a catch handler for a particular exception, the stack is unwound and the next try statement catch handlers are inspected for a match. \n\n- This continues until one of the catch statements succeeds, or until one of the nested try statements are exhausted. \n\n- If no catch statement matches, then the java run - time system will handle the exception.'),
            InterviewQuestionResponse(id: 9, topicId: 14, subjectId: 3, question: 'Types of exception', answer: 'Exceptions in java are of two kinds, checked, unchecked and error. \n1) Unchecked exceptions \n- The classes that extend RuntimeException are known as unchecked exceptions e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc. \n- Unchecked exceptions are not checked at compile-time rather they are checked at runtime. \n- Exceptions that are automatically available and need not be included in any method’s throws list are known as unchecked exception. \n- Unchecked exception is a type of exception for that you have option that handler it, or ignore it. \n- If you elect to ignore the possibility of an unchecked exception, then, as a result of that your program will terminate. \n- If you elect to handle unchecked exceptions that occur then the result will depend on the code that you have written to handle the exception. \n- Exceptions instantiated from RuntimeException and its subclasses are considered as unchecked exceptions. \n\n2) Unchecked exceptions \n- The classes that extend RuntimeException are known as unchecked exceptions e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc. \n- Unchecked exceptions are not checked at compile-time rather they are checked at runtime. \n- Exceptions that are automatically available and need not be included in any method’s throws list are known as unchecked exception. \n- Unchecked exception is a type of exception for that you have option that handler it, or ignore it. \n- If you elect to ignore the possibility of an unchecked exception, then, as a result of that your program will terminate. \n- If you elect to handle unchecked exceptions that occur then the result will depend on the code that you have written to handle the exception. \n- Exceptions instantiated from RuntimeException and its subclasses are considered as unchecked exceptions. \n\n3) RuntimeException \n- Exceptions of this are automatically defined for the programs that you write and include things such as division by zero and invalid array indexing. \n\n4) Error \n- Error is irrecoverable e.g. OutOfMemoryError, VirtualMachineError, AssertionError etc. \n- It defines exceptions that are not expected to be caught under the normal circumstances by your program. \n- Example: Memory leak, LinkageError etc.'),
            InterviewQuestionResponse(id: 10, topicId: 14, subjectId: 3, question: 'Create your own exception', answer: '- Although java of built - in exceptions handle most common errors, you will probably want to create your own exception types to handle situations specific to your applications. \n\n- This is quite easy to do: Just define a subclass of Exception (which is, of course, a subclass of Throwable). Your sub classes do not need to actually implement anything - it is their existence in the type system that allows you to use them as exceptions. \n\n- The Exception class does not define any methods of its own. It does, of course, inherit those methods provided by Throwable. Thus, all exceptions, including those that you create, have the methods defined by Throwable available to them.'),
            InterviewQuestionResponse(id: 11, topicId: 14, subjectId: 3, question: 'Native', answer: '- access modifier \n- Native applies to only to methods. \n- Native can be applied to static methods also.\n- Native methods cannot be abstract. \n- Native methods can throw exceptions. \n- Native method is like an abstract method. The implementation of the abstract class and native method exist somewhere else, other than the class in which the method is declared. \n- Java supports native methods. \n- Native methods are those methods which are written in some another language like C or C++. \n- Native keyword is used to declare a method as native. \n- A simple statement to call a native methods is: \n\npublic native returnType methodName();'),
            InterviewQuestionResponse(id: 12, topicId: 14, subjectId: 3, question: 'Volatile', answer: '- If a variable is modified by volatile keyword, it can be changed unexpectedly by other parts of program such as threads.  \n- For example in multithreading, there may be more than one threads which share a same instance variable, then this variable can be modified as volatile. \n- The more about multithreading is in the chapter multithreading. \n- Volatile: access modifier \n- Volatile applies to only variables. \n- Volatile can applied to static variables. \n- Volatile cannot be applied to final variables. \n- Transient and volatile cannot come together. \n- Volatile is used in multi-processor environments.'),
            InterviewQuestionResponse(id: 13, topicId: 14, subjectId: 3, question: 'Transient', answer: '- access modifier \n- Transient can be applied only to class level variables. \n- Local variables can’t be declared as transient. \n- During serialization, Object’s transient variables are not serialized. \n- Transient variables may not be final or static. But the complies allows the declaration and no compile time error is generated. \n- When an instance variable is specified as transient, then java runtime system will not write its content to the persistent storage area, when the object will be saved. \n- If you do not want some field to be serialized, you can mark that field transient or static. \n\n- For example if a variable is declared as transient in a Serializable class and the class is written to an ObjectStream, the value of the variable can not be written to the stream instead when the class is retrieved from the ObjectStream the value of the variable becomes null.'),
            InterviewQuestionResponse(id: 14, topicId: 14, subjectId: 3, question: 'What is final, finally and finalize?', answer: 'final: final is a keyword. The variable decleared as final should be initialized only once and cannot be changed. Java classes declared as final cannot be extended. Methods declared as final cannot be overridden. \n\nfinally: finally is a block. The finally block always executes when the try block exits. This ensures that the finally block is executed even if an unexpected exception occurs. But finally is useful for more than just exception handling - it allows the programmer to avoid having cleanup code accidentally bypassed by a return, continue, or break. Putting cleanup code in a finally block is always a good practice, even when no exceptions are anticipated. \n\nfinalize: finalize is a method. Before an object is garbage collected, the runtime system calls its finalize() method. You can write system resources release code in finalize() method before getting garbage collected.'),

            InterviewQuestionResponse(id: 1, topicId: 15, subjectId: 3, question: 'I/O', answer: '- Input is any information that is needed by your program to complete its execution and Output is information that the program must produce after its execution. \n\n- Often a program needs to bring information from an external source or to send out information to an external destination. \n\n- The information can be anywhere in file. On disk, somewhere on network, in memory or in other programs. Also the information can be of any type, i.e., object, characters, images or sounds. In Java information can be stored, and retrieved using a communication system called streams, which are implemented in Java.io package.'),
            InterviewQuestionResponse(id: 2, topicId: 15, subjectId: 3, question: 'The character stream classes', answer: '- Character streams are used to work with any text files that are represented by ASCII characters set or Unicode set. \n\n- Reading and writing file involves interacting with peripheral devices like keyboard printer that are part of system environment. \n\n- As you know such interactions are relatively slow compared to the speed at which CPU can operate. \n\n- For this reason Buffered reader and Buffered Writer classes are used to overcome from difficulties posed by speed mismatch. \n\n- Character streams are defined by using two class hierarchies. \n\n- At the top are two abstract classes, Reader and Writer. \n\n- These abstract classes handle Unicode character streams. Java has several concrete subclasses of each of these. \n\n- The abstract classes Reader and Writer define several key methods that the other stream classes implement. Two of the most important methods are read() and write(), which read and write characters of data. \n\n- These methods are overridden by derived stream classes.'),
            InterviewQuestionResponse(id: 3, topicId: 15, subjectId: 3, question: 'I/O stream classes', answer: '- I/O classes are used to get input from any source of data or to send output to any destination. \n\n- The source and destination of input and output can be file or even memory. \n\n- In Java input and output is defined in terms of an abstract concept called stream. \n\n- A Stream is a sequence of data. \n\n- If it is an input stream it has a source. \n\n- If it is an output stream it has a destination. There are two kinds of streams: byte stream and character stream. \n\n- The java.io package provides a large number of classes to perform stream IO.'),
            InterviewQuestionResponse(id: 4, topicId: 15, subjectId: 3, question: 'Java I/O classes and interfaces', answer: '- The package java.io provides two sets of class hierarchies-one for reading and writing of bytes, and the other for reading and writing of characters. \n\n- The InputStream and OutputStream class hierarchies are for reading and writing bytes. \n\n- Java provides class hierarchies derived from Reader and Writer classes for reading and writing characters. \n\n- Java programs use 16 bit Unicode character encoding to represent characters internally. \n\n- Other platforms may use a different character set (for example ASCII) to represent characters. \n\n- The reader classes support conversions of Unicode characters to internal character storage.'),
            InterviewQuestionResponse(id: 5, topicId: 15, subjectId: 3, question: 'Input and Output(I/O)', answer: 'I/O is used to process the input and produce the output based on the input. Java uses the concept of stream to make I/O operations fast. java.io package contains all the classes required for input and output operations.'),
            InterviewQuestionResponse(id: 6, topicId: 15, subjectId: 3, question: 'Stream', answer: '- A stream is a sequence of data. In Java a stream is composed of bytes. It is called a stream because it is like a stream of water that continues to flow. \n\nThree streams are created for us automatically \nSystem.out: standard output stream \nSystem.in: standard input stream \nSystem.err: standard error \n\n1) OutputStream \n- The OutputStream defines methods for writing bytes or arrays of bytes to the stream. \n\n- An output stream is automatically opened when created. An Output stream can be explicitly closed with the close() method. \n\n- Java application uses an output stream to write data to a destination, it may be a file, an array, peripheral device or socket. \n\n- OutputStream class is an abstract class. It is the super class of all classes representing an output stream of bytes. \n\n- An output stream accepts output bytes and sends them to some sink. \n\n- ByteArrayOutputStream provides some additional methods not declared for OutputStream. The reset() method resets the output buffer to allow writing to restart at the beginning of the buffer. The size() method returns the number of bytes that have been written to the buffer. \n\n2) InputStream \n- The InputStream class defines methods for reading bytes or arrays of bytes, marking locations in the stream, skipping bytes of input, finding out the number of bytes available for reading, and resetting the current position within the stream. \n\n- An input stream is automatically opened when created. \n\n- The close() method can explicitly close a stream. \n\n- Java application uses an input stream to read data from a source, it may be a file, an array, peripheral device or socket. \n\n- InputStream class is an abstract class. It is the super class of all classes representing an input stream of bytes.'),
            InterviewQuestionResponse(id: 7, topicId: 15, subjectId: 3, question: 'Byte Stream ', answer: '- Byte streams carry integers with values that range from0 to 255. A diversified data can be expressed in byte format, including numerical data, executable programs, and byte codes – the class file that runs a Java program. \n\n- Byte streams are defined by using two class hierarchies. \n\n- At the top are two abstract classes: InputStream and OutputStream. \n\n- Each of these abstract classes has several concrete subclasses that handle the differences between various devices, such as disk files, network connections, and even memory buffers. \n\n- The stream classes, you must import java.io. \n\n- The abstract classes InputStream and OutputStream define several key methods that the other stream classes implement. \n\n- Two of the most important are read( ) and write( ), which, respectively, read and write bytes of data. \n\n- Both methods are declared as abstract inside InputStream and OutputStream. \n\n- Character Streams are specialized type of byte streams that can handle only textual data.'),
            InterviewQuestionResponse(id: 8, topicId: 15, subjectId: 3, question: 'Predefined Streams', answer: '- All Java programs automatically import the java.lang package. \n\n- This package defines a class called System, which encapsulates several aspects of the run-time environment. \n\n- System also contains three predefined stream variables: in, out, and err. \n\n- These fields are declared as public, static, and final within System. \n\n- This means that they can be used by any other part of your program and without reference to a specific System object. \n\n- System.out refers to the standard output stream. By default, this is the console. \n\n- System.in refers to standard input, which is the keyboard by default System. \n\n- err refers to the standard error stream, which also is the console by default. However, these streams may be redirected to any compatible I/O device. \n\n- System.in is an object of type InputStream; \n\n- System.out and System.err are objects of type PrintStream. \n\n- These are byte streams, even though they typically are used to read and write characters from and to the console.'),
            InterviewQuestionResponse(id: 9, topicId: 15, subjectId: 3, question: 'BufferedWriter', answer: '- The BufferedWriter class is a subclass of Writer. It defines the abstract method flush() of the writer class. \n\n- A BufferedWriter is a Writer that buffers output. Using a BufferedWriter can increase performance by reducing the number of times data is actually physically written to the output stream. \n\nConstructors \n1) BufferedWriter(WriteroutputStream) \n2) BufferedWriter(WriteroutputStream, int bufSize) \n\n- The first form creates a buffered stream using a buffer with a default size. In the second, the size of the buffer is passed in bufSize.'),
            InterviewQuestionResponse(id: 10, topicId: 15, subjectId: 3, question: 'BufferedReader', answer: '- BufferedReader improves performance by buffering input. \n\nConstructors \n1) BufferedReader(ReaderinputStream) \n2) BufferedReader(ReaderinputStream, int bufSize) \n\n- The first form creates a buffered character stream using a default buffer size. \n\n- In the second, the size of the buffer is passed in bufSize. \n\n- The BufferedReader class adds a method readLine() which reads a line of characters from the keyboard. The reading of data is terminated when new line is encountered. \n\nSyntax: String readLine() throws IOException'),
            InterviewQuestionResponse(id: 11, topicId: 15, subjectId: 3, question: 'CharArrayReader', answer: '- CharArrayReader is an implementation of an input stream that uses a character array as the source. \nThis class has two constructors, each of which requires a character array to provide the data source: \n1) CharArrayReader(chararray[]) \n2) CharArrayReader(chararray[], int start, int numChars) \n\n- Here, array is the input source. The second constructor creates a Reader from a subset of your character array that begins with the character at the index specified by start and is num Chars long.'),
            InterviewQuestionResponse(id: 12, topicId: 15, subjectId: 3, question: 'CharArrayWriter', answer: '- The CharArrayWriter class can be used to write data to multiple files. This class implements the Appendable interface. \n\n- Its buffer automatically grows when data is written in this stream. \n\n- Calling the close() method on this object has no effect. \n\n- CharArrayWriter is an implementation of an output stream that uses an array as the destination. \n\nConstructors \n1) CharArrayWriter() \n2) CharArrayWriter(intn umChars) \n- In the first form, a buffer with a default size is created. In the second, a buffer is created with a size equal to that specified by num Chars. The buffer is held in the buf field of CharArrayWriter. \n\n- The buffer size will be increased automatically, if needed. The number of characters held by the buffer is contained in the count field of CharArrayWriter. Both buf and count are protected fields.'),
            InterviewQuestionResponse(id: 13, topicId: 15, subjectId: 3, question: 'PrintWriter', answer: '- The PrintWriter class is used to display values of simple data types. \n\n- It has method to print data such as print() and println(). In these method java calls toString() method to convert data type to a simple data type. \n\n- PrintWriter is essentially a character-oriented version of PrintStream. \n\n- It implements the Appendable, Closeable, and Flushable interfaces. \n\n- PrintWriter has several constructors. \n\n- The following have been supplied by PrintWriter from the start: \n1) PrintWriter(OutputStream outputStream) \n2) PrintWriter(OutputStreamoutputStream, boolean flushOnNewline) \n3) PrintWriter(Writer outputStream) \n4) PrintWriter(Writer outputStream, boolean flushOnNewline) \n\n- Buffers are automatically flushed when the program ends normally \n\n- Usually it is your responsibility to flush buffers if the program does not end normally \n\n- PrintWriter can do the flushing for you \n\npublic PrintWriter(OutputStream out, boolean autoFlush);'),
            InterviewQuestionResponse(id: 14, topicId: 15, subjectId: 3, question: 'ObjectOutput', answer: '- The ObjectOutput interface extends the DataOutput interface and supports object serialization. \n\n- Note especially the writeObject() method. \n\n-This is called to serialize an object. All of these methods will throw an IOException on error conditions. \n\n-They will throw an IOException on error conditions. \n\n-There is also an inner class to ObjectOuputStream called PutField.'),
            InterviewQuestionResponse(id: 15, topicId: 15, subjectId: 3, question: 'ObjectOutputStream', answer: '- The ObjectOutputStream class extends the OutputStream class and implements the ObjectOutput interface. \n\n- It is responsible for writing objects to a stream. \n\nConstructor \n1) ObjectOutputStream(OutputStreamoutStream) throws IOException \n\n- The argument outStream is the output stream to which serialized objects will be written.'),
            InterviewQuestionResponse(id: 16, topicId: 15, subjectId: 3, question: 'ObjectInput', answer: '- The ObjectInput interface extends the DataInput interface. \n\n- It supports object serialization. \n\n- Note especially the readObject( )method. This is called to deserialize an object.'),
            InterviewQuestionResponse(id: 17, topicId: 15, subjectId: 3, question: 'ObjectInputStream', answer: '- The ObjectInputStream class extends the InputStream class and implements the ObjectInput interface. \n\n- The ObjectInput interface extends the DataInput interface and adds some own methods. \n\n- ObjectInputStream is responsible for reading objects from a stream. \n\n- A constructor of this class is \n1) ObjectInputStream(InputStreaminStream) throws IOException \n\n- The argument in Stream is the input stream from which serialized objects should be read. \n\n- They will throw an IOException on error conditions. \n\n- The readObject( ) method can also throw ClassNotFoundException. \n\n- There is also an inner class to ObjectInputStream called GetField.'),
            InterviewQuestionResponse(id: 18, topicId: 15, subjectId: 3, question: 'Stream class', answer: '- A stream is a path or a medium along which the data flows. So the data passes through streams from source to destination. \n\n- The source is called the input and the destination is called the output of program. \n\n- java stream - bases I/O built upon four abstract classes \n\n- An input stream may be associated with the keyboard \n\n- An input stream or an output stream may be associated with a file \n\nDifferent streams have different characteristics: \n1) A file has a definite length, and therefore an end \n2) Keyboard input has no specific end \n\n- An object that either delivers data to its destination (screen, file, etc.) or that takes data from a source (keyboard, file, etc.) \n\n- It acts as a buffer between the data source and destination \n\n- java stream - bases I/O built upon four abstract classes \n1) Reader \n2) Writer \n3) InputStream \n4) OutputStream \n\n- They are used to create concrete stream subclasses. Although your programs perform their I/O operations through concrete subclasses, the top - level classes define the basic functionality common to all stream classes. \n\n- I/O is either text-based or data-based (binary). \n\n- InputStream or OutputStream are designed for byte streams \n\n- Reader or writer are designed for character streams. \n\n- The byte stream classes and the character stream classes form separate hierarchies. \n\n- In general, you should use the character stream classes when working with character or strings, and use the byte stream classes when working with bytes or other binary objects.'),
            InterviewQuestionResponse(id: 19, topicId: 15, subjectId: 3, question: 'Character Streams', answer: '- The character stream classes manipulate data character. A character in java is of 16 – bits. Thus the character stream classes can work with 16 – bit Unicode characters. \n\n- The main two classes of character stream are reader and writer.'),
            InterviewQuestionResponse(id: 20, topicId: 15, subjectId: 3, question: 'Byte Streams', answer: '- The java.io package supports two types of streams —binary streams, which contain binary data, and character streams, which contain character data. Binary streams are sometimes referred to as byte streams. A byte in a java is of 8 –bits. \n\n- The byte stream classes provide a rich environment for handling byte - oriented I/O. \n\n- A byte stream can be used with any type of object, including binary data. \n\n- This versatility makes byte streams important to many types of programs. \n\n- The byte stream classes are topped by InputStream and OutputStream. \n\nInput stream: \n\n- A stream that provides input to a program \n\n- System.in is an input stream \n\n- InputStream is an abstract class that defines java of model of streaming byte input. \n\n- All of the methods in this class will throw an IOException on error conditions. \n\nOutput stream \n\n- When you write data to a stream, the stream is called an output stream. \n\n- A stream that accepts output from a program : System.out is an output stream \n\n- A stream connects a program to an I/O object \n1) System.out connects a program to the screen \n2) System.in connects a program to the keyboard \n\n- OutputStream is an abstract class that defines streaming byte output. \n\n- All of the methods in this class return a void value and throw an IOException in the case of errors. Following table shows the methods in OutputStream.'),
            InterviewQuestionResponse(id: 21, topicId: 15, subjectId: 3, question: 'FileInputStream and FileOutputStream', answer: '- FileInputStream and FileOutputStream classes are used to read and write data in file. \n\n- It is used for reading streams of raw bytes such as image data. For reading streams of characters, consider using FileReader. \n\n- It should be used to read byte-oriented data. For example, to read image etc. \n\n1) FileInputStream \n\n- The FileInputStream class creates an InputStream that you can to read bytes from a file. \n\nIts two most common constructors are shown here. \n1) FileInputStream(String filepath) \n2) FileInputStream(File fileobj) \n\n- Either can throw a FileNotFoundException. Here, filepath is the full path name of a file, and fileobj is a File object that describes the file. \n\n- The following example creates two FileInputStreans that use the same disk file and each of two constructors: \nFileInputStream f0 = new FileInputStream("/autoexec.bat"); \nFile f = new File("/autoexec.bat");\nFileInputStream f1 = new FileInputStream(f); \n\n- Although the first constructor is probably more commonly used, the second allows us to closely examines the file using the File methods, before we attach it to an input stream. \n\n- When a FileInputStream is created, it is also opened for reading. \n\n- FileInputStream overrides six of the methods in the abstract class InputStream. The mark() and reset() methods are not overridden and attempt to use reset() on a FileInputStream will generate an IOException. \n\n2)FileOutputStream \n\n- FileOutputStream class is a subclass of the OutputStream class. \n\n- FileOutputStream creates an OutputStream that you can use to write bytes to a file. \n\n- If you have to write primitive values then use FileOutputStream. Instead, for character-oriented data, prefer FileWriter. But you can write byte-oriented as well as character-oriented data. \n\nIts most commonly used constructors are shown here: \n1) FileOutputStream(String filePath) \n2) FileOutputStream(File fileObj) \n3) FileOutputStream(String filePath, boolean append) \n4) FileOutputStream(File fileObj, boolean append)'),
            InterviewQuestionResponse(id: 22, topicId: 15, subjectId: 3, question: 'ByteArrayInputStream', answer: '- ByteArrayInputStream is an implementation of an input stream that uses a byte array as the source. \n\n- This class has two constructors, each of which requires a byte array to provide the data source: \n1) ByteArrayInputStream(byte array[]) \n2) ByteArrayInputStream(byte array[], int start, int numBytes) \n\n- Here, array is the input source. \n\n- The second constructor creates an InputStream from a subset of your byte array that begins with the character at the index specified by start and is numBytes long. \n\n- The input1 object contains the entire lowercase alphabet, while input1 contains only the first three letters. \n\n- A ByteArrayInputStream implements both mark() and reset(). However, if mark() has not been called, then reset() sets the stream pointer to the start of the stream—which in this case is the start of the byte array passed to the constructor.'),
            InterviewQuestionResponse(id: 23, topicId: 15, subjectId: 3, question: 'ByteArrayOutputStream', answer: '- ByteArrayOutputStream is an implementation of an output stream that uses a byte array as the destination. \n\n- In this stream, the data is written into a byte array. The buffer automatically grows as data is written to it. \n\n- Closing a ByteArrayOutputStream has no effect. \n\nConstructors \n1) ByteArrayOutputStream(): Creates a new byte array output stream with the initial capacity of 32bytes, though its size increases if necessary. \n2) ByteArrayOutputStream(int size): Creates a new byte array output stream, with a buffer capacity of the specified size, in bytes.'),
            InterviewQuestionResponse(id: 24, topicId: 15, subjectId: 3, question: 'PushbackReader', answer: '- The PushbackReader class allows one or more characters to be returned to the input stream. \n\nThis allows you to look ahead in the input stream. Here are its two constructors: \n1) PushbackReader(ReaderinputStream) \n2) PushbackReader(ReaderinputStream, int bufSize) \n\n- The first form creates a buffered stream that allows one character to be pushed back. \n\n- In the second, the size of the pushback buffer is passed in bufSize. \n\n- PushbackReader provides unread(), which returns one or more characters to the invoking input stream. It has the three forms shown here. \n1) void unread(int ch) \n2) void unread(char buffer[]) \n3) void unread(char buffer[], int offset, int numChars) \n\n- The first form pushes back the character passed inch. This will be the next character returned by a subsequent call toread(). The second form returns the characters in buffer. \n\n- The third form pushes back numCharscharacters beginning at offset from buffer. An IOException will be thrown if there is an attempt to return a character when the pushback buffer is full. \n\n- The following program reworks the earlier PushBackInputStream example by replacing. \n\n- PushBackInputStream with a PushbackReader.  As before, it shows how a programming language parser can use a pushback stream to deal with the difference between the == operator for comparison and the = operator for assignment.'),
            InterviewQuestionResponse(id: 25, topicId: 15, subjectId: 3, question: 'SequenceInputStream', answer: '- The SequenceInputStream class allows you to concatenate multiple InputStreams. \n\n- The construction of a Sequence InputStream is different from any other InputStream. \n\n- A Sequence InputStream constructor uses either a pair of InputStreams or an Enumeration of InputStreams as its argument: \n1) SequenceInputStream(InputStreamfirst, InputStreamsecond) \n2) SequenceInputStream(Enumeration <? extends InputStream>streamEnum) \n\n- Operationally, the class fulfills read requests from the first InputStream until it runs out and then switches over to the second one. In the case of an Enumeration, it will continue through all of the InputStreams until the end of the last one is reached. \n\nConstructors \n1) SequenceInputStream(InputStream s1, InputStream s2): Creates a new input stream by reading the data of two input stream in order, first s1 and then s2. \n2) SequenceInputStream(Enumeration e): Creates a new input stream by reading the data of an enumeration whose type is InputStream.'),
            InterviewQuestionResponse(id: 26, topicId: 15, subjectId: 3, question: 'FilterInputStream', answer: '- The FilterInputStream is a subclass of InputStream that offers some more functionality than other InputStream classes.\nConstructor \n1) FilterInputStream(InputStream obj) \n\n- The obj is the object of InputStream subclass. \n\n- The two subclasses of FilterInputStream are BufferedInputStream and DataInputStream.'),
            InterviewQuestionResponse(id: 27, topicId: 15, subjectId: 3, question: 'Buffered Stream', answer: '\nWhat is Buffer? \n\n- Buffer is a temporary storage place where the data can be kept before it is needed by the program that reads or writes data. By using buffer, you can get data without always going back to the original source of data. \n\n- In JAVA, these Buffers allow you to do input/output operations on more than a byte at a time. \n\n- It increases the performance, and we can easily manipulate, skip, mark or reset the stream of byte also. \n\n- Buffered Stream classes manipulate sequenced streams of byte data, typically associated with binary format files.\n\n- For example, binary image file is not intended to be processed as text and so conversion would be appropriate when such a file is read for display in a program. \n\n- There are two classes for bufferstream BufferInputStream and BufferedOutputStream. \n\n1)BufferedInputStream \n- The BufferedInputStream is a subclass FilterInputStream and is used to read bytes from input stream using buffer. \n- As stated earlier, use of buffer increases the performance of input and output. \nConstructor \n1) BufferedInputStream (InputStream obj) : The obj is an object of InputStream subclass. The default biffer size is used. \n2) BufferedInputStream (InputStream obj, int bufferSize) : The buffer size can be specified by buffersize. \n\n2) BufferedOutputStream \n- The BufferedOutputStream class is a subclass of FilterOutputStream and is used to output bytes to a file using buffer. \n- As we know, the use of buffer increases the performance of reading and writing data. \n\nConstructor \n1) BufferedOutputStream (OutputStream obj) : The obj is an object of a subclass of OutputStream. The default buffer size is used. \n2) BufferedOutputStream (OutputStream obj, int bufferSize) : The size of buffer is specified by the buffersize parameter.'),
            InterviewQuestionResponse(id: 28, topicId: 15, subjectId: 3, question: 'DataInputStream', answer: '\n- The DataInputSteam class is subclass of FilterInputStream class. This class allows reading of java’s standard data type values. It implements the DataInput interface. \n\nConstructor \n1) DataInputStream (InputStream obj) : Obj is the object of an InputStream subclass.'),
            InterviewQuestionResponse(id: 29, topicId: 15, subjectId: 3, question: 'DataOutputStream', answer: '- The DataOutputStream is a subclass of FilterOutputStream. It is used to write java’s standard type values. \n- It implements DataOutput interface. \n\nConstructor \n1) DataOutputStream (OutputStream obj) : The obj is an object of subclass of OutputStream class.'),
            InterviewQuestionResponse(id: 30, topicId: 15, subjectId: 3, question: 'FilterOutputStream', answer: '- The FilterOutputStream class is subclass of OutputStream class. \n- It offers some extended level of functionality with compared to other output stream classes. \n- It is an abstract class and its three subclasses are BufferedOutputStrem, DataOutputStream and PrintStream classes. \n\nConstructor \n1) FilterOutputStream (OutputStream obj) : The obj is an object of an output stream classes.'),
            InterviewQuestionResponse(id: 31, topicId: 15, subjectId: 3, question: 'PrintStream', answer: '- The original intent of PrintStream was to print all of the primitive data types and String objects in a viewable format. \n\n- The PrintStream class is a subclass of FilterOutputStream class. It is used to print data as we do using print() and println() methods of system.out. \n\n- This class also supports these methods. In these methods java calls toString() method to convert data type to a simple data type. \n\n- The PrintStream class provides methods to write data to another stream. The PrintStream class automatically flushes the data so there is no need to call flush() method. \n\n- Moreover, its methods do not throw IOException. \n\nConstructor \n1) PrintStream (OutputStream obj) : The obj is an object of any OutputStream class. \n2) PrintStream (OutputStream obj, boolean flushOnNewLine) : If the flushOnNewLine is true, the output stream is automatically gets flushed when a new line character (\n) is encountered.'),
            InterviewQuestionResponse(id: 32, topicId: 15, subjectId: 3, question: 'PipedInputStream and PipedOutputStream', answer: '- The PipedInputStream and PipedOutputStream classes can be used to read and write data simultaneously. \n\n- Both streams are connected with each other using the connect() method of the PipedOutputStream class.'),
            InterviewQuestionResponse(id: 33, topicId: 15, subjectId: 3, question: 'RandomAcessFile', answer: '- The character and byte stream are all sequential access streams whose contents must be read or written sequentially. \n\n- The RandomAccessFile class is used to read or write data from a file randomly. \n\n- The Random Access File allows files to be accessed at a specific point in the file. They can be opened in read/write mode, which allows updating of a current file. \n\n- It is not derived from InputStream or OutputStrem but it is directly the subclass of Object class. Instead, it implements the interfaces DataInput and DataOutput. \n\n- Other java.io classes have sequential access to a file. But the RandomAccessFile can read or write from or to any location of a file, i.e. you can have the file pointer on any desired location in the file. \n\nConstructors \n1) RandomAccessFile(String filename, String access) throws FileNotFoundException \n2) RandomAccessFile(File fileObj, String access) throws  FileNotFoundException \n\nMethod \n1) void seek(long newPos) throws IOException: Position the file pointer at a particular point in a file. The new position is current position plus the offset. The offset may be positive or negative.'),
            //InterviewQuestionResponse(id: 35, topicId: 15, subjectId: 3, question: '', answer: ''),
            InterviewQuestionResponse(id: 36, topicId: 15, subjectId: 3, question: 'Serialization', answer: '- You can also read and write objects to files.\n\n- Serialization is a mechanism of writing the state of an object into a byte stream. It is mainly used in Hibernate, JPA, EJB etc. The reverse operation of the serialization is called deserialization. The String class and all the wrapper classes implements Serializable interface by default. \n\n- Object I/O goes by the awkward name of serialization. \n\n- Serialization in other languages can be very difficult, because objects may contain references to other objects \n\n- Java makes serialization (almost) easy. \n\n- Serialization work: FIFO'),
            InterviewQuestionResponse(id: 37, topicId: 15, subjectId: 3, question: 'Advantage of Serialization', answer: 'It is mainly used to travel object of state on the network.'),
            InterviewQuestionResponse(id: 38, topicId: 15, subjectId: 3, question: 'Serializable', answer: '- Serializable is a marker interface (have no body). It is just used to "mark" Java classes which support a certain capability. It must be implemented by the class whose object you want to persist. \n\n- Only an object that implements the Serializable interface can be saved and restored by the serialization facilities. \n\n- The Serializable interface defines no members. It is simply used to indicate that a class may be serialized. \n\n- If a class is serializable, all of its subclasses are also serializable. \n\n- Variables that are declared as transient are not saved by the serialization facilities. Also, static variables are not saved.'),
            //InterviewQuestionResponse(id: 39, topicId: 15, subjectId: 3, question: '', answer: ''),

            InterviewQuestionResponse(id: 1, topicId: 17, subjectId: 3, question: 'Collection Framework ', answer: 'Collection \n-Collection Framework provides architecture to store and manipulate the group of objects. \n- All the operations that you perform on a data such as searching, sorting, insertion, deletion etc. can be performed by Java Collection Framework. Collection simply means a single unit of objects.  \n- Collection framework provides many interfaces (Set, List, Queue, Deque etc.) and classes (ArrayList, Vector, LinkedList, PriorityQueue, HashSet, LinkedHashSet, TreeSet etc). \n- Collection framework is the standardized mechanism of grouping of similar or diss of objects into a single object. This single objectis known as collection framework object. \n- Collection framework using store the element any type of data. Exaple: int, String etc. \n\nFramework \n- Provides readymade architecture. \n- Represents set of classes and interface. \n- Is optional.'),
            InterviewQuestionResponse(id: 2, topicId: 17, subjectId: 3, question: 'Collection object', answer: 'An object is said to be collection object if it holds or stores a group of other objects.'),
            InterviewQuestionResponse(id: 3, topicId: 17, subjectId: 3, question: 'Collection class', answer: '- A collection class is a class whose object can store group of other objects. \n- The collections are designed to store only objects that is the collections cannot store primitive type values. \n- All the collection classes are available in “java.util” (utility) package. \n- All the collection interfaces and collection class and together as collection framework. '),
            InterviewQuestionResponse(id: 4, topicId: 17, subjectId: 3, question: 'What is the difference between collection and Collection and Collections?', answer: '- “Collection is an “interface” which can be used to represent a group of objects as a single entity. Whereas “Collections is a utility class” present in java.util package to define several utility methods for Collection objects. \n\ncollection (lowercase c) \n- It represents any of the data structures in which objects are stored and iterated over. \n\nCollection (capital C) \n- It is actually the java.util.Collection interface from which Set, List, and Queue extend. \n\nCollections (capital C and ends with s): \n- It is the java.util.Collections class that holds a pile of static utility methods for use with collections.'),
            InterviewQuestionResponse(id: 5, topicId: 17, subjectId: 3, question: 'Collection Classes and Interfaces', answer: '- The collection interface is the root of collection hierarchy and is used for common functionality across all collections. There is no direct implementationof Collection Interface. \n\n- This framework consists of interfaces and the concrete classes which implement them. The interfaces are the basic data structures and the classes implement them in different ways. \n\n- For e.g List is an interface and the different classes which implements List are Linked List and ArrayList. Similarly, Set is an interface which is implemented by HashSet, TreeSet and LinkedHashSet classes. \n\n- Map interface is implemented by HashMap, TreeMap and LinkedHashMap classes. Now we will see sample programs to demonstrate the use of these classes are used in Java programs.'),
            InterviewQuestionResponse(id: 6, topicId: 17, subjectId: 3, question: 'Cursors of collection framework', answer: '- This cursors are used to access the elements one by one perform some other operations. They are 3 cursors and they are: \n\n1) Iterator \n- Iterator ebables you to cycle through a collection, obtaining or removing elements. \n- This cursor can be applied to all the collection classes and it can be used to accesses the elements in forward direction obly.  \nMethod : hasNext(), next(), remove() \n\n2) ListIterator \n- ListIterator extends Iterator to allow bidirectional traversal (backword or forward) of a list, and the modification of elements. \n\n3) Enumeration \n- This cursor can be applied to only the legacy classes and it can be used to accesses the elements forward direction only. It can be only legacy interfaces. \n- Method : hashMoreElements(), nextElement()'),
            InterviewQuestionResponse(id: 7, topicId: 17, subjectId: 3, question: 'Difference between Iterator and List Iterator', answer: 'Iterator and List Iterator both are interfaces use for accessing the elements. The Iterator can be used to access the elements in forward direction only. Whereas List Iterator accessing the elements in both forward and reserve direction.'),
            InterviewQuestionResponse(id: 8, topicId: 17, subjectId: 3, question: 'List Interface', answer: '- List Interface is the sub interface of Collection. It contains methods to insert and delete elements in index basis. \n- It is a factory of ListIterator interface. \n- The List interface provides support for ordered collections of objects. \n- If we want to represent a group of individual objects as a single entity where dublicates are allow and insertion order must be preserved: then we should go for List interface. \n- ArrayList, LinkedList and vector are classes implementing List interface.'),
            InterviewQuestionResponse(id: 9, topicId: 17, subjectId: 3, question: 'ListIterator Interface', answer: '- It extends Iterator, allow bidirectional traversal of list and the modification of elements. \n- It is not advisable to modify the collection itself while traversing an Iterator. \n- ListIterator is the child interface of Iterator. \n- By using listIterator we can move either to the forward direction (or) to the backward direction that is it is a bi-directional cursor. \n- While iterating by listIterator we can perform replacement and addition of new objects in addition to read and remove operations.'),
            InterviewQuestionResponse(id: 10, topicId: 17, subjectId: 3, question: 'Limitations of Iterator', answer: '- Both enumeration and Iterator are single direction cursors only. That is we can always move only forward direction and we can’t move to the backward direction. \n- While iterating by Iterator we can perform only read and remove operations and we can’t perform replacement and addition of new objects. \n- To overcome these limitations sun people introducedlistIterator concept.'),
            InterviewQuestionResponse(id: 11, topicId: 17, subjectId: 3, question: 'Enumeration', answer: '- Enumeration is an interface. \n- An enumeration is an object that generates elements one at a time. It is used for passing through a collection, usually of unknown size. \n- The traversing of elements can only be done once per creation. \n- We can use Enumeration to get objects one by one from the legacy collection objects. \n- We can create Enumeration object by using elements() method. \n Enumeration e = v.elements(); //Vector Object \n- An object that implements the Enumeration interface generates a series of elements, one at a time. \n- Successive calls to the nextElement method return successive elements of the series. \n- For example, to print all elements of a vector v: \n\n for (Enumeration e = v.elements() ; e.hasMoreElements() ;) { System.out.println(e.nextElement()); } \n\n- Methods are provided to enumerate through the elements of a vector, the keys of a hashtable, and the values in a hashtable. \n- Enumeration acts as Read-only interface, because it has the methods only to traverse and fetch the objects. \n- Enumerations are also used to specify the input streams to a SequenceInputStream. \n- Enumerations are of class type, and have all the capabilities that a Java class has. \n- Enumerations can have constructors, instance variables, method and can even implement interfaces. \n- Enumerations are not instantiated using new keyword. \n- All Enumerations by default inherit java.lang.Enum class.'),
            InterviewQuestionResponse(id: 12, topicId: 17, subjectId: 3, question: 'for - each', answer: '- for - each version of for loop can also be used for traversing each element of a collection. But this can only be used if we do not want to modify the contents of a collection and we do not want any reverse access. \n- for - each loop can cycle through any collection of object that implements Iterable interface.'),
            InterviewQuestionResponse(id: 13, topicId: 17, subjectId: 3, question: 'Difference between List and Set.', answer: 'List can contain duplicate elements whereas Set contains unique elements only.'),
            InterviewQuestionResponse(id: 14, topicId: 17, subjectId: 3, question: 'Set interface', answer: '- It is the child interface of Collection. \n- If we want to represent a group of individual objects where duplicates are not allow and insertion order is not preserved then we should go for Set interface.'),
            InterviewQuestionResponse(id: 15, topicId: 17, subjectId: 3, question: 'SortedSet', answer: '- It is the child interface of Set. \n- If we want to represent a group of "unique objects" according to some sorting order then we should go for SortedSet. \n- That sorting order can be either default natural sorting (or) customized sorting order.'),
            InterviewQuestionResponse(id: 16, topicId: 17, subjectId: 3, question: 'NavigableSet', answer: '- It is the child interface of SortedSet. \n- It provides several method for navigation purposes.'),
            InterviewQuestionResponse(id: 17, topicId: 17, subjectId: 3, question: 'ArrayList', answer: 'Why situation ArrayList use? \n If you need to support random access through an index without inserting or removing elements from any place other than the end, ArrayList offers the most efficient collection. \n\n- Uses a dynamic (increased or decreased) array for storing the elements. It extends AbstractList class and implements List interface. \n- Maintains insertion order. \n- You can specify initial size of arraylist. But by default it is 10. \n- ArrayList is not synchronized. \n- Random access because array works at the index basis. Insertion and deletion operations are expensive since it requires shifting of other elements. \n- Manipulation slow because a lot of shifting needs to be occurred. \n- It is re - sizable array implementation. Belongs to ‘List’ group in collection. It permits all elements, including null. It is not thread -safe. \n- ArrayList can contain duplicate elements. \n- ArrayLists are created with initial size. \n- Array is collection of similar data items. We can have array of primitives or objects. It is of fixed size. \n-  We can have multi dimensional arrays. \n- If multiple threads access as ArrayList instance concurrenlty, and at least one of the threads modifies the list structurally, it must be sysnchronized exeternally. \n- Structural Modificaiton: any operation thats adds or deletes one or more elements, or explicitly resizes the backing array; just setting the value of an element is not a structural modification. \n- ArrayList class extends AbstractList. It also implements the List interface. It is generic class which has declaration as follows: \n\n class ArrayList<E> \n\n ArrayList<E> al = new ArrayList<E>(int initalcapacity);'),
            InterviewQuestionResponse(id: 18, topicId: 17, subjectId: 3, question: 'Thread safe ArrayList', answer: '•	We know that Vector is synchronized but ArrayList is not synchronized, to make ArrayList synchronized.'),
            InterviewQuestionResponse(id: 19, topicId: 17, subjectId: 3, question: 'Difference between Array List and Linked List', answer: '- ArrayList is an implement of class which follows Array structure. ArrayList is faster in accessing the elements and in insertion and deletion. \n- LinkedList is an implementation class of List interface which follows tree structure. LinkedList is solver in accessing the elements and faster insertion and deletion. \n- An element of an ArrayList can be accessed directly (an address calculation). To access an element in a LinkedList, the list must be traversed to the position of the element.'),
            InterviewQuestionResponse(id: 21, topicId: 17, subjectId: 3, question: 'LinkedList', answer: 'Why situation LinkedList use? \n- Your application requires the insertion or deletion of elements from any place in the list, you should choose LinkedList. \n\n LinkedList is based on a double linked list  \n- Gives better performance on add and remove compared to ArrayList. \n- Gives poorer performance on get and set methods compared to ArrayList. \n\n- Uses doubly linked list to store the elements. It extends the AbstractList class and implements List and Deque interfaces.\n- It provides a linked - list data structure. \n- Can contain duplicate elements. \n- Maintains insertion order. \n- Not synchronized. \n- No random access. \n- Manipulation fast because no shifting needs to be occurred. \n- Can be used as list, stack or queue. \n- It does not support random access for retrieving values. \n- Insertion and deletion are very fast as no shifting is required (it involves pointer movements) but it provides sequential access only. \n- The underlying data structure is double LinkedList. \n- If our frequent operation is inserion or deletion in the middle then LinkedList is the best choice. \n- If our frequent operation is retrieval operation then LinkedList is worst choice. \n- Dublicate objects are allowed. \n- Insertion order is preserved. \n- Heterogeneous objects are allowed. \n- Null insertion is possible.'),
            InterviewQuestionResponse(id: 22, topicId: 17, subjectId: 3, question: 'Disadvantages of LinkedList', answer: '\n- Additional memory space is created for address partof the node in heap memory. \n- Retrieval time is more. \n- Since, we are wasting most of the memory space for addresses, performance will be reduced.'),
            InterviewQuestionResponse(id: 23, topicId: 17, subjectId: 3, question: 'Which implementation of the List interface provides for the fastest insertion of a new element into the middle of the list?', answer: '\n- Vector, Arraylist, Linkedlist. \n- Arraylist and Vector both use an array to store the elements of the list. \n- When an element is inserted into the middle of the list the elements that follow the insertion point must be shifted to make room for the new element. \n- The linkedlist is implemented using a doubly linked list; an insertion requires only the updating of the links at the point of insertion. Therefore, the linkedlist allows for fast insertions and deletions.'),
            InterviewQuestionResponse(id: 24, topicId: 17, subjectId: 3, question: 'Hashtable', answer: '\n- A Hashtable is an array of list. Each list is known as a bucket. The position of bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key. The records are rows of the HashTable. It implements the Map interface and extends Dictionary class. \n- HashTable is similar to HashMap which can store elements in the form of key - value pairs and it is synchronized. \n- Key contains unique elements. \n- It may have only one null key allow or value is more than one null key allow. It is part of group Map in collection. \n\n Syntax : obj.put("Object Key", "Object Value"); \n\n- It is synchronized. \n\n Properties of Hashtable \n- Hashtable is a legacy class introduced with JDK 1.0. \n- Stores data in key/value pairs. \n- It does not accept duplicate keys. If the same key is added twice, the earlier one is replaced (overwritten), that is old value is lost. \n- Value can be same for different keys (like value red can be there for keys tomato and apple or two students with roll number 40 and 50 may have the same birthday). \n- Key and value cannot be null and if added, JVM throws NullPointerException. Infact, with null key, the code compiles but does not execute. \n- Hashtable methods are synchronized (like Vector). \n- Hashtable can be designed for generics to accept same type of data. \n- Its equivalent in collections framework is HashMap. \n\nclass HashTable<K,V> Where K specifies type of keys, and V specifies type of values. \n\nWe can create HashTable as follows: HashTable<String, Integer> ht = new HashTable<String, Integer>();'),
            InterviewQuestionResponse(id: 25, topicId: 17, subjectId: 3, question: 'Map interface', answer: '- A map contains values based on the key i.e. key and value pair. Each pair is known as an entry. \n- Map contains only unique elements. \n- Map is not child interface of Collection. \n- A Map is an object that maps keys to values. Also called an associative array or a dictionary. \n- If we want to represent a group of objects as key - value pairs then we should go for Map interface. \n- Duplicate keys are not allowed but values can be duplicated. \n- The Map implementation let do things like search value based on the key. \n- The Map interface is implemented by HashMap, Hashtable, TreeMap, EnumMap, IdentifyHashMap, LinkedHashMap, Properties. \n\nSyntax : Map obj = new HashMap(); \n\nAdd element map : obj.put(new Long(1000000000L),new String("JDK GROUP"));'),
            InterviewQuestionResponse(id: 26, topicId: 17, subjectId: 3, question: 'SortedMap', answer: '- It is the child interface of Map. \n- If we want to represent a group of objects as key value pairs “according to some sorting order of keys” then we should go for SortedMap.'),
            InterviewQuestionResponse(id: 27, topicId: 17, subjectId: 3, question: 'NavigableMap', answer: 'It is the child interface of SortedMap and defines several methods for navigation purposes.'),
            InterviewQuestionResponse(id: 28, topicId: 17, subjectId: 3, question: 'What is hashmap and Map?', answer: 'Map is Interface which is part of Java collections framework. This is to store Key Value pair, and Hashmap is class that implements that using hashing technique.'),
            InterviewQuestionResponse(id: 29, topicId: 17, subjectId: 3, question: 'HashMap', answer: '- It is an implementation class of Map interface. \n- This class is used to store the elements if the form of key and other one is value pairs. The keys must be unique and the values can be duplicated. \n- The keys are like indexes. In List, the indexes are integers. \n- You can use anything as key of map. But while using your custom object as map key, that object should have hashCode and equals methods implemented. \n- It implements the Map interface and extends AbstractMap class. \n- It may have one null key and multiple null values. \n- You may want to store multiple values for the same key. \n\nThree way to possible \n1) Java util\n2) Guava Collection \n3) Commons Collection \n- It maintains no order. \n- If you try to get the value that doesn’t exist in your map, it returns null. \n- If you try to add duplicate key into map, it overrides the previous entry. \n- HashMap is not sorted in any way. It does maintain order. \n- HashMap is not synchronized meanning is not thread safety. This class does not guarantee the order of insertion.  \n- Hashmap is fail fast meaning, if we are modifying, adding, remove any object while iteration of HashMap, it throws ConcurrentModificationException. \n- HashMap, HashTable, TreeMap and LinkedHashMap are classes implementing Map interface. \n\nSyntax \n1) HashMap<k, v> hm = new HashMap<k, v>(); \n2) HashMap<k, v> hm = new HashMap<k, v>(int capacity); \n\nk – key and v - value'),
            InterviewQuestionResponse(id: 30, topicId: 17, subjectId: 3, question: 'LinkedHashMap', answer: '- A LinkedHashMap contains values based on the key. It implements the Map interface and extends HashMap class. \n- It contains only unique elements. \n- It may have one null key and multiple null values. \n- It is same as HashMap instead maintains insertion order. \n- It is exactly same as HashMap except the following differences. \n- In the case of HashMap JVM will always use “.equals()” method to identify duplicate keys.  \n- But in the case of IdentityHashMap JVM will use == (double equal operator) to identify duplicate keys.'),
            InterviewQuestionResponse(id: 31, topicId: 17, subjectId: 3, question: 'WeakHashMap', answer: '- It is exactly same as HashMap except the following differences. \n- In the case of normal HashMap, an object is not eligible for GC even though it doesn’t have any references if it is associated with HashMap. That is HashMap dominates garbage collector. \n- But in the case of WeakHashMap if an object does not have any references then it’s always eligible for GC even though it is associatedwith WeakHashMap that is garbage collector dominates WeakHashMap.'),
            InterviewQuestionResponse(id: 32, topicId: 17, subjectId: 3, question: 'TreeMap ', answer: '- TreeMap store the element natural order. \n- TreeMap sorts the keys in natural order. Natural order for integers is numerical order (1, 2, 3, ….) and for Strings it is alphabetical order (a, b, c, d, …). You can define natural order for your custom objects also. \n- A TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class. \n- It contains only unique elements. \n- It cannot have null key but can have multiple null values. \n- It is same as HashMap instead maintains ascending order. \n- TreeMap actually implements the SortedMap interface which extends the Map interface. \n- In a TreeMap the data will be sorted in ascending order of keys according to the natural order for the key class, or by the comparator provided at creation time. TreeMap is based on the Red-Black tree data structure. \n- There are no restrictions on values they can be heterogeneous and non Comparable. \n- For the non empty TreeMap if we are trying to insert an entry with null key we will get NullPointerException.'),
            InterviewQuestionResponse(id: 33, topicId: 17, subjectId: 3, question: 'NavigableMap', answer: 'It is the child interface of SortedMap and it defines several methods for navigation purpose.'),
            InterviewQuestionResponse(id: 34, topicId: 17, subjectId: 3, question: 'Set interface', answer: '- Set Interface also extends the Collection Interface. Set mean that it does not allow duplicate element i.e it care about uniqueness. \n- The concrete class implements hashcode and equals methods to make sure uniqueness of objects.  \n- It does not define any additional methods of its own. All these methods are inherited from Collection interface. \n\nThere are three classes that implements Set interface \n1) HashSet \n2) TreeSet \n3) LinkedHashSet'),
            InterviewQuestionResponse(id: 35, topicId: 17, subjectId: 3, question: 'HashSet interface', answer: '- Implemented using a hash table. \n- No ordering of elements. \n- This class implements the set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. \n- This class permits the null element.\n- This class offers constant time performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. \n- Implements Serializable and Cloneable interfaces but not RandomAccess. \n- If we are trying to insert duplicate objects we won’t get compile time error and runtime error add() method simply returns false. \n- Duplicate objects are not allowed. \n- Insertion order is not preserved and it is based onhash code of the objects. \n- The underlying data structure is Hashtable.'),
            InterviewQuestionResponse(id: 36, topicId: 17, subjectId: 3, question: 'TreeSet class', answer: '- Contains unique elements only like HashSet. The TreeSet class implements NavigableSet interface that extends the SortedSet interface using a red - black tree. \n\nA red - black tree is a binary search tree that has its nodes colored so that \n1) The root is black. \n2) No path from the root to a leaf has consecutive red nodes. \n3) All paths from the root to leaves have the same number of black nodes. \n\n- Objects are stored in sorted, ascending order. \n- Duplicate objects are not allowed. \n- Insertion order is not preserved and it is based onsome sorting order of objects. \n- Heterogeneous objects are not allowed if we are trying to insert heterogeneous objects then we will get ClassCastException. \n- Null insertion is possible (only once). \n- The underlying data structure is balanced tree. \n- Access and retrieval times are quite fast, which makes TreeSet an excellent choice when storing large amount of sorted information that must be found quickly.'),
            InterviewQuestionResponse(id: 37, topicId: 17, subjectId: 3, question: 'LinkedHashSet', answer: '- Contains unique elements only like HashSet. It extends HashSet class and implements Set interface. \n- Maintains insertion order. \n- It is the child class of HashSet. \n- The underlying data structure is a combination of LinkedList and Hashtable. \n- Introduced in 1.4v. \n- Insertion order is preserved.'),
            InterviewQuestionResponse(id: 38, topicId: 17, subjectId: 3, question: 'Queue', answer: '- The Queue interface basically orders the element in FIFO (First In First Out) manner. \n- It is the child interface of Collection. \n- If we want to represent a group of individual objects prior to processing then we should go for queue concept. \n\nTypes of Queues \nThread - safety \n- If you do not require the queue to be accessed concurrently from multiple threads, then a plain LinkedList can be used as a Queue; the advantage of the other implementations is that they offer efficient thread-safety; \nBlocking or non - blocking \n- Various blocking implementations add extra methods to put and remove items from the queue, blocking until the operation is possible, with an optional time limit; \nBound or non - bound \n- Sometimes it is useful to put an upper limit on the number of items that can fit in the queue, e.g. to prevent a thread pool from queueing up too many jobs when the machine is busy; \nOther special operations \n- Java provides an implementation that orders by priority, and another that applies a delay to queued items. \n\nQueue implementations \n1) ArrayBlockingQueue \n2) LinkedBlockingQueue \n3) PriorityBlockingQueue \n4) DelayQueue \n5) ConcurrentLinkedQueue \n6) LinkedList \n7) PriorityQueue'),
            InterviewQuestionResponse(id: 39, topicId: 17, subjectId: 3, question: 'ArrayBlockingQueue', answer: '- ArrayBlockingQueue implements BlockingQueue. \n- ArrayBlockingQueue is bounded queue i.e. size is fixed by given number. It is backed by array. That is why it is called ArrayBlockingQueue. \n- It acts as queue that FIFO (first in - first out). \n- Blocking means when the element is fetched from head and there is no element in queue, then it will wait till the element will present.'),
            InterviewQuestionResponse(id: 40, topicId: 17, subjectId: 3, question: 'PriorityQueue', answer: '- The PriorityQueue class provides the facility of using queue. But it does not orders the elements in FIFO manner. \n- PriorityQueue is similar to Queue but elements are processed according to their priority. The priorities can be assigned to elements by providing a comparator (discussed below) at the time of instantiation of the PriorityQueue. \n- If no priorities are assigned, the by default elements are stored by their natural ordering as per Heap data structure (PriorityQueue is implemented using Heap). \n- We can use PriorityQueue to represent a group of individual objects prior to processing according to some priority. \n- The priority order can be either default natural sorting order (or) customized sorting order specified by Comparator object. \n- If we are depending on default natural sorting order then the objects must be homogeneous and Comparable otherwise we will get ClassCastException. \n- If we are defining our own customized sorting order by Comparator then the objects need not be homogeneous and Comparable. \n- Duplicate objects are not allowed. \n- Insertion order is not preserved but all objects will be inserted according to some priority. \n- Null is not allowed even as the 1st element for empty PriorityQueue.'),
            InterviewQuestionResponse(id: 41, topicId: 17, subjectId: 3, question: 'Comparator interface', answer: '- Comparator interface is used to order the objects of user-defined class. This interface is found in java.util package and contains only one method named compare(Object obj1,Object obj2). \n- It provides multiple sorting sequences i.e. you can sort the elements based on any data member. For instance it may be of rollno, name, age or anything else. \n\nSyntax of compare method of Comparator interface \n1) boolean equals(Object obj) \n2) public int compare(Object obj1, Object obj2)'),
            InterviewQuestionResponse(id: 42, topicId: 17, subjectId: 3, question: 'Stack', answer: '- The Stack class represents a last - in - first - out (LIFO) stack of objects. \n- It is the child class of Vector. \n- It extends class Vector with five operations that allow a vector to be treated as a stack. \n- The usual push and pop operations are provided, as well as a method to peek at the top item on the stack, a method to test for whether the stack is empty, and a method to search the stack for an item and discover how far it is from the top. \n- When a stack is first created, it contains no items. \n- It has one constructor. \n- Stack(): It will create empty Stack.'),
            InterviewQuestionResponse(id: 43, topicId: 17, subjectId: 3, question: 'Limitations of stack usage', answer: '- The programmer stores data in a DS with an intention to get the elements whenever he would like in the code. But with stack, the popped element is completely removed and cannot be obtained again. For this reason stack is not used much in general production software like health and banking etc, but used by system and tool developers. \n- Another drawback is, the elements cannot be added or retrieved from the middle.'),
            InterviewQuestionResponse(id: 44, topicId: 17, subjectId: 3, question: 'Properties class', answer: '- Properties class extends Hashtable class.\n- Properties class object is used for reading of maintaining system environmental variables and reading the data from resource data file or properties file. \n- The properties object contains key and value pair both as a string. \n- It can be used to get property value based on the property key. The Properties class provides methods to get data from properties file and store data into properties file. Moreover, it can be used to get properties of system. \n- One advantage of Propertirs over Hashtable is that we can specify a default property that will be useful when no value is associated with a certain key. \n- The main advantage in this approach is if there is any change in property files automatically those changes will  be  available to java application just redeployment is enough. \n- By using Properties object we can read and hold properties from property files into java application. \n\nAdvantage of properties file \n- Easy Maintenance: If any information is changed from the properties file, you do not need to recompile the java class. It is mainly used to contain variable information i.e. to be changed. \n\nConstructor  \n1) Properties() \n2) Properties(Properties default)'),
            InterviewQuestionResponse(id: 45, topicId: 17, subjectId: 3, question: 'What is the difference between Sorting performance of Arrays.sort() vs Collections.sort()? Which one is faster? Which one to use and when?', answer: '- java.util.Array.sort() and java.util.Collections.sort() methods both methods have same algorithm the only difference is type of input to them. \n- Collections.sort() has a input as List so it does a translation of List to array and vice versa which is an additional step while sorting. \n- So this should be used when you are trying to sort a list. \n- Arrays.sort is for arrays so the sorting is done directly on the array. So clearly it should be used when you have a array available with you and you want to sort it.  '),
            InterviewQuestionResponse(id: 46, topicId: 17, subjectId: 3, question: 'Vector', answer: '- java.util package. Vector is a class.\n- The Vector class provides the capability to implement a growable array of objects. \n- The vector class creates a dynamic array. \n- The simple array you create is of a fixed size, but you can create dynamic array using the vector class. Thus a vector automatically grows when needed. \n- Moreover, in simple array you can store elements of same data types only. In vector, you can insert objects. \n- Vector contains the synchronized methods for accessing and modifying the vector, ArrayList is not. \n- This class is similar to ArrayList which can store group of individual elements. It allows storing duplicate values. Vector is a synchronized class. \n- The only limitation is that it can not hold elements of primitive data types like int, float, char, double, long and boolean, we can only store objects. So, the elements need to be converted to objects before storing them in vector. \n- This can be done using wrapper classes contained in java.lang package. For e.g. Integer is a wrapper class to convert an int type element to an object. \n- It is similar to ArrayList, but with two differences: Vector is synchronized, it ca not allow special characters and null values and it contains many legacy methods that are not part of the collections framework. \n- Like an array, it contains components that can be accessed using an integer index. \n- For Using Vectors we have to import java.util package. These are also called as dynamic Array of object data type but always Remember vectors doesn’t support primitive’s data types like int, float, char etc. \n- To add element in vector, addElement() method is used. \n- All vector starts with initial capacity, after it is reached next time if we want to store object in vector, the vector automatically allocates space for that object plus extra room for additional objects. \n- However, the size of a Vector can grow or shrink as needed to accommodate adding and removing items after the Vector has been created. \n\nConstructors \nvector() \nvector(int initialCapacity) \nvector(int initialCapacity, int capacityIncrement) \n\n- The first constructor constructs an empty vector so that its internal data array has size 10 and its standard capacity increment is zero. Default constructor with initial size 10. \n- Second constructor constructs an empty vector with the specified initial capacity and with its capacity increment equal to zero. \n- Third constructor constructs an empty vector with the specified initial capacity and capacity increment.'),
            InterviewQuestionResponse(id: 47, topicId: 17, subjectId: 3, question: 'Enum', answer: ''),
            InterviewQuestionResponse(id: 48, topicId: 17, subjectId: 3, question: 'When to use LinkedList or ArrayList?', answer: ''),
            InterviewQuestionResponse(id: 49, topicId: 17, subjectId: 3, question: 'How can you convert Map to List?', answer: 'We know that Map contains key-value pairs, whereas a list contains only objects. Since Entry class contains both key-value pair, Entry class will helps us to convert from Map (HashMap) to List (ArrayList). By using Map.entrySet() you will get Set object, which intern you can use it to convert to list object. \n\npublic static void main(String a[]){ \nMap<String, String> wordMap = new HashMap<String, String>(); \nSet<Entry<String, String>> set = wordMap.entrySet(); \nList<Entry<String, String>> list = new ArrayList<Entry<String, String>>(set);}'),

            InterviewQuestionResponse(id: 1, topicId: 18, subjectId: 3, question: 'Generic', answer: '- Generics is facility added in java programming in 2004 as a part of J2SE 1.5. \n\n- This allows type or method to operate on objects of various types while providing compile time safety. Common use of generics is when using Java Collection that can hold objects of any type, to specify the type of objects store in it. \n\n- J2SE 5.0 provides compile-time type safety with the Java Collections framework through generics. \n\n- Generics allows you to specify, at compile-time, the types of objects you want to store in a Collection. Then when you add and get items from the list, the list already knows what types of objects are supposed to be acted on. \n\n- So you do not need to cast anything. The "<>" characters are used to designate what type is to be stored. If the wrong type of data is provided, a compile-time exception is thrown. \n\n- Generics abstract over Types. \n\n- Classes, Interfaces and Methods can be Parameterized by Types. \n\n- Generics provide increased readability and type safety.'),
            InterviewQuestionResponse(id: 2, topicId: 18, subjectId: 3, question: 'What are the benefits of the generic types?', answer: '- Generics provides compile time safety. \n\n- Java collection stores object of any type, generics specify the type of object which can be contained by collection. \nE.g \nList list = new ArrayList(); //can store any object \n\nList<String> list = new ArrayList<String>(); //can store only string inside the list now. \n\n- Iterating over the collection is easier, explicit casting can be avoided.'),
            InterviewQuestionResponse(id: 3, topicId: 18, subjectId: 3, question: 'Generic methods', answer: 'A generic method can operate on any data type i.e we can write one generic method which can be called with arguments if different types. In the following program, we write a generic display( ) method to print array elements.'),
            InterviewQuestionResponse(id: 4, topicId: 18, subjectId: 3, question: 'Generic Classes', answer: 'All classes and interfaces in the Collection framework are generic and we have already used those classes previously. Now we will see how to make user defined classes generic.'),
            InterviewQuestionResponse(id: 5, topicId: 18, subjectId: 3, question: 'Autoboxing and Unboxing', answer: '- Autoboxing is a feature of Java language which is used in conjunction with generics to automatically convert primitive data type to their corresponding Wrapper Classes. \n\n- For e.g. conversion of int data type to Integer class or conversion of char data type to Character class. \n\n- Generic classes cannot deal with primitive data types. So, this conversion is important and it is done automatically and we have already used this feature in lot of programs previously. \n\n- The reverse operation (conversion from Wrapper Class objects to primitive data types) is known as Unboxing. \n\n- As a programmer, we do not have to worry about how boxing and unboxing is handled by Java Compiler internally.'),

            InterviewQuestionResponse(id: 1, topicId: 19, subjectId: 3, question: 'Anonymous inner class', answer: '- Anonymous inner class is a class it has no name. It is a non - static nested class without name. \n\n- Anonymous inner class makes out code more concise. They enable us to declare and instantiate the class at the same time. \n\n- An anonymous inner class, as the name indicates, does not have a name. As it does not contain a name, it must be instantiated at the time of defining it. This type of anonymous classes is mostly used in event handling mechanism of AWT. \n\n- The class instance is being created at the time of its creation.'),
            InterviewQuestionResponse(id: 2, topicId: 19, subjectId: 3, question: 'Anonymous class has some restrictions', answer: '- It is not possible to declare SIB and static members. \n- If we want to declare static variables, they must be constant variables.'),
            InterviewQuestionResponse(id: 3, topicId: 19, subjectId: 3, question: 'We can declare the following in Anonymous inner class', answer: '1) Fields \n2) Extra methods(excluding superclass methods) \n3) IIB \n4) Local Classes'),

            InterviewQuestionResponse(id: 1, topicId: 20, subjectId: 3, question: 'JSON', answer: '- JSON (JavaScript Object Notation) is a lightweight, text-based, language-independent data exchange format that is easy for humans and machines to read and write. \n\n- JSON can represent two structured types: objects and arrays. \n\n- An object is an unordered collection of zero or more name/value pairs. \n\n- An array is an ordered sequence of zero or more values. The values can be strings, numbers, booleans, null, and these two structured types.'),

            InterviewQuestionResponse(id: 1, topicId: 21, subjectId: 3, question: 'GSON', answer: 'Google Gson is a Java library that can be used to convert Java Objects into respective JSON format. \n\nIn another way, it can used to convert the JSON into equivalent java objects. \n\nThere are some other java libraries also capable of doing this conversion, but Gson stands among very few which do not require any pre-annotated java classes OR sourcecode of java classes in any way.'),
            InterviewQuestionResponse(id: 2, topicId: 21, subjectId: 3, question: 'Gson toJson() – Convert Java object to JSON', answer: 'Gson gson = new Gson(); \n\nSystem.out.println(gson.toJson(classname));'),

            //ANDROID
            InterviewQuestionResponse(id: 1, topicId: 1, subjectId: 4, question: 'What is Android?', answer: 'Android is an open-source, Linux-based operating system used in mobiles, tablets, televisions, etc.'),
            InterviewQuestionResponse(id: 2, topicId: 1, subjectId: 4, question: 'Context', answer: 'A Context is a handle to the system; it provides services like resolving resources, obtaining access to databases and preferences, and so on. An Android app has activities. Context is like a handle to the environment your application is currently running in. \n\nApplication Context: This context is tied to the lifecycle of an application. The application context can be used where you need a context whose lifecycle is separate from the current context or when you are passing a context beyond the scope of an activity. \n\nActivity Context: This context is available in an activity. This context is tied to the lifecycle of an activity. The activity context should be used when you are passing the context in the scope of an activity or you need the context whose lifecycle is attached to the current context.'),
            InterviewQuestionResponse(id: 3, topicId: 1, subjectId: 4, question: 'Difference between AsyncTasks & Threads?', answer: '- Thread should be used to separate long running operations from main thread so that performance is improved. But it can’t be cancelled elegantly and it can’t handle configuration changes of Android. You can’t update UI from Thread.\n\n- AsyncTask can be used to handle work items shorter than 5ms in duration. With AsyncTask, you can update UI unlike java Thread. But many long running tasks will choke the performance.'),
            InterviewQuestionResponse(id: 4, topicId: 1, subjectId: 4, question: 'Difference between Service, Intent Service, AsyncTask & Threads', answer: '- Android service is a component that is used to perform operations on the background such as playing music. It doesn’t has any UI (user interface). The service runs in the background indefinitely even if application is destroyed. \n\n- AsyncTask allows you to perform asynchronous work on your user interface. It performs the blocking operations in a worker thread and then publishes the results on the UI thread, without requiring you to handle threads and/or handlers yourself. \n\n- IntentService is a base class for Services that handle asynchronous requests (expressed as Intents) on demand. Clients send requests through startService(Intent) calls; the service is started as needed, handles each Intent in turn using a worker thread, and stops itself when it runs out of work. \n\n- A thread is a single sequential flow of control within a program. Threads can be thought of as mini-processes running within a main process.'),
            InterviewQuestionResponse(id: 5, topicId: 1, subjectId: 4, question: 'What is Application?', answer: 'The Application class in Android is the base class within an Android app that contains all other components such as activities and services. The Application class, or any subclass of the Application class, is instantiated before any other class when the process for your application/package is created.'),
            InterviewQuestionResponse(id: 6, topicId: 1, subjectId: 4, question: 'Why bytecode cannot be run in Android?', answer: 'Android uses DVM (Dalvik Virtual Machine ) rather using JVM(Java Virtual Machine).'),
            InterviewQuestionResponse(id: 7, topicId: 1, subjectId: 4, question: 'What is Armv7?', answer: 'There are 3 CPU architectures in Android. ARMv7 is the most common as it is optimised for battery consumption. ARM64 is an evolved version of that that supports 64-bit processing for more powerful computing. ARMx86, is the least used for these three, since it is not battery friendly. It is more powerful than the other two.'),
            InterviewQuestionResponse(id: 8, topicId: 1, subjectId: 4, question: 'What is .apk extension in Android?', answer: 'It is a default file format that is used by Android Operating System. Application Package Kit (APK) is used for installation of mobile apps. The .apk contains resource file, certificate, manifest file and other code. \n\nAPK files are archive files in the zip format with .apk extension.'),
            InterviewQuestionResponse(id: 9, topicId: 1, subjectId: 4, question: 'What is AIDL?', answer: 'In the Android platform, there are remote methods which facilitate the use of methods from one program to another. To create and implement the remote methods the first step is to define communication interface in AIDL. \n\nAIDL stands for Android Interface Definition Language. It facilitates the communication between the client and service. It also communicates the information through inter-process communication. \n\nFor communication between processes, the data is broken down into chunks which are easily understandable by the Android platform.'),
            InterviewQuestionResponse(id: 10, topicId: 1, subjectId: 4, question: 'Explain AndroidManifest.xml file and why do you need this?', answer: 'Every application must have AndroidManifest.xml file in the root directory. It contains the information about your app and provides the same to the Android system. \nThe information includes the package name, Android components such as Activity, Services, Broadcast Receivers, Content Providers, etc. Every Android system must have this information before running any app code. \n\nAndroidManifest.xml file performs the following tasks: \n\n- It provides a name to the Java package and this name is a unique identifier for the application. \n\n- It describes the various components of the application which include Activity, Services, Content Providers, etc. Also, it defines the classes which implement these components. \n\n- It is responsible to protect the application and it declares the permission for accessing the protected part of the app. \n\n- It also declares the Android API which is going to be used by the application. \n\n- It contains the library file details which are used and linked to the application.'),
            InterviewQuestionResponse(id: 11, topicId: 1, subjectId: 4, question: 'What is a singleton class in Android?', answer: 'A singleton class is a class which can create only an object that can be shared all other classes.'),
            InterviewQuestionResponse(id: 12, topicId: 1, subjectId: 4, question: 'What is adb?', answer: 'Adb is short for Android Debug Bridge. It allows developers the power to execute remote shell commands. Its basic function is to allow and control communication towards and from the emulator port.'),
            InterviewQuestionResponse(id: 13, topicId: 1, subjectId: 4, question: 'Explain retrofit use rxjava.', answer: 'RxAndroid adds android specific bindings for RxJava, Specifically AndroidSchedulers.mainThread() which provides a Scheduler that schedules on main thread and can be used to switch between threads in Android. \n\naddCallAdapterFactory(RxJava2CallAdapterFactory.create()) \n\naddCallAdapterFactory() — Adapter factory for supporting service method return types, add instance of RxJava2CallAdapterFactory for Rxjava 2 support. \n\nYou can use the Observable/Flowable returned by the API and subscribe() to it to handle the data.'),
            InterviewQuestionResponse(id: 14, topicId: 1, subjectId: 4, question: 'What is Room?', answer: 'The Room persistence library provides an abstraction layer over SQLite to allow for more robust database access while harnessing the full power of SQLite. \nBasically, with the help of room we can quickly create sqlite databases and perform the operations like create, read, update and delete. Room makes everything very easy and quick. \n\nComponents of Room We have 3 components of room. \nEntity: Instead of creating the SQLite table, we will create the Entity. Entity is nothing but a model class annotated with @Entity. The variables of this class is our columns, and the class is our table. \nDatabase: It is an abstract class where we define all our entities. \nDAO: Stands for Data Access Object. It is an interface that defines all the operations that we need to perform in our database.'),
            InterviewQuestionResponse(id: 15, topicId: 1, subjectId: 4, question: 'Library', answer: 'spruce-android'),

            InterviewQuestionResponse(id: 1, topicId: 3, subjectId: 4, question: 'Android architecture', answer: 'android architecture or Android software stack is categorized into five parts: \n\n1) Linux kernel : It is the heart of android architecture that exists at the root of android architecture. Linux kernel is responsible for device drivers, power management, memory management, device management and resource access. \n\n2) Native Libraries : On the top of linux kernel, their are Native libraries such as WebKit, OpenGL, FreeType, SQLite, Media, C runtime library (libc) etc. \nThe WebKit library is responsible for browser support, SQLite is for database, FreeType for font support, Media for playing and recording audio and video formats. \n\n3) Android Runtime : In android runtime, there are core libraries and DVM (Dalvik Virtual Machine) which is responsible to run android application. DVM is like JVM but it is optimized for mobile devices. It consumes less memory and provides fast performance. \n\n4) Android Framework : On the top of Native libraries and android runtime, there is android framework. Android framework includes Android API of such as UI (User Interface), telephony, resources, locations, Content Providers (data) and package managers. It provides a lot of classes and interfaces for android application development. \n\n5) Applications : On the top of android framework, there are applications. All applications such as home, contact, settings, games, browsers are using android framework that uses android runtime and libraries. Android runtime and native libraries are using linux kernal.'),

            InterviewQuestionResponse(id: 1, topicId: 4, subjectId: 4, question: 'Activity lifecycle ', answer: 'Android Activity Lifecycle is controlled by 7 methods of android.app.Activity class. The android Activity is the subclass of ContextThemeWrapper class. \nAn activity is the single screen in android. It is like window or frame of Java. \nBy the help of activity, you can place all your UI components or widgets in a single screen. \n\n1) onCreate : When activity is first created. \n\n2) onStart : When activity is becoming visible to the user. \n\n3) onResume :  When activity will start interacting with the user. \n\n4) onPause : When activity is not visible to the user. \n\n5) onStop : When activity is no longer visible to the user. \n\n6) onRestart : Called after your activity is stopped, prior to start. \n\n7) onDestroy : Called before the activity is destroyed.'),
            InterviewQuestionResponse(id: 2, topicId: 4, subjectId: 4, question: 'Fragment lifecycle', answer: '- Android Fragment is the part of activity, it is also known as sub-activity. There can be more than one fragment in an activity. Fragments represent multiple screen inside one activity. \n- Android fragment lifecycle is affected by activity lifecycle because fragments are included in activity. \n- Each fragment has its own life cycle methods that is affected by activity life cycle because fragments are embedded in activity. \n- The FragmentManager class is responsible to make interaction between fragment objects. \n\n 1) onAttach(Activity) : It is called only once when it is attached with activity. \n\n2) onCreate(Bundle) : It is used to initialize the fragment. \n\n3) onCreateView(LayoutInflater, ViewGroup, Bundle) : Creates and returns view hierarchy. \n\n4) onActivityCreated(Bundle) : It is invoked after the completion of onCreate() method. \n\n5) onViewStateRestored(Bundle) : It provides information to the fragment that all the saved state of fragment view hierarchy has been restored. \n\n6) onStart() : Makes the fragment visible. \n\n7) onResume() : Makes the fragment interactive. \n\n8) onPause() : Is called when fragment is no longer interactive. \n\n9) onStop() : Is called when fragment is no longer visible. \n\n10) onDestroyView() : Allows the fragment to clean up resources. \n\n11) onDestroy() : Allows the fragment to do final clean up of fragment state. \n\n12) onDetach() : It is called immediately prior to the fragment no longer being associated with its activity.'),
            InterviewQuestionResponse(id: 3, topicId: 4, subjectId: 4, question: 'What’s the difference between onCreate() and onStart()?', answer: '- The onCreate() method is called once during the Activity lifecycle, either when the application starts, or when the Activity has been destroyed and then recreated, for example during a configuration change. \n\n- The onStart() method is called whenever the Activity becomes visible to the user, typically after onCreate() or onRestart().'),
            InterviewQuestionResponse(id: 4, topicId: 4, subjectId: 4, question: 'Scenario in which only onDestroy is called for an activity without onPause() and onStop()?', answer: 'If finish() is called in the OnCreate method of an activity, the system will invoke onDestroy() method directly.'),
            InterviewQuestionResponse(id: 5, topicId: 4, subjectId: 4, question: 'Why would you do the setContentView() in onCreate() of Activity class?', answer: 'As onCreate() of an Activity is called only once, this is the point where most initialisation should go. It is inefficient to set the content in onResume() or onStart() (which are called multiple times) as the setContentView() is a heavy operation.'),
            InterviewQuestionResponse(id: 6, topicId: 4, subjectId: 4, question: 'onSavedInstanceState() and onRestoreInstanceState() in activity?', answer: '- OnRestoreInstanceState() - When activity is recreated after it was previously destroyed, we can recover the saved state from the Bundle that the system passes to the activity. Both the onCreate() and onRestoreInstanceState() callback methods receive the same Bundle that contains the instance state information. But because the onCreate() method is called whether the system is creating a new instance of your activity or recreating a previous one, you must check whether the state Bundle is null before you attempt to read it. If it is null, then the system is creating a new instance of the activity, instead of restoring a previous one that was destroyed. \n\n- onSaveInstanceState() - is a method used to store data before pausing the activity.'),

            InterviewQuestionResponse(id: 1, topicId: 5, subjectId: 4, question: 'What is an intent?', answer: 'Intents are messages that can be used to pass information to the various components of android. For instance, launch an activity, open a webview etc. \n\nTwo types of intents : \n- Implicit: Implicit intent is when you call system default intent like send email, send SMS, dial number. \n- Explicit: Explicit intent is when you call an application activity from another activity of the same application.'),
            InterviewQuestionResponse(id: 2, topicId: 5, subjectId: 4, question: 'What is a Sticky Intent?', answer: 'Sticky Intents allows communication between a function and a service. sendStickyBroadcast() performs a sendBroadcast(Intent) known as sticky, i.e. the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value of registerReceiver(BroadcastReceiver, IntentFilter). For example, if you take an intent for ACTION_BATTERY_CHANGED to get battery change events: When you call registerReceiver() for that action — even with a null BroadcastReceiver — you get the Intent that was last Broadcast for that action. Hence, you can use this to find the state of the battery without necessarily registering for all future state changes in the battery.'),
            InterviewQuestionResponse(id: 3, topicId: 5, subjectId: 4, question: 'What is a Pending Intent?', answer: 'If you want someone to perform any Intent operation at future point of time on behalf of you, then we will use Pending Intent.'),
            InterviewQuestionResponse(id: 4, topicId: 5, subjectId: 4, question: 'What is an Action?', answer: 'Description of the intent. For instance, ACTION_CALL — used to perform calls'),
            InterviewQuestionResponse(id: 5, topicId: 5, subjectId: 4, question: 'What are intent Filters?', answer: 'Specifies the type of intent that the activity/service can respond to.'),

            InterviewQuestionResponse(id: 1, topicId: 6, subjectId: 4, question: 'RecyclerView ', answer: 'A flexible view for providing a limited window into a large data set or data that frequently changes. \n\nLayoutManager: \n- LayoutManager is responsible for measuring and positioning item views within a RecyclerView as well as determining the policy for when to recycle item views that are no longer visible to the user. \n- By changing the LayoutManager RecyclerView can be used to implement a standard vertically scrolling list, a uniform grid, staggered grids, horizontally scrolling collections and more. \n\nLayoutManager types: \n1) LinearLayoutManager arranges the items in a one-dimensional list. Using a RecyclerView with LinearLayoutManager provides functionality like the older ListView layout. \n2) GridLayoutManager arranges the items in a two-dimensional grid, like the squares on a checkerboard. Using a RecyclerView with GridLayoutManager provides functionality like the older GridView layout. \n3) StaggeredGridLayoutManager arranges the items in a two-dimensional grid, with each column slightly offset from the one before, like the stars in an American flag. \n\naddItemDecoration: \n- Add an to this RecyclerView. Item decorations can affect both measurement and drawing of individual item views. \n- Item decorations are ordered. Decorations placed earlier in the list will be run/queried/drawn first for their effects on item views. Padding added to views will be nested; a padding added by an earlier decoration will mean further item decorations in the list will be asked to draw/pad within the previous decoration of given area. \n\nRecyclerView Adapter: \n- A subclass of RecyclerView.Adapter responsible for providing views that represent items in a data set. \n- A view previously used to display data for a specific adapter position may be placed in a cache for later reuse to display the same type of data again later. This can drastically improve performance by skipping initial layout inflation or construction. \n- A child view that must be rebound by the adapter before being displayed. \n1) Position: The position of a data item within the adapter of data set. \n2) Index: The index of an attached child view as used in a call to ViewGroup getChildAt. Contrast with Position. \n3) Binding: The process of preparing a child view to display data corresponding to position within the adapter. \n4) ViewHolder: The ViewHolder which should be updated to represent the contents of the item at the given position in the data set. \n5) getItemCount: Returns the number of items in the adapter bound to the parent RecyclerView.'),
            InterviewQuestionResponse(id: 2, topicId: 6, subjectId: 4, question: 'RecyclerView VS ListView', answer: ''),

            InterviewQuestionResponse(id: 1, topicId: 8, subjectId: 4, question: 'What is the difference between fragments & activities. Explain the relationship between the two.', answer: 'An Activity is an application component that provides a screen, with which users can interact in order to do something whereas a Fragment represents a behavior or a portion of user interface in an Activity (with its own lifecycle and input events, and which can be added or removed at will).'),
            InterviewQuestionResponse(id: 2, topicId: 8, subjectId: 4, question: 'When should you use a fragment rather than an activity?', answer: '- When there are ui components that are going to be used across multiple activities. \n\n- When there are multiple views that can be displayed side by side (viewPager tabs) \n\n- When you have data that needs to be persisted across Activity restarts (such as retained fragments)'),
            InterviewQuestionResponse(id: 3, topicId: 8, subjectId: 4, question: 'Difference between adding/replacing fragment in backstack?', answer: '- removes the existing fragment and adds a new fragment. This means when you press back button the fragment that got replaced will be created with its onCreateView being invoked. \n\n- add retains the existing fragments and adds a new fragment that means existing fragment will be active and they wont be in paused state hence when a back button is pressed onCreateView is not called for the existing fragment(the fragment which was there before new fragment was added). \n\n- In terms of fragment’s life cycle events onPause, onResume, onCreateView and other life cycle events will be invoked in case of replace but they wont be invoked in case of add.'),
            InterviewQuestionResponse(id: 4, topicId: 8, subjectId: 4, question: 'Why is it recommended to use only the default constructor to create a Fragment?', answer: 'The reason why you should be passing parameters through bundle is because when the system restores a fragment (e.g on config change), it will automatically restore your bundle. This way you are guaranteed to restore the state of the fragment correctly to the same state the fragment was initialised with.'),
            InterviewQuestionResponse(id: 5, topicId: 8, subjectId: 4, question: 'You’re replacing one Fragment with another — how do you ensure that the user can return to the previous Fragment, by pressing the Back button?', answer: 'We need to save each Fragment transaction to the backstack, by calling addToBackStack() before you commit() that transaction'),
            InterviewQuestionResponse(id: 6, topicId: 8, subjectId: 4, question: 'Callbacks invoked during addition of a fragment to back stack and while popping back from back stack', answer: 'addOnBackStackChangedListener is called when fragment is added or removed from the backstack.'),
            InterviewQuestionResponse(id: 7, topicId: 8, subjectId: 4, question: 'What are retained fragments?', answer: 'By default, Fragments are destroyed and recreated along with their parent Activity’s when a configuration change occurs. Calling setRetainInstance(true) allows us to bypass this destroy-and-recreate cycle, signaling the system to retain the current instance of the fragment when the activity is recreated.'),
            InterviewQuestionResponse(id: 8, topicId: 8, subjectId: 4, question: 'Difference between FragmentPagerAdapter vs FragmentStatePagerAdapter?', answer: '- FragmentPagerAdapter: the fragment of each page the user visits will be stored in memory, although the view will be destroyed. So when the page is visible again, the view will be recreated but the fragment instance is not recreated. This can result in a significant amount of memory being used. FragmentPagerAdapter should be used when we need to store the whole fragment in memory. FragmentPagerAdapter calls detach(Fragment) on the transaction instead of remove(Fragment). \n\n- FragmentStatePagerAdapter: the fragment instance is destroyed when it is not visible to the User, except the saved state of the fragment. This results in using only a small amount of Memory and can be useful for handling larger data sets. Should be used when we have to use dynamic fragments, like fragments with widgets, as their data could be stored in the savedInstanceState.Also it won’t affect the performance even if there are large number of fragments.'),

            InterviewQuestionResponse(id: 1, topicId: 9, subjectId: 4, question: 'Difference between RelativeLayout and LinearLayout?', answer: '- Linear Layout — Arranges elements either vertically or horizontally. i.e. in a row or column. \n\n- Relative Layout — Arranges elements relative to parent or other elements.'),
            InterviewQuestionResponse(id: 2, topicId: 9, subjectId: 4, question: 'What is ConstraintLayout?', answer: 'It allows you to create large and complex layouts with a flat view hierarchy (no nested view groups). It’s similar to RelativeLayout in that all views are laid out according to relationships between sibling views and the parent layout, but it’s more flexible than RelativeLayout and easier to use with Android Studio’s Layout Editor.'),
            InterviewQuestionResponse(id: 3, topicId: 9, subjectId: 4, question: 'FrameLayout', answer: 'Frame Layouts are designed to contain a single item, making them an efficient choice when you need to display a single View. If you add multiple Views to a FrameLayout then it’ll stack them one above the other, so FrameLayouts are also useful if you need overlapping Views, for example if you’re implementing an overlay or a HUD element.'),
            InterviewQuestionResponse(id: 4, topicId: 9, subjectId: 4, question: 'What is View Group? How are they different from Views?', answer: '- View: View objects are the basic building blocks of User Interface(UI) elements in Android. View is a simple rectangle box which responds to the user’s actions. Examples are EditText, Button, CheckBox etc. View refers to the android.view.View class, which is the base class of all UI classes. \n\n- ViewGroup: ViewGroup is the invisible container. It holds View and ViewGroup. For example, LinearLayout is the ViewGroup that contains Button(View), and other Layouts also. ViewGroup is the base class for Layouts.'),
            InterviewQuestionResponse(id: 5, topicId: 9, subjectId: 4, question: 'Difference between padding and margin?', answer: 'Padding is for inside/within components. Eg. TextView , Button, EditText etc. \nEg. space between the Text and Border \n\nMargin is to be applied for the on-outside of the components. \nEg. space between left edge of the screen and border of your component'),

            InterviewQuestionResponse(id: 1, topicId: 10, subjectId: 4, question: 'Services', answer: 'A Service is an application component that can perform long-running operations in the background, and it does not provide a user interface. It can run in the background, even when the user is not interacting with your application. \n\nThese are the three different types of services: \n\n- Foreground Service: A foreground service performs some operation that is noticeable to the user. For example, we can use a foreground service to play an audio track. A Notification must be displayed to the user. \n\n- Background Service: A background service performs an operation that isn’t directly noticed by the user. In Android API level 26 and above, there are restrictions to using background services and it is recommended to use WorkManager in these cases. \n\n- Bound Service: A service is bound when an application component binds to it by calling bindService(). A bound service offers a client-server interface that allows components to interact with the service, send requests, receive results. A bound service runs only as long as another application component is bound to it.'),
            InterviewQuestionResponse(id: 2, topicId: 10, subjectId: 4, question: 'Difference between Service & Intent Service', answer: '- Service is the base class for Android services that can be extended to create any service. A class that directly extends Service runs on the main thread so it will block the UI (if there is one) and should therefore either be used only for short tasks or should make use of other threads for longer tasks. \n\n- IntentService is a subclass of Service that handles asynchronous requests (expressed as “Intents”) on demand. Clients send requests through startService(Intent) calls. The service is started as needed, handles each Intent in turn using a worker thread, and stops itself when it runs out of work.'),
            InterviewQuestionResponse(id: 3, topicId: 10, subjectId: 4, question: 'What are Handlers?', answer: 'Handlers are objects for managing threads. It receives messages and writes code on how to handle the message. They run outside of the activity’s lifecycle, so they need to be cleaned up properly or else you will have thread leaks. \n\n- Handlers allow communicating between the background thread and the main thread. \n\n- A Handler class is preferred when we need to perform a background task repeatedly after every x seconds/minutes.'),
            InterviewQuestionResponse(id: 4, topicId: 10, subjectId: 4, question: 'Bound Service', answer: 'A bound service is a service that allows other android components (like activity) to bind to it and send and receive data. A bound service is a service that can be used not only by components running in the same process as local service, but activities and services, running in different processes, can bind to it and send and receive data. \n\n- When implementing a bound service we have to extend Service class but we have to override onBind method too. This method returns an object that implements IBinder, that can be used to interact with the service.'),
            InterviewQuestionResponse(id: 5, topicId: 10, subjectId: 4, question: 'Difference between Activity & Service', answer: 'Activities are basically containers or windows to the user interface. Services is a component that is used to perform operations on the background. It does not have an UI.'),

            InterviewQuestionResponse(id: 1, topicId: 11, subjectId: 4, question: 'ContentProvider', answer: 'A ContentProvider provides data from one application to another, when requested. It manages access to a structured set of data. It provides mechanisms for defining data security. ContentProvider is the standard interface that connects data in one process with code running in another process. \n\nWhen you want to access data in a ContentProvider, you must instead use the ContentResolver object in your application’s Context to communicate with the provider as a client. The provider object receives data requests from clients, performs the requested action, and returns the results.'),
            InterviewQuestionResponse(id: 2, topicId: 11, subjectId: 4, question: 'Access data using Content Provider', answer: 'Start by making sure your Android application has the necessary read access permissions. Then, get access to the ContentResolver object by calling getContentResolver() on the Context object, and retrieving the data by constructing a query using ContentResolver.query(). \n\nThe ContentResolver.query() method returns a Cursor, so you can retrieve data from each column using Cursor methods.'),

            InterviewQuestionResponse(id: 1, topicId: 1, subjectId: 6, question: 'What is React Native?', answer: 'React Native is a most used JavaScript Framework. React Native is a next generation of React mobile framework. Native framework is most used for building Mobile apps and web apps. It helps developers reuse code across the web and on Mobile application. Native app creation; it means writing apps for a specific operating system. Mainly it builds native mobile apps using JavaScript and React Framework.'),
            InterviewQuestionResponse(id: 2, topicId: 1, subjectId: 6, question: 'What is the props?', answer: 'Props are used to customize the components by giving them different parameters. Each component has its infrequent ability to customize the component.'),
            InterviewQuestionResponse(id: 3, topicId: 1, subjectId: 6, question: 'What does StyleSheet.create do?', answer: 'StyleSheet.create method ensures that values are immutable and opaque, they are also only created once.'),
            InterviewQuestionResponse(id: 4, topicId: 1, subjectId: 6, question: 'What is State?', answer: 'State is a triggering method which is used to refresh or update values in the component.'),
            InterviewQuestionResponse(id: 5, topicId: 1, subjectId: 6, question: 'What is native apps means?', answer: 'A native app is a program that has been coded in a specific programming language like Objective –C, java, Swift etc. It live on the device and are accessed through icons on the device home screen. Native mobile applications provide fast performance and a high degree of reliability. Native apps are installed through an application store (such as Google Play or Apple’s App Store). It supports both online and offline transactions.'),
            InterviewQuestionResponse(id: 6, topicId: 1, subjectId: 6, question: 'What is a Hybrid app?', answer: 'A hybrid app is a program that is built using HTML 5, CSS and JavaScript and wrapped in native container.'),
            InterviewQuestionResponse(id: 7, topicId: 1, subjectId: 6, question: 'What is HOC?', answer: 'HOC (Higher Order Component) is an advanced technique in React for reusing component logic. Hoc is a function that takes a component and returns a new component.'),
            InterviewQuestionResponse(id: 8, topicId: 1, subjectId: 6, question: 'Why animation very clear in React Native?', answer: 'The animated API was designed with a very important constraint in mind, it is serializable. This means we can send everything about the animation to native before it has even started and allows native code to perform the animation on the UI thread without having to go through the bridge on every frame. It is very useful because once the animation has started, the JS thread can be blocked and the animation will still run smoothly. React Native provides extremely smooth animations because the code is converted to native views before rendering.'),
            InterviewQuestionResponse(id: 9, topicId: 1, subjectId: 6, question: 'How Virtual DOM works in React Native?', answer: 'React creates an in-memory data structure cache, computes the resulting differences, and then updates the browser’s displayed DOM efficiently. This allows developers to write code as if the entire page is rendered on each change while the React libraries only render subcomponents that actually change.'),
            InterviewQuestionResponse(id: 10, topicId: 1, subjectId: 6, question: 'Is React Native a native mobile App?', answer: 'Yes, React Native compiles a native mobile app using native app components. It’s neither a Hybrid Mobile app that uses Web View to run the HTML5 app or a mobile web app. React Native builds a real mobile app that’s indistinguishable from an app built using Objective-C or Java.'),
            InterviewQuestionResponse(id: 11, topicId: 1, subjectId: 6, question: 'What is the difference between ReactJS and React Native?', answer: '- ReactJS is a JavaScript framework used for developing mobile or web apps in HTML5 using JavaScript language. \n\n- React Native is used to develop native mobile apps using JavaScript language.'),
            InterviewQuestionResponse(id: 12, topicId: 1, subjectId: 6, question: 'What are Refs in React?', answer: 'Refs are an escape hatch which allows you to get direct access to a DOM element or an instance of a component. In order to use them you add a ref attribute to your component whose value is a callback function which will receive the underlying DOM element or the mounted instance of the component as its first argument.'),
            InterviewQuestionResponse(id: 13, topicId: 1, subjectId: 6, question: 'When should I start using Redux with React Native?', answer: 'Unless your app is a video game or dealing with only a handful of entirely disconnected views, I can’t imagine a situation where shared global state is not required. Even shifting from one active tab to another can be seen as a global state change. If you end up using react-navigation, redux can be easily incorporated as part of the project setup.'),
            InterviewQuestionResponse(id: 14, topicId: 1, subjectId: 6, question: 'Which node_modules will run in React Native?', answer: 'In React Native, any pure JavaScript libarary that does not rely on node.js runtime modules .and does not rely on web specific concepts like window.location.pathname will run fine. But we have to be mindful because there’s no way to test for this with Babel—it doesn’t scan these libraries for offending dependencies. A module that uses window.location.pathname may fail at runtime in a different unexpected place.'),
            InterviewQuestionResponse(id: 15, topicId: 1, subjectId: 6, question: 'What are the key advantages of React Native?', answer: '- It is free and opensource \n- Community driven \n- Single code used \n- Code sharing in different platforms \n- Cost saving and reuse code \n- Live reload or preview \n- Hybrid apps native performance \n- Increase development speed \n- Modular and intuitive architecture similar to React'),
            InterviewQuestionResponse(id: 16, topicId: 1, subjectId: 6, question: 'What are the Cons of React Native?', answer: '\n- Memory management \n- Security problem \n- Single threadedness \n- Native code required (Not support all native APIs) \n- Depended on third party libraries \n- App performance: React Native apps are not equivalent to true native apps written entirely in Swift/Obj-C or Java.'),

            //KOTLIN
            InterviewQuestionResponse(id: 1, topicId: 1, subjectId: 5, question: 'What is Kotlin?', answer: 'Kotlin is a general-purpose, statically typed, and open-source programming language. It runs on JVM and can be used anywhere Java is used today. It can be used to develop Android apps, server-side apps and much more.'),
            InterviewQuestionResponse(id: 2, topicId: 1, subjectId: 5, question: 'History of Kotlin?', answer: 'Kotlin was developed by JetBrains team. A project was started in 2010 to develop the language and officially, first released in February 2016. Kotlin was developed under the Apache 2.0 license.'),
            InterviewQuestionResponse(id: 3, topicId: 1, subjectId: 5, question: 'Features of Kotlin?', answer: 'Concise - Kotlin reduces writing the extra codes. This makes Kotlin more concise.\n\n - Null safety - Kotlin is null safety language. Kotlin aimed to eliminate the NullPointerException (null reference) from the code. \n\n - Interoperable - Kotlin easily calls the Java code in a natural way as well as Kotlin code can be used by Java. \n\n - Smart cast - It explicitly typecasts the immutable values and inserts the value in its safe cast automatically. \n\n - Compilation Time - It has better performance and fast compilation time. \n\n - Tool-friendly - Kotlin programs are build using the command line as well as any of Java IDE. \n\n - Extension function - Kotlin supports extension functions and extension properties which means it helps to extend the functionality of classes without touching their code.'),

            InterviewQuestionResponse(id: 1, topicId: 2, subjectId: 5, question: 'What is variable?', answer: '1) var (Mutable variable): We can change the value of variable declared using var keyword later in the program. \n2) val (Immutable variable): We cannot change the value of variable which is declared using val keyword.'),

            InterviewQuestionResponse(id: 1, topicId: 3, subjectId: 5, question: 'Data type', answer: 'Number \nCharacter \nBoolean \nArray \nString'),

            InterviewQuestionResponse(id: 1, topicId: 4, subjectId: 5, question: 'Type Conversion', answer: 'Type conversion is a process in which one data type variable is converted into another data type. In Kotlin, implicit conversion of smaller data type into larger data type is not supported (as it supports in java). \nFor example Int cannot be assigned into Long or Double.'),

            InterviewQuestionResponse(id: 1, topicId: 12, subjectId: 5, question: 'Collections', answer: 'Collections in Kotlin are used to store group of related objects in a single unit. By using collection, we can store, retrieve manipulate and aggregate data.'),
            InterviewQuestionResponse(id: 2, topicId: 12, subjectId: 5, question: 'Types of Kotlin Collections', answer: '- Immutable Collection (or Collection) \n- Immutable collection also called Collection supports read only functionalities.  \n\n- Mutable Collection \n- Mutable collections supports both read and write functionalities.'),
            InterviewQuestionResponse(id: 3, topicId: 12, subjectId: 5, question: 'Map Interface', answer: 'otlin Map is an interface and generic collection of elements. Map interface holds data in the form of key and value pair. Map key are unique and holds only one value for each key. The key and value may be of different pairs such as <Int, Int>,<Int, String>, <Char, String>etc. This interface is immutable, fixed size and its methods support read only access. \n\nTo use the Map interface we need to use its function called mapOf() or mapOf<k,v>().'),
            InterviewQuestionResponse(id: 4, topicId: 12, subjectId: 5, question: 'MutableMap Interface', answer: 'Kotlin MutableMap is an interface of collection framework that holds the object in the form of key and value pair. The values of MutableMap interface are retrieved by using their corresponding keys. The key and value may be of different pairs such as <Int, Int>,<Int, String>, <Char, String> etc. Each key of MutableMap holds only one value. \n\nTo use the MutableMap interface we need to use its function called mutableMapOf() or mutableMapOf <k,v>().'),
            InterviewQuestionResponse(id: 5, topicId: 12, subjectId: 5, question: 'Set Interface', answer: 'Kotlin Set interface is a generic unordered collection of elements. Set interface does not support duplicate elements. This interface is immutable in nature its methods supports read-only functionality of the set. \n\nSet interface uses setOf() function to create the list of object of set interface which contains list of elements.'),
            InterviewQuestionResponse(id: 6, topicId: 12, subjectId: 5, question: 'MutableSet Interface', answer: 'MutableSet interface is a generic unordered collection of elements. MutableSet interface does not support duplicate elements. This interface is mutable so its methods support read-write functionality supports adding and removing elements. \n\nSet interface uses mutableSetOf() function to create the list of object of set interface which contains list of elements.'),
            InterviewQuestionResponse(id: 7, topicId: 12, subjectId: 5, question: 'Set Interface', answer: 'Set interface is a generic unordered collection of elements. Set interface does not support duplicate elements. This interface is immutable in nature its methods supports read-only functionality of the set. \n\nSet interface uses setOf() function to create the list of object of set interface which contains list of elements.'),
            InterviewQuestionResponse(id: 8, topicId: 12, subjectId: 5, question: 'HashSet', answer: 'HashSet is class of collection which extends AbstractMutableSet class and implements Set interface. The HashSet class store elements using hashing mechanism. It support both read and write functionality. It does not support duplicate value and does not make guarantees about the order sequence of element.'),

            InterviewQuestionResponse(id: 1, topicId: 15, subjectId: 5, question: 'Sealed Class', answer: 'Sealed class is a class which restricts the class hierarchy. A class can be declared as sealed class using "sealed" keyword before the class name. It is used to represent restricted class hierarchy. \n\nSealed class is used when the object have one of the types from limited set, but cannot have any other type. \n\nThe constructors of sealed classes are private in default and cannot be allowed as non-private. \n\nsealed class MyClass'),
            InterviewQuestionResponse(id: 2, topicId: 15, subjectId: 5, question: 'Sealed class with when', answer: 'Sealed classes are commonly used with when expression. As the sub classes of sealed classes have their own types act as a case. Due to this, when expression in sealed class covers all the cases and avoid to add else clause.'),
            InterviewQuestionResponse(id: 3, topicId: 15, subjectId: 5, question: 'Abstract class', answer: 'A class which is declared with abstract keyword is known as abstract class. An abstract class cannot be instantiated. Means, we cannot create object of abstract class. The method and properties of abstract class are non-abstract unless they are explicitly declared as abstract. \n\nabstract class A {  var x = 0  abstract fun doSomething()  } \n\nAbstract classes are partially defined classes, methods and properties which are no implementation but must be implemented into derived class. If the derived class does not implement the properties of base class then is also meant to be an abstract class. \n\nAbstract class or abstract function does not need to annotate with open keyword as they are open by default. Abstract member function does not contain its body. The member function cannot be declared as abstract if it contains in body in abstract class.'),
            InterviewQuestionResponse(id: 4, topicId: 15, subjectId: 5, question: 'Abstract class by default method?', answer: 'The methods which are only declared without their method body are abstract by default.'),
            InterviewQuestionResponse(id: 5, topicId: 15, subjectId: 5, question: 'Inheritance', answer: 'Inheritance is an important feature of object oriented programming language. Inheritance allows to inherit the feature of existing class (or base or parent class) to new class (or derived class or child class). \n\nThe main class is called super class (or parent class) and the class which inherits the superclass is called subclass (or child class). The subclass contains features of superclass as well as its own. \n\nThe concept of inheritance is allowed when two or more classes have same properties. It allows code reusability. A derived class has only one base class but may have multiple interfaces whereas a base class may have one or more derived classes. \n\nIn Kotlin, the derived class inherits a base class using: operator in the class header (after the derive class name or constructor)'),
            InterviewQuestionResponse(id: 6, topicId: 15, subjectId: 5, question: 'open keyword', answer: 'As Kotlin classes are final by default, they cannot be inherited simply. We use the open keyword before the class to inherit a class and make it to non-final \n\nopen class Example{ }'),
            InterviewQuestionResponse(id: 7, topicId: 15, subjectId: 5, question: 'Interface', answer: 'An interface is a blueprint of class.Kotlin interface is similar to Java 8. It contains abstract method declarations as well as implementation of method. \ninterface MyInterface { }'),
            InterviewQuestionResponse(id: 8, topicId: 15, subjectId: 5, question: 'Why use Kotlin interface?', answer: '\nUsing interface supports functionality of multiple inheritance. \n\n- It can be used achieve to loose coupling. \n\n- It is used to achieve abstraction. \n\nSubclass extends only one super class but implements multiple interfaces. Extension of parent class or interface implementation are done using (:) operator in their subclass.'),
            InterviewQuestionResponse(id: 9, topicId: 15, subjectId: 5, question: 'Implementing Interfaces?', answer: 'e are implementing the interface MyInterface in InterfaceImp class. InterfaceImp class provides the implementation of property id and abstract method absMethod() declared in MyInterface interface.'),
            InterviewQuestionResponse(id: 10, topicId: 15, subjectId: 5, question: 'Implementing multiple interface', answer: 'We can implement multiple abstract methods of different interfaces in same class. All the abstract methods must be implemented in subclass. The other non-abstract methods of interface can be called from derived class. \n\nFor example, creating two interface MyInterface1 and MyInterface2 with abstract methods doSomthing() and absMethod() respectively. These abstract methods are overridden in derive class MyClass.'),
            InterviewQuestionResponse(id: 11, topicId: 15, subjectId: 5, question: 'Extension Function', answer: 'extension function provides a facility to "add" methods to class without inheriting a class or using any type of design pattern. The created extension functions are used as a regular function inside that class. /n/nThe extension function is declared with a prefix receiver type with method name. /nfun <class_name>.<method_name>()'),
            InterviewQuestionResponse(id: 12, topicId: 15, subjectId: 5, question: 'Data class', answer: 'Data class is a simple class which is used to hold data/state and contains standard functionality. A data keyword is used to declare a class as a data class. \n\ndata class User(val name: String, val age: Int) \n\nDeclaring a data class must contains at least one primary constructor with property argument (val or var). \n\nRequirements of data class \n-Contain primary constructor with at least one parameter. \n- Parameters of primary constructor marked as val or var. \n- Data class cannot be abstract, inner, open or sealed. \n- Before 1.1,data class may only implements interface. After that data classes may extend other classes.'),
            InterviewQuestionResponse(id: 13, topicId: 15, subjectId: 5, question: 'data class copy()', answer: 'The data class provides a copy() method which is used to create a copy (or colon) of object. Using copy() method, some or all properties of object can be altered.'),
            InterviewQuestionResponse(id: 14, topicId: 15, subjectId: 5, question: 'Default and named arguments in data class.', answer: 'We can also assign the default arguments in primary constructor of data class. These default values can be changed later on program if required.'),
            InterviewQuestionResponse(id: 15, topicId: 15, subjectId: 5, question: 'Visibility Modifier', answer: 'Visibility modifiers are the keywords which are used to restrict the use of class, interface, methods, and property of Kotlin in the application. These modifiers are used at multiple places such as class header or method body. \n\n- public - A public modifier is accessible from everywhere in the project. It is a default modifier in Kotlin. If any class, interface etc. are not specified with any access modifier then that class, interface etc. are used in public scope. All public declaration can be placed at top of the file. If a member of class is not specified then it is by default public. \n\n- protected - A protected modifier with class or interface allows visibility to its class or subclass only. A protected declaration (when overridden) in its subclass is also protected modifier unless it is explicitly changed. In Kotlin, protected modifier cannot be declared at top level. \n\n- internal - The internal modifiers are newly added in Kotlin, it is not available in Java. Declaring anything makes that field marked as internal field. The internal modifier makes the field visible only inside the module in which it is implemented. all the fields are declared as internal which are accessible only inside the module in which they are implemented. \n\n- private - A private modifier allows the declaration to be accessible only within the block in which properties, fields, etc. are declare. The private modifier declaration does not allow to access the outside the scope. A private package can be accessible within that specific file.'),

            InterviewQuestionResponse(id: 1, topicId: 16, subjectId: 5, question: 'Null Safety', answer: 'Kotlin null safety is a procedure to eliminate the risk of null reference from the code. Kotlin compiler throws NullPointerException immediately if it found any null argument is passed without executing any other statements. \nKotlin type system is aimed to eliminate NullPointerException form the code. NullPointerException can only possible on following causes: -An forcefully call to throw NullPointerException(); \n- An uninitialized of this operator which is available in a constructor passed and used somewhere. \n- Use of external java code as Kotlin is Java interoperability.'),
            InterviewQuestionResponse(id: 2, topicId: 16, subjectId: 5, question: 'Kotlin Nullable Types and Non-Nullable Types', answer: 'Kotlin types system differentiates between references which can hold null (nullable reference) and which cannot hold null (non null reference). Normally,types of String are not nullable. To make string which holds null value, we have to explicitly define them by putting a ? behind the String as: String? \n\n- Nullable Types - Nullable types are declared by putting a ? \n- Non Nullable Types - Non nullable types are normal strings which are declared as String.'),
            InterviewQuestionResponse(id: 3, topicId: 16, subjectId: 5, question: 'Elvis Operator (?:)', answer: 'Elvis operator (?:) is used to return the not null value even the conditional expression is null. It is also used to check the null safety of values'),

            InterviewQuestionResponse(id: 1, topicId: 1, subjectId: 7, question: 'What is SEO and introduce its types?', answer: 'Search engine optimization or SEO is a process of keep changing the position of a web page or website in a search engine results by using keywords or phrases. \nTwo Types of SEO are: \n- On Page Optimization \n- Off Page Optimization'),
            InterviewQuestionResponse(id: 2, topicId: 1, subjectId: 7, question: 'What are the SEO tools do you use?', answer: 'The SEO tools that I use are Google analytic, Keyword Planner, Alexa, open site explorer, Google Webmaster.'),
            InterviewQuestionResponse(id: 3, topicId: 1, subjectId: 7, question: 'What do you mean by Backlink?', answer: 'The incoming links to your website or webpage are referred to as Backlink. It is also called as an inbound link.'),
            InterviewQuestionResponse(id: 4, topicId: 1, subjectId: 7, question: 'What are outbound Links?', answer: 'The outbound links are a Links, from your website to another webpage or website.'),
            InterviewQuestionResponse(id: 5, topicId: 1, subjectId: 7, question: 'Can you tell me something about Googlebot?', answer: 'To index and update a webpage Google uses the Googlebot (Web Spider). Caching, Crawling and indexing of a webpage are done through Googlebot by collecting details from that webpage.'),
            InterviewQuestionResponse(id: 6, topicId: 1, subjectId: 7, question: 'What is Cross-linking and what is the function of Crosslinking?', answer: '- Cross-linking is the process of linking one site to another site. \n\n- It provides the users with reference sites that contain the content related to the search. \n\n- The 2 websites cross-linking do not be owned by the same person. \n\n- In other words, cross-linking is a barter wherein I link to you and you link to me. \n\n- It could be a 2-way link oe 3-way link. In a 2 way link site A links to site B and site B links to site A. In a 3 way link, \n\n- site A links to site B, site B links to site C and site C links to site A.'),
            InterviewQuestionResponse(id: 7, topicId: 1, subjectId: 7, question: 'What is the main purpose of using keyword in SEO?', answer: 'Keyword is a single word, and while a combination of those keywords makes phrases. These keywords or phrases are used by the search engines to populate the subjects over the internet. Search engine stores keywords in the database, and when search is done, it will come up with the best possible match.'),
            InterviewQuestionResponse(id: 8, topicId: 1, subjectId: 7, question: 'Can you mention the functions of body content relevance?', answer: 'Whenever there is a text that does not have images on the web page is referred as body content relevance or non-image text. It helps in good optimization of the sites and also to improve your ranking in the search engine.'),
            InterviewQuestionResponse(id: 9, topicId: 1, subjectId: 7, question: 'What are Spiders, Robots and Crawlers and what are their functions?', answer: 'Spiders, robot and crawler, they are all same and referred by different names. It is a software program that follows, or “Crawls” different links throughout the internet, and then grabs the content from the sites and adds to the search engine indexes.'),
            InterviewQuestionResponse(id: 10, topicId: 1, subjectId: 7, question: 'What does it mean if nothing appears on doing search on the domain?', answer: 'On doing search on your domain and if nothing appears then there are three possibilities. \n- May be the site is banned by search engines \n- May be no index by search engines \n- Some canonical issues'),
            InterviewQuestionResponse(id: 11, topicId: 1, subjectId: 7, question: 'What is keyword stemming?', answer: 'The process of finding out new keywords from the root keyword from the search query is referred as keywords stemming. Adding a prefix, suffix, or pluralization can be used to create the new keyword.'),
            InterviewQuestionResponse(id: 12, topicId: 1, subjectId: 7, question: 'Name some SEO blogs that you frequently read?', answer: '- Google Webmaster Central \n- Search Engine Land \n- SEOSmarty \n- MOZ \n- Search Engine Journal \n- BacklinkO'),
            InterviewQuestionResponse(id: 13, topicId: 1, subjectId: 7, question: 'What do you mean by Cloaking?', answer: 'Cloaking is a deceptive way of optimizing your website for search. In this technique, a different content will be show to the search engine crwaler than what is presented to the end users.'),
            InterviewQuestionResponse(id: 14, topicId: 1, subjectId: 7, question: 'How many types of Meta Tags are there in SEO and what are their characters limits?', answer: '- Meta Description tag with 1200 pixels limits \n- Meta Keyword tag \n- Title Tag with 600 pixels limits \n- Meta Robots'),
            InterviewQuestionResponse(id: 15, topicId: 1, subjectId: 7, question: 'How many characters limits in & Meta Description tag?', answer: 'We can add 70 characters in title tag and 222 characters in Meta Description tag. Though google now places a pizel limit.'),
            InterviewQuestionResponse(id: 16, topicId: 1, subjectId: 7, question: 'What is Google Sandbox?', answer: 'Google sandbox is an imaginary area where new websites and their search rating are put on hold until they prove worthy for ranking. In other words, it checks the standard of the website.'),
            InterviewQuestionResponse(id: 17, topicId: 1, subjectId: 7, question: 'Tell me something about Black Hat SEO?', answer: 'In order to get a high ranking in search engine result page, websites go for various methods and techniques which are characterized by two categories. One method that is acceptable by search engine guidelines is known as White Hat SEO, while the other method which is not acceptable by search engine guidelines is known as Black Hat SEO.'),
            InterviewQuestionResponse(id: 18, topicId: 1, subjectId: 7, question: 'Name few Black Hat SEO techniques?', answer: '- Link Farming \n- Hidden text, etc. \n- Gateway or Doorway pages \n- Cloaking \n- Keyword Stuffing'),
            InterviewQuestionResponse(id: 19, topicId: 1, subjectId: 7, question: 'Can you differentiate between ‘nofollow’ and ‘dofollow’ link?', answer: 'Nofollow links do not pass Link juice and have no impact on Google Ranking Algorithm. Dofollow link passes link juice and has an impact on Google Ranking Algorithm.'),
            InterviewQuestionResponse(id: 20, topicId: 1, subjectId: 7, question: 'What is the difference between PR (page rank) and SERP (Search engine result page)?', answer: 'Page rank is calculated on the basis of quality inbound links from other website or webpages to our webpage or a website. \n- SERP (Search Engine Result page) is the placement of the website or web-pages which is returned by the search engine after a search query or attribute.'),
            InterviewQuestionResponse(id: 21, topicId: 1, subjectId: 7, question: 'Why the Title Tag in website is valuable?', answer: 'Title tags are very essential in SEO, as it tells about the contents on that web page. Through title tags only the search engine will tell the user, what is there in the page.'),
            InterviewQuestionResponse(id: 22, topicId: 1, subjectId: 7, question: 'What is considered as more significant, creating content or building backlinks?', answer: 'Both are necessary, creating quality content is equally important to building backlinks. Although, building backlinks are useful in building authority to a site and for ranking as well, quality content is the first element that is considered to be more responsible for ranking.'),
            InterviewQuestionResponse(id: 23, topicId: 1, subjectId: 7, question: 'Can you mention the difference between SEO and SEM?', answer: 'SEM (Search Engine Marketing), it is used for the promotion of website through paid advertising by increasing their visibility in Search Engine Result Page (SERP) in the Ads section.  While SEO is optimizing the site to increase the organic ranking of a site.'),
            InterviewQuestionResponse(id: 24, topicId: 1, subjectId: 7, question: 'What do you know about LSI?', answer: 'LSI stands for Latent Semantic Indexing. This technique is established to obtain the data by relating the word to its closest counterparts or to its similar context. For example, if you are searching something with a keyword “CAR” it will show all the related things like classic cars, car auctions, Bentley car, car race etc.'),
            InterviewQuestionResponse(id: 25, topicId: 1, subjectId: 7, question: 'How will you cross-check whether your SEO campaign is working or not?', answer: 'To check whether your SEO campaign is working or not, the first approach is to check the websites statistics, which tells you about the origin of traffic.  The other way of checking is to make a search based on the relevant keywords and key phrases and look for the search result. The number of search result will tell you whether your SEO campaign is working or not.'),
            InterviewQuestionResponse(id: 26, topicId: 1, subjectId: 7, question: 'What is the meaning of competitive analysis?', answer: 'Competitive analysis does the comparison, between the website I am optimizing, and the website that is ranked highly in search results.'),
            InterviewQuestionResponse(id: 27, topicId: 1, subjectId: 7, question: 'What will be your next steps if your SEO methods or technique does not work?', answer: 'My first attempt would to try analysis the problem and resolve them step by step \n- Firstly I would try to see whether it is a new project, and then like to re-check the key words. \n- Also, I would look for relevant key-words that can be helpful. \n- Even though the webpage and website has been indexed well and still not appearing on the first 10 pages of search engine result page, then I would make some changes in page text, titles and description. \n- If website is not indexed well or dropped from the index, than it might comprises serious issues and re-work might be required.'),
            InterviewQuestionResponse(id: 28, topicId: 1, subjectId: 7, question: 'What is PPC?', answer: 'PPC stands for Pay Per Click and is an advertisement campaign hosted by Google.  It is segmented into two modules CPC ( Cost per click) and CPM ( Cost per thousand impressions) through flat rate and bidding respectively. In CPC, if the user clicks on the advert, only then the advertiser will be charged.'),
            InterviewQuestionResponse(id: 29, topicId: 1, subjectId: 7, question: 'What is 301 redirect?', answer: 'It is a method by which the user is redirected to new page url to old page url . It is a permanent redirect and it is also useful in directing link juice to new url from old url.'),
            InterviewQuestionResponse(id: 30, topicId: 1, subjectId: 7, question: 'What are Webmaster tools?', answer: 'Webmaster tool is a service provided by Google from where you can get backlink information, crawl errors, search queries, Indexing data, CTR etc.'),
            InterviewQuestionResponse(id: 31, topicId: 1, subjectId: 7, question: 'What is keyword density and what is the formula for knowing keyword density?', answer: 'From SEO point of view, keyword density will definitely help to stand out your content from others. The formula to know the keyword density is ( Total number of keyword/ total number of words in your article) multiply by 100.'),
            InterviewQuestionResponse(id: 32, topicId: 1, subjectId: 7, question: 'What is robots.txt? ', answer: 'Robots.txt is a text file. It is through this file, it gives instruction to search engine crawlers about indexing and caching of a webpage, file of a website or directory, domain.'),
            InterviewQuestionResponse(id: 33, topicId: 1, subjectId: 7, question: 'What will you do, for the company website you are working for, decides to move all the contents to new domain?', answer: 'The first step would be to update the previous site with a permanent redirect to new page for all the pages. After that, I will remove the previous content from search engine in order to avoid duplicate content issues.'),
            InterviewQuestionResponse(id: 34, topicId: 1, subjectId: 7, question: 'Can you optimize the website which has pages in millions?', answer: 'From SEO point of view, for dynamic website, special additional SEO stuffs have to be implemented. \n- Good Internal link structure \n- Generation of dynamic title and description \n- Dynamic XML sitemap generation'),
            InterviewQuestionResponse(id: 35, topicId: 1, subjectId: 7, question: 'What is the latest update in SEO?', answer: '- Panda \n- Penguin'),
            InterviewQuestionResponse(id: 36, topicId: 1, subjectId: 7, question: 'What are the key aspects of Panda update?', answer: 'Panda is to improve the search in Google. The latest version has focused on quality content, proper design, proper speed, proper use of images and many more.'),
            InterviewQuestionResponse(id: 37, topicId: 1, subjectId: 7, question: 'What are the key aspects of Penguin update?', answer: 'Penguin is the code name for Google algorithm. Its main target is to decrease the ranking of that website that are violating the Google Webmaster guidelines. These guidelines are violated by using black hat techniques like cloaking and stuffing.'),
            InterviewQuestionResponse(id: 38, topicId: 1, subjectId: 7, question: 'How will you neutralize a toxic link to your site?', answer: 'Through Backlink Quality Checker you can know who links to your website. Now, you have to go to ‘ Toxic link’ report, where you will find all the links, that are harmful to your websites. If there is any link in ‘ Toxic link report’ that matches with the link on your website, then you can remove it by using ‘Google Disavov tool’.'),
            InterviewQuestionResponse(id: 39, topicId: 1, subjectId: 7, question: 'Mention how can you check if someone is not building or re-directing a low-quality backlink to your site?', answer: 'To prevent someone from building or re-directing a low-quality links to your site, you can use tools like, \n- Ahrefs \n- Open Site Explorer'),
            InterviewQuestionResponse(id: 40, topicId: 1, subjectId: 7, question: 'How backlink tools work?', answer: 'Backlink tools runs a series of tests to tell you how many backlinks are pointing to the weblink you entered.  Additional information is also being collected like anchor text used, Domain Authority & Trust  of the backlink source, and any potential flags or warnings for each individual link.'),
            InterviewQuestionResponse(id: 41, topicId: 1, subjectId: 7, question: 'Mention how often should you perform a link audit?', answer: 'A link audit may be tedious and complicated process.  If you have just started on building links you can do audit quite often.  But a complete link audit should be done approximately once a year.'),
            InterviewQuestionResponse(id: 42, topicId: 1, subjectId: 7, question: 'Mention what do you understand by Frames in HTML?', answer: 'A Frame in HTML is a technique that divides the content of a page onto several parts.  Search engines consider Frames as completely different pages and may have a negative impact on SEO. We should avoid the usage of Frames and use basic HTML instead.'),
            InterviewQuestionResponse(id: 43, topicId: 1, subjectId: 7, question: 'Mention which is the most important area to include your keywords?', answer: 'The most important area to include your keywords are, \n- Page title \n- Body text \n- Meta Description'),
            InterviewQuestionResponse(id: 44, topicId: 1, subjectId: 7, question: 'What if your website is banned by the search engines for black hat practices?', answer: 'If your website is banned by the search engines for black hat practices, you can apply for re-inclusion after correcting your wrong doings.'),
            InterviewQuestionResponse(id: 45, topicId: 1, subjectId: 7, question: 'Mention what will be your approach if your SEO method don’t work?', answer: 'If the SEO method doesn’t work then do the  following, \n- First see whether it is a new project then re-check the keywords \n- Then look for relevant keywords that can be helpful \n- Make changes in page text, title and description \n- If still not ranked then there may be some other serious issues like bad links, penguin/panda or other Google penalty, crawlability issues, UI issue etc.'),

            //InterviewQuestionResponse(id: 24, topicId: 1, subjectId: 3, question: '', answer: ''),
      ];